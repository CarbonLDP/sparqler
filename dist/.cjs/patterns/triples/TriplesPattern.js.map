{"version":3,"sources":["patterns/triples/TriplesPattern.ts"],"names":[],"mappings":"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","file":"TriplesPattern.js","sourcesContent":["import { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tElementPattern,\n\tGraphPattern,\n\tSupportedNativeTypes,\n\tTriplesNodePattern,\n\tTriplesSameSubject,\n\tTriplesSameSubjectMore,\n} from \"./..\";\nimport {\n\tSAME_PROPERTY_SEPARATOR,\n\tSAME_SUBJECT_SEPARATOR,\n} from \"./../tokens\";\nimport {\n\tLiteral,\n\tResource,\n\tVariable,\n} from \"./\";\nimport {\n\tLeftSymbol,\n\tOperator,\n\tRightSymbol,\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\nimport { serialize } from \"./../../utils/ObjectPattern\";\n\nexport abstract class TriplesPattern<T extends GraphPattern> implements TriplesSameSubject<T>, ElementPattern {\n\n\tprotected abstract elementTokens:Token[];\n\tprotected patternTokens:Token[];\n\n\tprotected interfaces:{\n\t\taddPattern:TriplesSameSubjectMore<T>;\n\t\tgraphPattern?:T\n\t};\n\n\tprivate resolver:IRIResolver;\n\n\tconstructor( resolver:IRIResolver ) {\n\t\tthis.resolver = resolver;\n\t\tthis.patternTokens = [];\n\t\tthis.init();\n\t}\n\n\n\thas( property:string | Variable | Resource, object:SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern ):TriplesSameSubjectMore<T> & T;\n\thas( property:string | Variable | Resource, objects:(SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern)[] ):TriplesSameSubjectMore<T> & T;\n\thas( property:string | Variable | Resource, objects ):TriplesSameSubjectMore<T> & T {\n\t\tthis.patternTokens = [];\n\t\treturn this._addPattern( property, objects );\n\t}\n\n\tgetSelfTokens():Token[] {\n\t\treturn this.elementTokens;\n\t}\n\n\tprotected init():void {\n\t\tthis.interfaces = {\n\t\t\taddPattern: {\n\t\t\t\tand: ( property, objects ) => {\n\t\t\t\t\tthis.patternTokens.push( SAME_SUBJECT_SEPARATOR );\n\t\t\t\t\treturn this._addPattern( property, objects );\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t};\n\n\tprivate _addPattern( property:string | Variable | Resource, objects:ElementPattern | ElementPattern[] ):TriplesSameSubjectMore<T> & T {\n\t\tlet tokens:Token[] = ( typeof property === \"string\" )\n\t\t\t? this._resolvePath( property )\n\t\t\t: property.getSelfTokens();\n\n\t\tobjects = Array.isArray( objects ) ? objects : [ objects ];\n\t\tobjects.forEach( ( value, index, array ) => {\n\t\t\ttokens.push( ...serialize( value ) );\n\t\t\tif( index < array.length - 1 ) tokens.push( SAME_PROPERTY_SEPARATOR );\n\t\t} );\n\n\t\tthis.patternTokens.push( ...tokens );\n\t\treturn Object.assign( {}, this.interfaces.addPattern, this.interfaces.graphPattern );\n\t}\n\n\tprivate static PATH_OPERATORS:string[] = [ \"|\", \"/\", \"^\", \"?\", \"*\", \"+\", \"!\", \"(\", \")\" ];\n\n\tprivate _resolvePath( propertyPath:string ):Token[] {\n\t\tconst tokens:Token[] = propertyPath\n\t\t\t.split( /(<.*?>)/ ).reduce( ( array:string[], part:string ) => {\n\t\t\t\t// Is an IRI\n\t\t\t\tif( part.startsWith( \"<\" ) ) {\n\t\t\t\t\tarray.push( part );\n\t\t\t\t}\n\n\t\t\t\t// Everything else\n\t\t\t\telse {\n\t\t\t\t\tarray.push( ...part.split( /([|/^?*+!()])/ ) )\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\t\t\t}, [] )\n\t\t\t.reduce( ( array:Token[], part:string ) => {\n\t\t\t\tif( ! part ) return array;\n\n\t\t\t\t// Operators\n\t\t\t\tif( TriplesPattern.PATH_OPERATORS.indexOf( part ) !== - 1 ) {\n\t\t\t\t\tarray.push( new Operator( part ) );\n\t\t\t\t}\n\n\t\t\t\t// \"a\" keyword\n\t\t\t\telse if( part === \"a\" ) {\n\t\t\t\t\tarray.push( new StringLiteral( part ) );\n\t\t\t\t}\n\n\t\t\t\t// IRI or prefix\n\t\t\t\telse {\n\t\t\t\t\tif( part.startsWith( \"<\" ) && part.endsWith( \">\" ) ) part = part.slice( 1, - 1 );\n\t\t\t\t\tarray.push( ...this.resolver.resolve( part, true ) );\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\t\t\t}, [] );\n\n\n\t\tif( tokens[ 0 ] instanceof Operator )\n\t\t\ttokens.unshift( new LeftSymbol( \"\" ) );\n\t\tif( tokens[ tokens.length - 1 ] instanceof Operator )\n\t\t\ttokens.push( new RightSymbol( \"\" ) );\n\n\t\treturn tokens;\n\t}\n\n}\n\nexport default TriplesPattern;\n"],"sourceRoot":"../../../src"}