{"version":3,"sources":["clauses/decorators/order.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAC3C,OAAO,EAAE,oBAAoB,EAAE,MAAM,IAAI,CAAC;AAO1C,OAAO,EACN,EAAE,EACF,KAAK,GACL,MAAM,yBAAyB,CAAC;AACjC,OAAO,EACN,aAAa,GAEb,MAAM,gBAAgB,CAAC;AAYxB,MAAM,kBAAgF,YAAmB;IACxG,MAAM,MAAM,GAAW,CAAE,KAAK,EAAE,EAAE,EAAE,IAAI,aAAa,CAAE,YAAY,CAAE,CAAE,CAAC;IAExE,MAAM,SAAS,GAAgB,IAAI,SAAS,CAAK,IAAI,EAAE,MAAM,CAAE,CAAC;IAChE,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAwB,SAAS,EAAE,oBAAoB,CAAS,SAAS,EAAE,EAAE,CAAE,CAAE,CAAC;AAC/G,CAAC;AAUD,MAAM,yBAAsF,SAAsB,EAAE,MAAQ;IAC3H,MAAM,CAAC,MAAM,CAAC,MAAM,CAAE,oBAAoB,CAAQ,SAAS,EAAE,MAAM,CAAE,EAAE;QACrE,OAAO,EAAE,OAAO,CAAC,IAAI,CAAE,SAAS,CAAE;KAClC,CACD,CAAC;AACH,CAAC","file":"order.js","sourcesContent":["import { Container } from \"./../Container\";\nimport { limitOffsetDecorator } from \"./\";\nimport {\n\tFinishClause,\n\tLimitOffsetClause,\n\tOrderClause,\n\tSubFinishClause,\n} from \"./../interfaces\";\nimport {\n\tBY,\n\tORDER,\n} from \"./../../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\n\n/**\n * Set a condition to be used as the order of the sequence of solutions the\n * query will retrieve.\n *\n * Notice: The current version of SPARQLER does not evaluate the condition\n * for possible errors.\n *\n * @param rawCondition Raw condition to be applied for the solutions order.\n * @returns Object with the methods to keep constructing the query.\n */\nexport function orderBy<T extends FinishClause | SubFinishClause>( this:Container<T>, rawCondition:string ):LimitOffsetClause<T> & T {\n\tconst tokens:Token[] = [ ORDER, BY, new StringLiteral( rawCondition ) ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens );\n\treturn this._finishDecorator<LimitOffsetClause<T>>( container, limitOffsetDecorator<T, {}>( container, {} ) );\n}\n\n/**\n * Decorator that binds the OrderClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function orderDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & OrderClause<T> {\n\treturn Object.assign( limitOffsetDecorator<T, W>( container, object ), {\n\t\t\torderBy: orderBy.bind( container ),\n\t\t},\n\t);\n}\n"],"sourceRoot":"../../../src"}