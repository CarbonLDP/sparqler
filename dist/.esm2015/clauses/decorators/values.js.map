{"version":3,"sources":["clauses/decorators/values.ts"],"names":[],"mappings":"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","file":"values.js","sourcesContent":["import { ValuesClause, } from \"./..\";\nimport { Container } from \"./../Container\";\nimport {\n\tFinishClause,\n\tSubFinishClause,\n} from \"./../interfaces\";\nimport { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tPatternBuilder,\n\tSupportedNativeTypes,\n\tUndefined,\n} from \"./../../patterns\";\nimport {\n\tCLOSE_MULTI_BLOCK,\n\tCLOSE_SINGLE_BLOCK,\n\tCLOSE_SINGLE_LIST,\n\tOPEN_MULTI_BLOCK,\n\tOPEN_SINGLE_BLOCK,\n\tOPEN_SINGLE_LIST,\n\tVALUES,\n} from \"./../../patterns/tokens\";\nimport {\n\tLiteral,\n\tResource,\n\tVariable,\n} from \"./../../patterns/triples\";\nimport { Token } from \"./../../tokens\";\nimport { serialize } from \"./../../utils/ObjectPattern\";\n\ntype PossibleTypes = SupportedNativeTypes | Resource | Literal | Undefined;\n\n/**\n * Set the values of a variable to be combined into the results query.\n *\n * @param variable Variable to add values.\n * @param values The values to be combined.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variable:string, values:SupportedNativeTypes | SupportedNativeTypes[] ):T;\n/**\n * Set the values of a variable to be combined into the results query.\n *\n * The values are constructed with a function that receives a\n * pattern builder.\n *\n * @param variable Variable to add values.\n * @param valuesBuilder Functions that returns the values to be added.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variable:string, valuesBuilder:( builder:PatternBuilder ) => ( SupportedNativeTypes | Resource | Literal | Undefined ) | ( SupportedNativeTypes | Resource | Literal | Undefined )[] ):T;\n/**\n * Set the values of multiple variables to be combined into the results\n * query.\n *\n * @param variables Variables to add values.\n * @param values The values to be combined.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variables:string[], values:SupportedNativeTypes[] | SupportedNativeTypes[][] ):T;\n/**\n * Set the values of multiple variables to be combined into the results\n * query.\n *\n * The values are constructed with a function that receives a\n * pattern builder.\n *\n * @param variables Variables to add values.\n * @param valuesBuilder Functions that returns the values to be added.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variables:string[], valuesBuilder:( builder:PatternBuilder ) => ( SupportedNativeTypes | Resource | Literal | Undefined )[] | ( SupportedNativeTypes | Resource | Literal | Undefined )[][] ):T;\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variableOrVariables:string | string[], valuesOrBuilder ):T {\n\tconst isSingle:boolean = ! Array.isArray( variableOrVariables );\n\tconst variables:Variable[] = ( isSingle ?\n\t\t[ variableOrVariables as string ] : variableOrVariables as string[] )\n\t\t.map( name => new Variable( null, name ) );\n\tconst tokens:Token[] = [ VALUES ];\n\n\tif( isSingle ) {\n\t\ttokens.push( ...variables[ 0 ].getSelfTokens(), OPEN_SINGLE_BLOCK );\n\t} else {\n\t\ttokens.push( OPEN_SINGLE_LIST );\n\t\tvariables.forEach( variable => tokens.push( ...variable.getSelfTokens() ) );\n\t\ttokens.push( CLOSE_SINGLE_LIST, OPEN_MULTI_BLOCK );\n\t}\n\n\tlet iriResolver:IRIResolver = void 0;\n\tconst rawValues:PossibleTypes | PossibleTypes[] | PossibleTypes[][] =\n\t\ttypeof valuesOrBuilder === \"function\" ?\n\t\t\tvaluesOrBuilder( new PatternBuilder( iriResolver = new IRIResolver( this._iriResolver ) ) ) :\n\t\t\tvaluesOrBuilder;\n\n\tconst values:PossibleTypes[][] = isSingle ?\n\t\tArray.isArray( rawValues ) ? (rawValues as PossibleTypes[]).map( value => [ value ] ) : [ [ rawValues ] ] :\n\t\tArray.isArray( rawValues[ 0 ] ) ? rawValues as PossibleTypes[][] : [ rawValues ] as PossibleTypes[][];\n\n\tvalues.forEach( ( valuesRow ) => {\n\t\tif( isSingle ) {\n\t\t\ttokens.push( ...serialize( valuesRow[ 0 ] ) );\n\t\t} else {\n\t\t\ttokens.push( OPEN_SINGLE_LIST );\n\t\t\tvaluesRow.forEach( value => tokens.push( ...serialize( value ) ) );\n\t\t\ttokens.push( CLOSE_SINGLE_LIST );\n\t\t}\n\t} );\n\n\ttokens.push( isSingle ? CLOSE_SINGLE_BLOCK : CLOSE_MULTI_BLOCK );\n\n\tconst container:Container<T> = new Container<T>( this, tokens, iriResolver );\n\treturn this._finishDecorator( container, {} );\n}\n\n/**\n * Decorator that binds the {@link ValuesClause} methods to a\n * container and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function valuesDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & ValuesClause<T> {\n\treturn Object.assign( object, {\n\t\tvalues: values.bind( container ),\n\t} );\n}"],"sourceRoot":"../../../src"}