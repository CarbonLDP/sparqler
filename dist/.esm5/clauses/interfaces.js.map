{"version":3,"sources":["clauses/interfaces.ts"],"names":[],"mappings":"","file":"interfaces.js","sourcesContent":["import {\n\tGraphPattern,\n\tPatternBuilder,\n\tSupportedNativeTypes,\n\tUndefined,\n} from \"./../patterns\";\nimport {\n\tLiteral,\n\tResource,\n} from \"./../patterns/triples\";\n\nexport interface QueryClause<T extends FinishClause = FinishClause> extends SelectClause<T> {\n\tbase( iri:string ):QueryClause<T>;\n\tvocab( iri:string ):QueryClause<T>;\n\tprefix( name:string, iri:string ):QueryClause<T>;\n}\n\nexport interface SelectClause<T extends FinishClause = FinishClause> {\n\tselect( ...variables:string[] ):FromClause<T>;\n\tselectDistinct( ...variables:string[] ):FromClause<T>;\n\tselectReduced( ...variables:string[] ):FromClause<T>;\n\tselectAll():FromClause<T>;\n\tselectAllDistinct():FromClause<T>;\n\tselectAllReduced():FromClause<T>;\n}\n\nexport interface SubSelectClause {\n\tselect( ...variables:string[] ):SubWhereClause;\n\tselectDistinct( ...variables:string[] ):SubWhereClause;\n\tselectReduced( ...variables:string[] ):SubWhereClause;\n\tselectAll():SubWhereClause;\n\tselectAllDistinct():SubWhereClause;\n\tselectAllReduced():SubWhereClause;\n}\n\nexport interface FromClause<T extends FinishClause = FinishClause> extends WhereClause<T> {\n\tfrom( iri:string ):FromClause<T>;\n\tfromNamed( iri:string ):FromClause<T>;\n}\n\nexport interface WhereClause<T extends FinishClause = FinishClause> {\n\twhere( patternFunction:( builder:PatternBuilder ) => GraphPattern | GraphPattern[] ):GroupClause<T> & T;\n}\n\nexport interface SubWhereClause {\n\twhere( patterns:GraphPattern | GraphPattern[] ):GroupClause<SubFinishClause> & SubFinishClause;\n}\n\nexport interface GroupClause<T extends FinishClause | SubFinishClause = FinishClause> extends HavingClause<T> {\n\t// TODO: create group condition expressions\n\tgroupBy( rawCondition:string ):HavingClause<T> & T;\n}\n\nexport interface HavingClause<T extends FinishClause | SubFinishClause = FinishClause> extends OrderClause<T> {\n\t// TODO: create having condition expressions\n\thaving( rawCondition:string ):OrderClause<T> & T;\n}\n\nexport interface OrderClause<T extends FinishClause | SubFinishClause = FinishClause> extends LimitOffsetClause<T> {\n\t// TODO: create order condition expressions\n\torderBy( rawCondition:string ):LimitOffsetClause<T> & T;\n}\n\n/**\n * This LimitOffsetClause created this way to be able to specify `limit` and `offset` in this order or viceversa,\n * but not be able to repeat `limit` or `offset` more that once.\n *\n * Example:\n *  - Correct:\n *      .limit( ... )\n *      .offset( ... )\n *      .execute();\n *\n *      .offset( ... )\n *      .limit( ... )\n *      .execute();\n *\n *      .limit( ... )\n *      .execute();\n *\n *  - Incorrect:\n *      .limit( ... )\n *      .limit( ... ) // Not possible\n *      .offset( ... )\n *\n *      .offset( ... )\n *      .limit( ... )\n *      .offset( ... ) // Not possible\n */\nexport interface LimitOffsetClause<T extends FinishClause | SubFinishClause = FinishClause> extends LimitClause<OffsetClause<T & ValuesClause<T>> & ValuesClause<T> & T>,\n                                                                                                    OffsetClause<LimitClause<T & ValuesClause<T>> & ValuesClause<T> & T>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tValuesClause<T> {}\n\nexport interface OffsetClause<T> {\n\toffset( offset:number ):T;\n}\n\nexport interface LimitClause<T> {\n\tlimit( limit:number ):T;\n}\n\nexport interface ValuesClause<T extends FinishClause | SubFinishClause = FinishClause> {\n\tvalues( variable:string, values: SupportedNativeTypes | SupportedNativeTypes[] ): T;\n\tvalues( variable:string, valuesBuilder:( builder:PatternBuilder ) => ( SupportedNativeTypes | Resource | Literal | Undefined ) | ( SupportedNativeTypes | Resource | Literal | Undefined )[]  ): T;\n\tvalues( variables:string[], values: SupportedNativeTypes[] | SupportedNativeTypes[][] ): T;\n\tvalues( variables:string[], valuesBuilder:( builder:PatternBuilder ) => ( SupportedNativeTypes | Resource | Literal | Undefined )[] | ( SupportedNativeTypes | Resource | Literal | Undefined )[][]  ): T;\n}\n\nexport interface FinishClause {\n\ttoCompactString():string;\n\ttoPrettyString():string;\n\ttoString():string;\n}\n\nexport interface SubFinishClause extends GraphPattern {}\n"],"sourceRoot":"../../src"}