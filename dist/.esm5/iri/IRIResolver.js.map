{"version":3,"sources":["iri/IRIResolver.ts"],"names":[],"mappings":"AAAA,OAAO,EACN,gBAAgB,EAChB,UAAU,EACV,OAAO,GACP,MAAM,SAAS,CAAC;AACjB,OAAO,EAAE,aAAa,EAAE,MAAM,sBAAsB,CAAC;AACrD,OAAO,EACN,aAAa,GAEb,MAAM,aAAa,CAAC;AAUrB;IAmBC,qBAAa,IAAiB,EAAE,KAAa;;QAC5C,IAAI,CAAC,SAAS,GAAG,IAAI;YACpB,CAAC,CAAC,IAAI,GAAG,CAAE,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,CAAE;YACrC,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC;QAEb,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QAE1D,EAAE,CAAA,CAAE,eAAe,WAAY,CAAC;YAAC,MAAM,CAAC,MAAM,CAAE,IAAI,CAAE,CAAC;IACxD,CAAC;IAWD,6BAAO,GAAP,UAAS,WAAkB,EAAE,KAAqB;QAArB,sBAAA,EAAA,aAAqB;QACjD,IAAI,MAAc,CAAC;QAEnB,EAAE,CAAA,CAAE,UAAU,CAAE,WAAW,CAAG,CAAC,CAAC,CAAC;YAC1B,IAAA,kCAA0E,EAAxE,cAAM,EAAE,iBAAS,CAAwD;YAEjF,IAAM,IAAI,GAAW,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,MAAM,CAAE,CAAC;YAClD,EAAE,CAAA,CAAE,IAAI,KAAK,KAAK,CAAE,CAAC;gBAAC,MAAM,IAAI,KAAK,CAAE,uCAAuC,CAAE,CAAC;YAEjF,MAAM,GAAG,CAAE,IAAI,aAAa,CAAE,MAAM,CAAE,EAAE,aAAa,EAAE,IAAI,aAAa,CAAE,SAAS,CAAE,CAAE,CAAC;YACxF,EAAE,CAAA,CAAE,CAAE,IAAK,CAAC;gBAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,MAAM,EAAE,IAAI,CAAE,CAAC;QACjD,CAAC;QAAC,IAAI,CAAC,CAAC;YACP,MAAM,GAAG,OAAO,CAAE,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAE,CAAC;QAC/D,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IACf,CAAC;IACF,kBAAC;AAAD,CAvDA,AAuDC,IAAA","file":"IRIResolver.js","sourcesContent":["import {\n\tgetPrefixedParts,\n\tisPrefixed,\n\tresolve,\n} from \"./utils\";\nimport { PREFIX_SYMBOL } from \"./../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../tokens\";\n\n/**\n * Map type of the stored prefixes used by {@link IRIResolver}.\n */\nexport type PrefixMap = Map<string, boolean>;\n\n/**\n * Class to manage the resolution of IRIs in tokens\n */\nexport class IRIResolver {\n\n\t/**\n\t * Map to store prefixes and information of its usage\n\t */\n\treadonly _prefixes:PrefixMap;\n\n\t/**\n\t * IRI to resolve relative RDF properties\n\t */\n\treadonly _vocab:string;\n\n\t/**\n\t * Creates a new empty instance of IRIResolver if no parameter is provided, but\n\t * if a base IRIResolver is specified, its information will be copied to the new instance.\n\t *\n\t * @param base IRIResolver to copy its data from.\n\t * @param vocab Absolute IRI to change the default vocab value.\n\t */\n\tconstructor( base?:IRIResolver, vocab?:string ) {\n\t\tthis._prefixes = base\n\t\t\t? new Map( base._prefixes.entries() )\n\t\t\t: new Map();\n\n\t\tthis._vocab = vocab ? vocab : base ? base._vocab : void 0;\n\n\t\tif( new.target === IRIResolver ) Object.freeze( this );\n\t}\n\n\t/**\n\t * Resolves (if necessary) and creates the respective tokens if the IRI provided.\n\t *\n\t * If vocab parameter is to `true`, the stored vocab IRI is used to resolve relative IRIs.\n\t *\n\t * @param relativeIRI The relative IRI to be resolved and tokenized.\n\t * @param vocab Optional parameter to specified if the relative IRIs will be resolved with the stored vocab IRI.\n\t * @returns An array of tokens representing the provided IRI to be used in the SPARQL query.\n\t */\n\tresolve( relativeIRI:string, vocab:boolean = false ):Token[] {\n\t\tlet tokens:Token[];\n\n\t\tif( isPrefixed( relativeIRI ) ) {\n\t\t\tconst [ prefix, prefixIRI ]:[ string, string ] = getPrefixedParts( relativeIRI );\n\n\t\t\tconst used:boolean = this._prefixes.get( prefix );\n\t\t\tif( used === void 0 ) throw new Error( \"The used prefix has not been declared\" );\n\n\t\t\ttokens = [ new StringLiteral( prefix ), PREFIX_SYMBOL, new StringLiteral( prefixIRI ) ];\n\t\t\tif( ! used ) this._prefixes.set( prefix, true );\n\t\t} else {\n\t\t\ttokens = resolve( relativeIRI, vocab ? this._vocab : void 0 );\n\t\t}\n\n\t\treturn tokens;\n\t}\n}\n"],"sourceRoot":"../../src"}