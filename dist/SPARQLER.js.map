{"version":3,"sources":["SPARQLER.ts"],"names":[],"mappings":"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","file":"SPARQLER.js","sourcesContent":["import {\n\tQueryClause,\n\tFromClause,\n\tSelectClause,\n\tWhereClause,\n\tSolutionModifier,\n\tGroupClause,\n\tHavingClause,\n\tOrderClause,\n\tLimitOffsetClause,\n\tLimitClause,\n\tOffsetClause,\n\tFinishClause,\n\tFinishSelectClause,\n\tFinishSelect,\n} from \"./Clauses\";\nimport {\n\tGraphPattern,\n\tIRIResolver,\n} from \"./Patterns\";\nimport * as IRIUtils from \"./Utils/IRI\";\nimport * as PatternsUtils from \"./Utils/Patterns\";\nimport { PatternBuilder } from \"./PatternBuilder\";\nimport {\n\tToken,\n\tTokenFormat,\n} from \"./Tokens/Token\";\nimport { Identifier } from \"./Tokens/Identifier\";\nimport { StringLiteral } from \"./Tokens/StringLiteral\";\nimport { RightSymbol } from \"./Tokens/RightSymbol\";\nimport { NumberLiteral } from \"./Tokens/NumberLiteral\";\nimport {\n\tOPEN_IRI,\n\tCLOSE_IRI,\n\tVAR_SYMBOL,\n\tPREFIX_SYMBOL,\n\tEMPTY_SEPARATOR,\n\tOPEN_MULTI_BLOCK,\n\tCLOSE_MULTI_BLOCK,\n\tOPEN_MULTI_LIST,\n\tOPEN_MULTI_BN,\n\tCLOSE_MULTI_LIST,\n\tCLOSE_MULTI_BN,\n\tSAME_SUBJECT_SEPARATOR,\n\tSAME_PROPERTY_SEPARATOR,\n\tTRIPLE_SEPARATOR,\n} from \"./Patterns/Tokens\";\nimport { NewLineSymbol } from \"./Tokens/NewLineSymbol\";\n\ninterface PrefixInfo {\n\tiri:string;\n\tused:boolean;\n}\n\nexport class SPARQLER implements QueryClause,\n                                 FromClause<FinishClause>,\n                                 SelectClause,\n                                 WhereClause<FinishClause>,\n                                 GroupClause<FinishClause>,\n                                 HavingClause<FinishClause>,\n                                 OrderClause<FinishClause>,\n                                 LimitOffsetClause<FinishClause>,\n                                 FinishClause,\n                                 IRIResolver {\n\n\tprivate _base:string;\n\tprivate _vocab:string;\n\tprivate _prefixes:Map<string, PrefixInfo>;\n\n\tprivate _selects:Token[];\n\tprivate _from:Token[];\n\tprivate _where:Token[];\n\tprivate _group:Token[];\n\tprivate _having:Token[];\n\tprivate _order:Token[];\n\tprivate _limit:Token[];\n\tprivate _offset:Token[];\n\n\tprivate interfaces:{\n\t\tqueryClause:QueryClause;\n\t\tfromClause:FromClause<FinishClause>;\n\t\twhereClause:WhereClause<FinishClause>;\n\t\thavingClause:HavingClause<FinishClause>;\n\t\tgroupClause:GroupClause<FinishClause>;\n\t\torderClause:OrderClause<FinishClause>;\n\t\tfinishClause:FinishClause;\n\t\tlimitClause:LimitClause<FinishClause>;\n\t\toffsetClause:OffsetClause<FinishClause>;\n\t\tfinishSelect?:FinishSelect;\n\t};\n\n\tconstructor() {\n\t\tthis._prefixes = new Map<string, PrefixInfo>();\n\n\t\tthis.initInterfaces();\n\t}\n\n\t// Clauses related implementations\n\n\tbase( iri:string ):QueryClause {\n\t\tthis._base = iri;\n\t\treturn this.interfaces.queryClause;\n\t}\n\n\tvocab( iri:string ):QueryClause {\n\t\tthis._vocab = iri;\n\t\treturn this.interfaces.queryClause;\n\t}\n\n\tprefix( name:string, iri:string ):QueryClause {\n\t\tthis._prefixes.set( name, {\n\t\t\tiri: iri,\n\t\t\tused: false,\n\t\t} );\n\t\treturn this.interfaces.queryClause;\n\t}\n\n\tselect( ...variables:string[] ):WhereClause<FinishSelectClause> & FromClause<FinishSelectClause> {\n\t\tif( variables.length === 0 ) throw new Error( \"IllegalArgumentError: Need to provide al least one variable.\" );\n\n\t\tthis._selects = [ new Identifier( \"SELECT\" ) ];\n\t\tvariables.forEach( variable => this._selects.push( VAR_SYMBOL, new StringLiteral( variable ) ) );\n\n\t\tObject.assign( this.interfaces.finishClause, this.interfaces.finishSelect );\n\t\treturn Object.assign( {}, this.interfaces.whereClause, this.interfaces.fromClause );\n\t}\n\n\tselectAll():WhereClause<FinishSelectClause> & FromClause<FinishSelectClause> {\n\t\tthis._selects = [ new Identifier( \"SELECT\" ), new RightSymbol( \"*\" ) ];\n\n\t\tObject.assign( this.interfaces.finishClause, this.interfaces.finishSelect );\n\t\treturn Object.assign( {}, this.interfaces.whereClause, this.interfaces.fromClause );\n\t}\n\n\tfrom( iri:string ):WhereClause<FinishSelectClause> {\n\t\tthis._from = [ new Identifier( \"FROM\" ), ...this._resolveIRI( iri ) ];\n\t\treturn this.interfaces.whereClause;\n\t}\n\n\tfromNamed( iri:string ):WhereClause<FinishSelectClause> {\n\t\tthis._from = [ new Identifier( \"FROM\" ), new Identifier( \"NAMED\" ), ...this._resolveIRI( iri ) ];\n\t\treturn this.interfaces.whereClause;\n\t}\n\n\twhere( patternFunction:( builder:PatternBuilder ) => GraphPattern ):SolutionModifier<FinishClause> & FinishClause;\n\twhere( patternFunction:( builder:PatternBuilder ) => GraphPattern[ ] ):SolutionModifier<FinishClause> & FinishClause;\n\twhere( patternFunction ):SolutionModifier<FinishClause> & FinishClause {\n\t\tlet result:GraphPattern | GraphPattern[] = patternFunction( new PatternBuilder( this ) );\n\t\tthis._where = [ new Identifier( \"WHERE\" ), ...PatternsUtils.getBlockTokens( result as GraphPattern[] ) ];\n\n\t\treturn Object.assign(\n\t\t\t{},\n\t\t\tthis.interfaces.groupClause,\n\t\t\tthis.interfaces.havingClause,\n\t\t\tthis.interfaces.orderClause,\n\t\t\tthis.interfaces.limitClause,\n\t\t\tthis.interfaces.offsetClause,\n\t\t\tthis.interfaces.finishClause,\n\t\t);\n\t}\n\n\t// TODO: Implement group condition\n\tgroupBy( rawCondition:string ):HavingClause<FinishClause> & OrderClause<FinishClause> & LimitOffsetClause<FinishClause> & FinishClause {\n\t\tthis._group = [ new Identifier( \"GROUP\" ), new Identifier( \"BY\" ), new StringLiteral( rawCondition ) ];\n\t\treturn Object.assign(\n\t\t\t{},\n\t\t\tthis.interfaces.havingClause,\n\t\t\tthis.interfaces.orderClause,\n\t\t\tthis.interfaces.limitClause,\n\t\t\tthis.interfaces.offsetClause,\n\t\t\tthis.interfaces.finishClause,\n\t\t);\n\t}\n\n\t// TODO: Implement having condition\n\thaving( rawCondition:string ):OrderClause<FinishClause> & LimitOffsetClause<FinishClause> & FinishClause {\n\t\tthis._having = [ new Identifier( \"HAVING\" ), new StringLiteral( rawCondition ) ];\n\t\treturn Object.assign(\n\t\t\t{},\n\t\t\tthis.interfaces.orderClause,\n\t\t\tthis.interfaces.limitClause,\n\t\t\tthis.interfaces.offsetClause,\n\t\t\tthis.interfaces.finishClause,\n\t\t);\n\t}\n\n\t// TODO: Implement order condition\n\torderBy( rawCondition:string ):LimitOffsetClause<FinishClause> & FinishClause {\n\t\tthis._order = [ new Identifier( \"ORDER\" ), new Identifier( \"BY\" ), new StringLiteral( rawCondition ) ];\n\t\treturn Object.assign(\n\t\t\t<any> {},\n\t\t\tthis.interfaces.limitClause,\n\t\t\tthis.interfaces.offsetClause,\n\t\t\tthis.interfaces.finishClause,\n\t\t);\n\t}\n\n\tlimit( limit:number ):OffsetClause<FinishClause> & FinishClause {\n\t\tthis._limit = [ new Identifier( \"LIMIT\" ), new NumberLiteral( limit ) ];\n\n\t\tif( this._offset )\n\t\t\treturn <any> this.interfaces.finishClause;\n\t\treturn Object.assign( {}, this.interfaces.offsetClause, this.interfaces.finishClause );\n\t}\n\n\toffset( offset:number ):LimitClause<FinishClause> & FinishClause {\n\t\tthis._offset = [ new Identifier( \"OFFSET\" ), new NumberLiteral( offset ) ];\n\n\t\tif( this._limit )\n\t\t\treturn <any> this.interfaces.finishClause;\n\t\treturn Object.assign( {}, this.interfaces.limitClause, this.interfaces.finishClause );\n\t}\n\n\t/**\n\t * Construct the SPARQL query string.\n\t * @returns {string}\n\t */\n\tprivate constructQuery( format:TokenFormat ):string {\n\t\tlet tokens:Token[] = [];\n\n\t\t// Add base\n\t\tif( this._base )\n\t\ttokens.push( new Identifier( \"BASE\" ), OPEN_IRI, new StringLiteral( this._base ), CLOSE_IRI );\n\n\t\t// Add used prefixes\n\t\tthis._prefixes.forEach( ( prefixInfo:PrefixInfo, prefix:string ) => {\n\t\t\tif( prefixInfo.used || format === TokenFormat.PRETTY )\n\t\t\t\ttokens.push( new Identifier( \"PREFIX\" ), new StringLiteral( prefix + \":\" ), OPEN_IRI, new StringLiteral( prefixInfo.iri ), CLOSE_IRI );\n\t\t} );\n\n\t\t// Add select clause\n\t\tif( this._selects )\n\t\ttokens.push( ...this._selects );\n\n\t\t// Add from clause\n\t\tif( this._from )\n\t\t\ttokens.push( ...this._from );\n\n\t\t// Add where clause\n\t\tif( this._where )\n\t\ttokens.push( ...this._where );\n\n\t\t// Add solution modifiers\n\t\tif( this._order )\n\t\t\ttokens.push( ...this._order );\n\t\tif( this._having )\n\t\t\ttokens.push( ...this._having );\n\t\tif( this._group )\n\t\t\ttokens.push( ...this._group );\n\t\tif( this._limit )\n\t\t\ttokens.push( ...this._limit );\n\t\tif( this._offset )\n\t\t\ttokens.push( ...this._offset );\n\n\t\t// Transform the tokens to a string\n\t\tif( format === TokenFormat.COMPACT ) {\n\t\t\treturn tokens.reduce( ( res, token, index ) => {\n\t\t\t\tlet nextToken:Token = tokens[ index + 1 ];\n\t\t\t\tif( nextToken === EMPTY_SEPARATOR ) nextToken = tokens[ index + 2 ];\n\t\t\t\treturn res + token.getTokenValue( format, nextToken );\n\t\t\t}, \"\" );\n\n\t\t} else if( format === TokenFormat.PRETTY ) {\n\t\t\tlet stack:{ token:Token, indentation:number, subject:number, property:number, spaces:number }[] = [];\n\t\t\tlet actual:{ token:Token, indentation:number, subject:number, property:number, spaces:number } = {\n\t\t\t\ttoken: null,\n\t\t\t\tindentation: 0,\n\t\t\t\tsubject: 0,\n\t\t\t\tproperty: 0,\n\t\t\t\tspaces: 0\n\t\t\t};\n\n\t\t\treturn tokens.reduce( ( res, token, index ) => {\n\t\t\t\tlet nextToken:Token = tokens[ index + 1 ];\n\t\t\t\tlet tokenString:string = token.getTokenValue( format, nextToken );\n\n\t\t\t\t// Record spaces occupied by t¡he tokens\n\t\t\t\tif( actual.spaces === 0 ) {\n\t\t\t\t\tactual.subject += tokenString.length;\n\t\t\t\t\tif( tokenString.endsWith( \" \" ) ) actual.spaces ++;\n\t\t\t\t} else if( actual.spaces === 1 ) {\n\t\t\t\t\tactual.property += tokenString.length;\n\t\t\t\t\tif( tokenString.endsWith( \" \" ) ) actual.spaces ++;\n\t\t\t\t}\n\n\t\t\t\t// Check if a new block of lines\n\t\t\t\tif( [ OPEN_MULTI_BLOCK as Token, OPEN_MULTI_BN, OPEN_MULTI_LIST ].indexOf( token ) !== - 1 ) {\n\n\t\t\t\t\t// Record a new state for a block of triples\n\t\t\t\t\tstack.push( actual );\n\t\t\t\t\tactual = {\n\t\t\t\t\t\ttoken: token,\n\t\t\t\t\t\tindentation: actual.indentation + 4,\n\t\t\t\t\t\tsubject: 0,\n\t\t\t\t\t\tproperty: 0,\n\t\t\t\t\t\tspaces: token === OPEN_MULTI_BLOCK ? 0 : token === OPEN_MULTI_BN ? 1 : 2,\n\t\t\t\t\t};\n\n\t\t\t\t} else if( [ CLOSE_MULTI_LIST as Token ].indexOf( token ) !== - 1 ) {\n\t\t\t\t\tif( ! ( nextToken instanceof NewLineSymbol ) ) {\n\n\t\t\t\t\t\t// Obtain parent state\n\t\t\t\t\t\tlet parent = actual;\n\t\t\t\t\t\twhile( [ OPEN_MULTI_BLOCK as Token, OPEN_MULTI_BN, OPEN_MULTI_LIST ].indexOf( parent.token ) === - 1 )\n\t\t\t\t\t\t\tparent = stack.pop();\n\t\t\t\t\t\tstack.push( parent );\n\n\t\t\t\t\t\t// Record a new state for properties of a collection\n\t\t\t\t\t\tactual = {\n\t\t\t\t\t\t\ttoken: token,\n\t\t\t\t\t\t\tindentation: parent.indentation + 4,\n\t\t\t\t\t\t\tsubject: 0,\n\t\t\t\t\t\t\tproperty: 0,\n\t\t\t\t\t\t\tspaces: 1\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t} else if( [ SAME_SUBJECT_SEPARATOR as Token, SAME_PROPERTY_SEPARATOR, CLOSE_MULTI_LIST ].indexOf( token ) !== - 1 ) {\n\n\t\t\t\t\t// Obtain parent state\n\t\t\t\t\tlet parent = actual;\n\t\t\t\t\twhile( [ OPEN_MULTI_BLOCK as Token, OPEN_MULTI_BN, OPEN_MULTI_LIST, CLOSE_MULTI_LIST, CLOSE_MULTI_BN ].indexOf( parent.token ) === - 1 )\n\t\t\t\t\t\tparent = stack.pop();\n\t\t\t\t\tstack.push( parent );\n\n\t\t\t\t\t// Record a new state for same subject properties\n\t\t\t\t\tif( token === SAME_SUBJECT_SEPARATOR ) {\n\t\t\t\t\t\tactual = {\n\t\t\t\t\t\t\ttoken: token,\n\t\t\t\t\t\t\tindentation: parent.indentation + actual.subject,\n\t\t\t\t\t\t\tsubject: actual.subject,\n\t\t\t\t\t\t\tproperty: 0,\n\t\t\t\t\t\t\tspaces: 1\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Record a new state for a list of objects of a property\n\t\t\t\t\t} else if( token === SAME_PROPERTY_SEPARATOR ) {\n\t\t\t\t\t\tactual = {\n\t\t\t\t\t\t\ttoken: token,\n\t\t\t\t\t\t\tindentation: parent.indentation + actual.subject + actual.property,\n\t\t\t\t\t\t\tsubject: actual.subject,\n\t\t\t\t\t\t\tproperty: actual.property,\n\t\t\t\t\t\t\tspaces: 2\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Returns still a block state\n\t\t\t\t} else if( token === TRIPLE_SEPARATOR ) {\n\t\t\t\t\twhile( actual.token !== OPEN_MULTI_BLOCK ) actual = stack.pop();\n\t\t\t\t\tactual.spaces = 0;\n\t\t\t\t\tactual.subject = 0;\n\t\t\t\t\tactual.property = 0;\n\t\t\t\t}\n\n\t\t\t\tif( nextToken === CLOSE_MULTI_BLOCK ) {\n\t\t\t\t\twhile( actual.token !== OPEN_MULTI_BLOCK ) actual = stack.pop();\n\t\t\t\t\tactual = stack.pop();\n\t\t\t\t} else if( nextToken === CLOSE_MULTI_BN ) {\n\t\t\t\t\twhile( actual.token !== OPEN_MULTI_BN ) actual = stack.pop();\n\t\t\t\t\tactual = stack.pop();\n\t\t\t\t} else if( nextToken === CLOSE_MULTI_LIST ) {\n\t\t\t\t\twhile( actual.token !== OPEN_MULTI_LIST ) actual = stack.pop();\n\t\t\t\t\tactual = stack.pop();\n\t\t\t\t}\n\n\t\t\t\tif( tokenString.endsWith( \"\\n\" ) ) {\n\t\t\t\t\ttokenString = tokenString + \" \".repeat( actual.indentation );\n\t\t\t\t}\n\n\t\t\t\treturn res + tokenString;\n\t\t\t}, \"\" );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a compact SPARQL query string.\n\t * @returns {string}\n\t */\n\ttoCompactString():string {\n\t\treturn this.constructQuery( TokenFormat.COMPACT );\n\t}\n\n\ttoString():string {\n\t\treturn this.toCompactString();\n\t}\n\n\t/**\n\t * Returns a pretty SPARQL query string.\n\t * @returns {string}\n\t */\n\ttoPrettyString():string {\n\t\treturn this.constructQuery( TokenFormat.PRETTY );\n\t}\n\n\tprivate initInterfaces():void {\n\t\tthis.interfaces = {\n\t\t\tqueryClause: {\n\t\t\t\tbase: this.base.bind( this ),\n\t\t\t\tvocab: this.vocab.bind( this ),\n\t\t\t\tprefix: this.prefix.bind( this ),\n\t\t\t\tselect: this.select.bind( this ),\n\t\t\t\tselectAll: this.selectAll.bind( this ),\n\t\t\t},\n\t\t\tfromClause: {\n\t\t\t\tfrom: this.from.bind( this ),\n\t\t\t\tfromNamed: this.fromNamed.bind( this ),\n\t\t\t},\n\t\t\twhereClause: {\n\t\t\t\twhere: this.where.bind( this ),\n\t\t\t},\n\t\t\tgroupClause: {\n\t\t\t\tgroupBy: this.groupBy.bind( this ),\n\t\t\t},\n\t\t\thavingClause: {\n\t\t\t\thaving: this.having.bind( this ),\n\t\t\t},\n\t\t\torderClause: {\n\t\t\t\torderBy: this.orderBy.bind( this ),\n\t\t\t},\n\t\t\tlimitClause: {\n\t\t\t\tlimit: this.limit.bind( this ),\n\t\t\t},\n\t\t\toffsetClause: {\n\t\t\t\toffset: this.offset.bind( this ),\n\t\t\t},\n\t\t\tfinishClause: {\n\t\t\t\ttoCompactString: this.toCompactString.bind( this ),\n\t\t\t\ttoPrettyString: this.toPrettyString.bind( this ),\n\t\t\t},\n\t\t};\n\t}\n\n\t_resolveIRI( iri:string, vocab:boolean = false ):Token[] {\n\t\tlet tokens:Token[];\n\n\t\tif( IRIUtils.isPrefixed( iri ) ) {\n\t\t\tlet parts:string[] = IRIUtils.getPrefixedParts( iri );\n\t\t\tif( parts === null ) return;\n\n\t\t\tlet prefixInfo:PrefixInfo = this._prefixes.get( parts[ 0 ] );\n\t\t\tif( prefixInfo === void 0 ) throw new Error( \"IllegalArgumentError: The used prefix has not been declared\" );\n\n\t\t\ttokens = [ new StringLiteral( parts[ 0 ] ), PREFIX_SYMBOL, new StringLiteral( parts[ 1 ] ) ];\n\t\t\tprefixInfo.used = true;\n\t\t} else {\n\t\t\ttokens = IRIUtils.resolve( iri, vocab ? this._vocab : void 0 );\n\t\t}\n\n\t\treturn tokens;\n\t}\n\n}\n\nexport default SPARQLER;\n"]}