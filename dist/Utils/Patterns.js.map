{"version":3,"sources":["Utils/Patterns.ts"],"names":[],"mappings":";AAEA,6CAM4B;AAC5B,mDAAkD;AAIlD,wBAAgC,QAAQ;IACvC,IAAI,MAAM,GAAW,SAAS,CAAE,QAAQ,CAAE,CAAC;IAE3C,IAAI,SAAS,GAAS,0BAAiB,CAAC;IACxC,IAAI,UAAU,GAAS,2BAAkB,CAAC;IAC1C,EAAE,CAAA,CAAE,WAAW,CAAE,MAAM,CAAG,CAAC,CAAC,CAAC;QAC5B,SAAS,GAAG,yBAAgB,CAAC;QAC7B,UAAU,GAAG,0BAAiB,CAAC;IAChC,CAAC;IAED,MAAM,EAAG,SAAS,SAAK,MAAM,GAAE,UAAU,GAAG;AAC7C,CAAC;AAXD,wCAWC;AAKD,mBAA2B,QAAQ;IAClC,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,GAAG,QAAQ,GAAG,CAAE,QAAQ,CAAE,CAAC;IAE/D,IAAI,aAAa,GAAW,EAAE,CAAC;IAC/B,IAAI,SAAS,GAAS,KAAK,CAAC,CAAC;IAE7B,QAAQ,CAAC,OAAO,CAAE,UAAE,YAAY,EAAE,KAAK;QACtC,IAAI,MAAM,GAAW,YAAY,CAAC,UAAU,EAAE,CAAC;QAE/C,EAAE,CAAA,CAAE,SAAS,KAAK,yBAAgB,IAAI,CAAE,MAAM,CAAE,CAAC,CAAE,YAAY,uBAAU,IAAI,MAAM,CAAE,CAAC,CAAE,KAAK,yBAAgB,CAAG,CAAC;YAAC,aAAa,CAAC,GAAG,EAAE,CAAC;QAEtI,aAAa,CAAC,IAAI,OAAlB,aAAa,EAAU,MAAM,EAAG;QAEhC,SAAS,GAAG,MAAM,CAAE,MAAM,CAAC,MAAM,GAAG,CAAC,CAAE,CAAC;QACxC,EAAE,CAAA,CAAE,KAAK,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,SAAS,KAAK,0BAAkB,CAAC,CAAC,CAAC;YACrE,SAAS,GAAG,yBAAgB,CAAC;YAC7B,aAAa,CAAC,IAAI,CAAE,yBAAgB,CAAE,CAAC;QACxC,CAAC;IACF,CAAC,CAAE,CAAC;IAEJ,MAAM,CAAC,aAAa,CAAC;AACtB,CAAC;AArBD,8BAqBC;AAED,qBAA6B,MAAc;IAC1C,MAAM,CAAC,MAAM,CAAC,IAAI,CAAE,UAAA,KAAK,IAAI,OAAA,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAE,CAAC,OAAO,CAAE,KAAK,CAAE,OAAO,CAAE,CAAE,KAAK,CAAE,CAAC,EAArD,CAAqD,CAAE,KAAK,KAAK,CAAC,CAAC;AACjG,CAAC;AAFD,kCAEC","file":"Patterns.js","sourcesContent":["import { GraphPattern } from \"../Patterns\";\nimport { Token } from \"../Tokens/Token\";\nimport {\n\tTRIPLE_SEPARATOR,\n\tOPEN_MULTI_BLOCK,\n\tCLOSE_MULTI_BLOCK,\n\tOPEN_SINGLE_BLOCK,\n\tCLOSE_SINGLE_BLOCK\n} from \"../Patterns/Tokens\";\nimport { Identifier } from \"../Tokens/Identifier\";\n\nexport function getBlockTokens( pattern:GraphPattern ):Token[];\nexport function getBlockTokens( patterns:GraphPattern[] ):Token[];\nexport function getBlockTokens( patterns ):Token[] {\n\tlet tokens:Token[] = getTokens( patterns );\n\n\tlet openToken:Token = OPEN_SINGLE_BLOCK;\n\tlet closeToken:Token = CLOSE_SINGLE_BLOCK;\n\tif( isMultiLine( tokens ) ) {\n\t\topenToken = OPEN_MULTI_BLOCK;\n\t\tcloseToken = CLOSE_MULTI_BLOCK;\n\t}\n\n\treturn [ openToken, ...tokens, closeToken ];\n}\n\n\nexport function getTokens( pattern:GraphPattern ):Token[];\nexport function getTokens( patterns:GraphPattern[] ):Token[];\nexport function getTokens( patterns ):Token[] {\n\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\n\tlet triplesTokens:Token[] = [];\n\tlet lastToken:Token = void 0;\n\n\tpatterns.forEach( ( graphPattern, index ) => {\n\t\tlet tokens:Token[] = graphPattern.getPattern();\n\n\t\tif( lastToken === TRIPLE_SEPARATOR && ( tokens[ 0 ] instanceof Identifier || tokens[ 0 ] === OPEN_MULTI_BLOCK ) ) triplesTokens.pop();\n\n\t\ttriplesTokens.push( ...tokens );\n\n\t\tlastToken = tokens[ tokens.length - 1 ];\n\t\tif( index < patterns.length - 1 && lastToken !== CLOSE_MULTI_BLOCK ) {\n\t\t\tlastToken = TRIPLE_SEPARATOR;\n\t\t\ttriplesTokens.push( TRIPLE_SEPARATOR );\n\t\t}\n\t} );\n\n\treturn triplesTokens;\n}\n\nexport function isMultiLine( tokens:Token[] ):boolean {\n\treturn tokens.find( token => [ \".\", \";\", \",\" ].indexOf( token[ \"value\" ] ) !== - 1 ) !== void 0;\n}"]}