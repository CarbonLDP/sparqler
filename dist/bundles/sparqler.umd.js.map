{"version":3,"file":"sparqler.umd.js","sources":["../../node_modules/tslib/tslib.es6.js","../src/tokens/Token.ts","../src/tokens/NewLineSymbol.ts","../src/tokens/Operator.ts","../src/tokens/LeftSymbol.ts","../src/tokens/RightSymbol.ts","../src/tokens/StringLiteral.ts","../src/tokens/Identifier.ts","../src/tokens/NumberLiteral.ts","../src/tokens/BlankNodeToken.ts","../src/tokens/VariableToken.ts","../src/tokens/IRIToken.ts","../src/iri/utils.ts","../src/tokens/PrefixedNameToken.ts","../src/tokens/NumberToken.ts","../src/tokens/LanguageToken.ts","../src/tokens/BooleanToken.ts","../src/iri/IRIResolver.ts","../src/tokens/StringToken.ts","../src/tokens/LiteralToken.ts","../src/tokens/ValuesToken.ts","../src/tokens/SubjectToken.ts","../src/tokens/PredicateToken.ts","../src/tokens/utils.ts","../src/tokens/OptionalToken.ts","../src/tokens/GraphToken.ts","../src/tokens/BindToken.ts","../src/tokens/FilterToken.ts","../src/tokens/PrefixToken.ts","../src/tokens/ConstructToken.ts","../src/tokens/SelectToken.ts","../src/tokens/BaseToken.ts","../src/tokens/OrderToken.ts","../src/tokens/LimitToken.ts","../src/tokens/OffsetToken.ts","../src/tokens/QueryToken.ts","../src/tokens/CollectionToken.ts","../src/patterns/tokens.ts","../src/clauses/decorators/finish.ts","../src/clauses/decorators/subFinish.ts","../src/clauses/Container.ts","../src/clauses/decorators/from.ts","../src/clauses/decorators/group.ts","../src/clauses/decorators/having.ts","../src/patterns/notTriples/NotTriplesPattern.ts","../src/utils/XSD.ts","../src/utils/ObjectPattern.ts","../src/patterns/notTriples/ValuesPattern.ts","../src/patterns/triples/TriplesPattern.ts","../src/patterns/triples/BlankNode.ts","../src/patterns/triples/Collection.ts","../src/patterns/triples/TriplesSubject.ts","../src/patterns/triples/Literals.ts","../src/patterns/triples/Resource.ts","../src/patterns/triples/Variable.ts","../src/utils/Patterns.ts","../src/patterns/PatternBuilder.ts","../src/clauses/decorators/values.ts","../src/clauses/decorators/limit-offset.ts","../src/clauses/decorators/order.ts","../src/clauses/decorators/query.ts","../src/clauses/decorators/select.ts","../src/clauses/decorators/where.ts","../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export const EMPTY_SEPARATOR:string = \"\";\nexport const SPACE_SEPARATOR:string = \" \";\nexport const NEW_LINE_SEPARATOR:string = \"\\n\";\n\nexport enum TokenFormat {\n\tPRETTY,\n\tCOMPACT,\n}\n\nexport abstract class Token {\n\n\tconstructor( protected value:string ) {};\n\n\tgetTokenValue( format?:TokenFormat, nextToken?:Token ):string {\n\t\tlet separator:string = EMPTY_SEPARATOR;\n\n\t\tif( nextToken !== void 0 ) {\n\t\t\tswitch( format ) {\n\t\t\t\tcase TokenFormat.PRETTY:\n\t\t\t\t\tseparator = this.getPrettySeparator( nextToken );\n\t\t\t\t\tbreak;\n\t\t\t\tcase TokenFormat.COMPACT:\n\t\t\t\t\tseparator = this.getCompactSeparator( nextToken );\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn this.value + separator;\n\t}\n\n\tprotected abstract getPrettySeparator( nextToken:Token ):string;\n\n\tprotected abstract getCompactSeparator( nextToken:Token ):string;\n\n}\n\nexport default Token;","import {\n\tEMPTY_SEPARATOR,\n\tNEW_LINE_SEPARATOR,\n\tSPACE_SEPARATOR,\n\tToken,\n} from \"./Token\";\n\nexport class NewLineSymbol extends Token {\n\n\tprotected getPrettySeparator( nextToken:Token ):string {\n\t\tif( nextToken instanceof NewLineSymbol ) {\n\t\t\tif( [ \".\", \";\", \",\" ].indexOf( nextToken[ \"value\" ] ) !== - 1 )\n\t\t\t\treturn SPACE_SEPARATOR;\n\t\t}\n\n\t\treturn NEW_LINE_SEPARATOR;\n\t}\n\n\tprotected getCompactSeparator( nextToken:Token ):string {\n\t\treturn EMPTY_SEPARATOR;\n\t}\n\n}\n\nexport default NewLineSymbol;\n","import {\n\tEMPTY_SEPARATOR,\n\tToken,\n} from \"./Token\";\n\nexport class Operator extends Token {\n\n\tprotected getPrettySeparator( nextToken:Token ):string {\n\t\treturn EMPTY_SEPARATOR;\n\t}\n\n\tprotected getCompactSeparator( nextToken:Token ):string {\n\t\treturn EMPTY_SEPARATOR;\n\t}\n\n}\n\nexport default Operator;\n","import { Identifier } from \"./Identifier\";\nimport {\n\tEMPTY_SEPARATOR,\n\tSPACE_SEPARATOR,\n\tToken,\n} from \"./Token\";\n\nexport class LeftSymbol extends Token {\n\n\tprotected getPrettySeparator( nextToken:Token ):string {\n\t\tif( nextToken instanceof LeftSymbol || nextToken instanceof Identifier )\n\t\t\treturn SPACE_SEPARATOR;\n\t\treturn EMPTY_SEPARATOR;\n\t}\n\n\tprotected getCompactSeparator( nextToken:Token ):string {\n\t\treturn EMPTY_SEPARATOR;\n\t}\n\n}\n\nexport default LeftSymbol;\n","import { Identifier } from \"./Identifier\";\nimport { LeftSymbol } from \"./LeftSymbol\";\nimport { NewLineSymbol } from \"./NewLineSymbol\";\nimport { Operator } from \"./Operator\";\nimport {\n\tEMPTY_SEPARATOR,\n\tNEW_LINE_SEPARATOR,\n\tSPACE_SEPARATOR,\n\tToken,\n} from \"./Token\";\n\nexport class RightSymbol extends Token {\n\n\tprotected getPrettySeparator( nextToken:Token ):string {\n\t\tif( nextToken instanceof Identifier && nextToken[ \"value\" ] !== \"UNDEF\" )\n\t\t\treturn NEW_LINE_SEPARATOR;\n\n\t\tif( nextToken instanceof NewLineSymbol ) {\n\t\t\tif( [ \"}\", \"]\", \")\" ].indexOf( nextToken[ \"value\" ] ) !== - 1 ) {\n\t\t\t\treturn NEW_LINE_SEPARATOR;\n\t\t\t}\n\t\t}\n\n\t\tif( nextToken instanceof LeftSymbol ) {\n\t\t\tif( nextToken[ \"value\" ] === \"(\" )\n\t\t\t\treturn NEW_LINE_SEPARATOR;\n\t\t}\n\n\t\tif( nextToken instanceof Operator )\n\t\t\treturn EMPTY_SEPARATOR;\n\n\t\treturn SPACE_SEPARATOR;\n\t}\n\n\tprotected getCompactSeparator( nextToken:Token ):string {\n\t\treturn EMPTY_SEPARATOR;\n\t}\n\n}\n\nexport default RightSymbol;\n","import { Identifier } from \"./Identifier\";\nimport { NewLineSymbol } from \"./NewLineSymbol\";\nimport { Operator } from \"./Operator\";\nimport { RightSymbol } from \"./RightSymbol\";\nimport {\n\tEMPTY_SEPARATOR,\n\tNEW_LINE_SEPARATOR,\n\tSPACE_SEPARATOR,\n\tToken,\n} from \"./Token\";\n\nexport class StringLiteral extends Token {\n\n\tprotected getPrettySeparator( nextToken:Token ):string {\n\t\tif( ( nextToken instanceof Identifier && nextToken[ \"value\" ] !== \"AS\" ) || ( nextToken instanceof NewLineSymbol && ( nextToken[ \"value\" ] === \")\" || nextToken[ \"value\" ] === \"}\" ) ) )\n\t\t\treturn NEW_LINE_SEPARATOR;\n\n\t\tif( nextToken instanceof Operator || ( nextToken instanceof RightSymbol && nextToken[ \"value\" ] !== \")\" ) )\n\t\t\treturn EMPTY_SEPARATOR;\n\n\t\treturn SPACE_SEPARATOR;\n\t}\n\n\tprotected getCompactSeparator( nextToken:Token ):string {\n\t\tif( this.constructor === nextToken.constructor || nextToken instanceof Identifier )\n\t\t\treturn SPACE_SEPARATOR;\n\n\t\treturn EMPTY_SEPARATOR;\n\t}\n\n}\n\nexport default StringLiteral;\n","import { StringLiteral } from \"./StringLiteral\";\nimport {\n\tEMPTY_SEPARATOR,\n\tNEW_LINE_SEPARATOR,\n\tSPACE_SEPARATOR,\n\tToken,\n} from \"./Token\";\n\nexport class Identifier extends Token {\n\n\tprotected getPrettySeparator( nextToken:Token ):string {\n\t\tif( this.value === \"UNION\" ) return NEW_LINE_SEPARATOR;\n\t\treturn SPACE_SEPARATOR;\n\t}\n\n\tprotected getCompactSeparator( nextToken:Token ):string {\n\t\tif( this.constructor === nextToken.constructor || nextToken instanceof StringLiteral )\n\t\t\treturn SPACE_SEPARATOR;\n\n\t\treturn EMPTY_SEPARATOR;\n\t}\n\n}\n\nexport default Identifier;\n","import { Identifier } from \"./Identifier\";\nimport { Operator } from \"./Operator\";\nimport { RightSymbol } from \"./RightSymbol\";\nimport {\n\tEMPTY_SEPARATOR,\n\tNEW_LINE_SEPARATOR,\n\tSPACE_SEPARATOR,\n\tToken,\n} from \"./Token\";\n\nexport class NumberLiteral extends Token {\n\n\tconstructor( value:number ) {\n\t\tsuper( value + \"\" );\n\t}\n\n\tprotected getPrettySeparator( nextToken:Token ):string {\n\t\tif( nextToken instanceof Identifier )\n\t\t\treturn NEW_LINE_SEPARATOR;\n\n\t\tif( nextToken instanceof Operator || nextToken instanceof RightSymbol )\n\t\t\treturn EMPTY_SEPARATOR;\n\n\t\treturn SPACE_SEPARATOR;\n\t}\n\n\tprotected getCompactSeparator( nextToken:Token ):string {\n\t\tif( this.constructor === nextToken.constructor )\n\t\t\treturn SPACE_SEPARATOR;\n\n\t\treturn EMPTY_SEPARATOR;\n\t}\n\n}\n\nexport default NumberLiteral;\n","import { TokenNode } from \"./TokenNode\";\n\nconst LABEL_REGEX:RegExp = /^_:[A-Za-z0-9_]([A-Za-z0-9_\\-.]*[A-Za-z0-9_\\-])?$/;\n\nexport class BlankNodeToken implements TokenNode {\n\treadonly token:\"blankNode\" = \"blankNode\";\n\treadonly label?:string;\n\n\tconstructor( label?:string ) {\n\t\tif( ! label ) return;\n\t\tif( ! LABEL_REGEX.test( label ) ) throw new Error( \"Invalid blank node label.\" );\n\t\tthis.label = label;\n\t}\n\n\ttoString():string {\n\t\tif( this.label ) return this.label;\n\t\treturn `[]`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\nconst NAME_REGEX:RegExp = /^((?:[0-9A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]))((?:[0-9A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]))*$/;\n\nexport class VariableToken implements TokenNode {\n\treadonly token:\"variable\" = \"variable\";\n\treadonly name:string;\n\n\tconstructor( name:string ) {\n\t\tif( ! NAME_REGEX.test( name ) ) throw new Error( \"Invalid variable name\" );\n\n\t\tthis.name = name;\n\t}\n\n\ttoString():string {\n\t\treturn `?${ this.name }`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\nexport class IRIToken implements TokenNode {\n\treadonly token:\"iri\" = \"iri\";\n\treadonly value:string;\n\n\tconstructor( value:string ) {\n\t\tthis.value = value;\n\t}\n\n\ttoString():string {\n\t\treturn `<${ this.value }>`;\n\t}\n}\n","import { Token } from \"../tokens/Token\";\nimport { StringLiteral } from \"../tokens/StringLiteral\";\nimport {\n\tOPEN_IRI,\n\tCLOSE_IRI,\n} from \"../patterns/tokens\";\n\nexport function isAbsolute( iri:string ):boolean {\n\treturn iri.indexOf( \":\" ) !== - 1;\n}\n\nexport function hasProtocol( iri:string ):boolean {\n\treturn iri.indexOf( \"://\" ) !== - 1;\n}\n\nexport function isRelative( iri:string ):boolean {\n\treturn ! isAbsolute( iri );\n}\n\nexport function isIRI( iri:string ):boolean {\n\treturn hasProtocol( iri ) || ! isAbsolute( iri );\n}\n\nconst bNodeRegex:RegExp = /^_:/;\n\nexport function isBNodeLabel( label:string ):boolean {\n\treturn bNodeRegex.test( label );\n}\n\nconst prefixRegex:RegExp = /([A-Za-z](([A-Za-z_\\-0-9]|\\.)*[A-Za-z_\\-0-9])?)?:/;\nconst softPrefixRegex:RegExp = /^(?!_:)[^]*?:/;\nconst prefixNormalizeRegex:RegExp = /([_~.\\-!$&'|()*+,;=/?#@%])/g;\n\nexport function isPrefixed( iri:string ):boolean {\n\treturn softPrefixRegex.test( iri ) && ! hasProtocol( iri );\n}\n\nexport function getPrefixedParts( iri:string ):[ string, string ] {\n\tlet parts:RegExpExecArray = prefixRegex.exec( iri );\n\tif( parts === null || hasProtocol( iri ) ) return null;\n\n\tlet prefix:string = parts[ 1 ] || \"\";\n\tlet local:string = iri.substr( prefix.length + 1 ).replace( prefixNormalizeRegex, \"\\\\$1\" );\n\n\treturn [\n\t\tprefix,\n\t\tlocal,\n\t];\n}\n\n/**\n * Check if the provided is an IRI to surround it with '<>'.\n * @param iri String to check.\n * @param vocab Optional parameter that indicates the vocab to resolve relative IRIs.\n * @returns {string}\n */\nexport function resolve( iri:string, vocab?:string ):Token[] {\n\tlet tokens:Token[] = [ new StringLiteral( iri ) ];\n\n\tif( isIRI( iri ) ) {\n\t\tif( isRelative( iri ) && vocab )\n\t\t\tiri = vocab + iri;\n\t\ttokens = [ OPEN_IRI, new StringLiteral( iri ), CLOSE_IRI ];\n\t}\n\n\treturn tokens;\n}\n","import { isPrefixed } from \"./../iri/utils\";\nimport { TokenNode } from \"./TokenNode\";\n\nconst NAMESPACE_REGEX:RegExp = /^([A-Za-z](([A-Za-z_\\-0-9]|\\.)*[A-Za-z_\\-0-9])?)?$/;\n\nexport class PrefixedNameToken implements TokenNode {\n\treadonly token:\"prefixedName\" = \"prefixedName\";\n\treadonly namespace:string;\n\treadonly localName:string;\n\n\tconstructor( prefixedName:string );\n\tconstructor( namespace:string, localName:string );\n\tconstructor( prefixedOrNamespace:string, localName?:string ) {\n\t\tlet namespace:string = prefixedOrNamespace;\n\t\tif( localName === void 0 ) {\n\t\t\tif( ! isPrefixed( prefixedOrNamespace ) ) throw new Error( \"Invalid prefixed name.\" );\n\t\t\t[ namespace, localName ] = prefixedOrNamespace.split( /:(.*)/ );\n\t\t}\n\n\t\tif( ! NAMESPACE_REGEX.test( namespace ) ) throw new Error( \"Invalid prefixed namespace.\" );\n\t\tthis.namespace = namespace;\n\n\t\tconst [ , ln1, ln2, ln3 ] = localName.split( /^(.)(?:(.*)?(.))?$/ );\n\n\t\tlet preSanitation:string = \"\";\n\t\tif( ln1 ) preSanitation += ln1.replace( /([\\-.])/g, \"\\\\$1\" );\n\t\tif( ln2 ) preSanitation += ln2;\n\t\tif( ln2 ) preSanitation += ln3.replace( /([.])/g, \"\\\\$1\" );\n\n\t\tthis.localName = preSanitation.replace( /([~!$&'|()*+,;=/?#@%])/g, \"\\\\$1\" );\n\t}\n\n\ttoString():string {\n\t\treturn `${ this.namespace }:${ this.localName }`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\nexport class NumberToken implements TokenNode {\n\treadonly token:\"number\" = \"number\";\n\treadonly value:number;\n\n\tconstructor( value:number ) {\n\t\tthis.value = value;\n\t}\n\n\ttoString():string {\n\t\treturn `${ this.value }`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\nconst LANGUAGE_REGEX:RegExp = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;\n\nexport function isLanguageTag( tag:string ):boolean {\n\treturn LANGUAGE_REGEX.test( tag );\n}\n\nexport class LanguageToken implements TokenNode {\n\treadonly token:\"language\" = \"language\";\n\treadonly tag:string;\n\n\tconstructor( tag:string ) {\n\t\tif( ! isLanguageTag( tag ) ) throw new Error( \"Invalid language tag.\" );\n\t\tthis.tag = tag;\n\t}\n\n\ttoString():string {\n\t\treturn `@${ this.tag }`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\nexport class BooleanToken implements TokenNode {\n\treadonly token:\"boolean\" = \"boolean\";\n\treadonly value:boolean;\n\n\tconstructor( value:boolean ) {\n\t\tthis.value = value;\n\t}\n\n\ttoString():string {\n\t\treturn `${ this.value }`;\n\t}\n}\n","import {\n\tgetPrefixedParts,\n\tisPrefixed,\n\tresolve,\n} from \"./utils\";\nimport { PREFIX_SYMBOL } from \"./../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../tokens\";\n\n/**\n * Map type of the stored prefixes used by {@link IRIResolver}.\n */\nexport type PrefixMap = Map<string, boolean>;\n\n/**\n * Class to manage the resolution of IRIs in tokens\n */\nexport class IRIResolver {\n\n\t/**\n\t * Map to store prefixes and information of its usage\n\t */\n\treadonly _prefixes:PrefixMap;\n\n\t/**\n\t * IRI to resolve relative RDF properties\n\t */\n\treadonly _vocab:string;\n\n\t/**\n\t * Creates a new empty instance of IRIResolver if no parameter is provided, but\n\t * if a base IRIResolver is specified, its information will be copied to the new instance.\n\t *\n\t * @param base IRIResolver to copy its data from.\n\t * @param vocab Absolute IRI to change the default vocab value.\n\t */\n\tconstructor( base?:IRIResolver, vocab?:string ) {\n\t\tthis._prefixes = base\n\t\t\t? new Map( base._prefixes.entries() )\n\t\t\t: new Map();\n\n\t\tthis._vocab = vocab ? vocab : base ? base._vocab : void 0;\n\n\t\tif( new.target === IRIResolver ) Object.freeze( this );\n\t}\n\n\t/**\n\t * Resolves (if necessary) and creates the respective tokens if the IRI provided.\n\t *\n\t * If vocab parameter is to `true`, the stored vocab IRI is used to resolve relative IRIs.\n\t *\n\t * @param relativeIRI The relative IRI to be resolved and tokenized.\n\t * @param vocab Optional parameter to specified if the relative IRIs will be resolved with the stored vocab IRI.\n\t * @returns An array of tokens representing the provided IRI to be used in the SPARQL query.\n\t */\n\tresolve( relativeIRI:string, vocab:boolean = false ):Token[] {\n\t\tlet tokens:Token[];\n\n\t\tif( isPrefixed( relativeIRI ) ) {\n\t\t\tconst [ prefix, prefixIRI ]:[ string, string ] = getPrefixedParts( relativeIRI );\n\n\t\t\tconst used:boolean = this._prefixes.get( prefix );\n\t\t\tif( used === void 0 ) throw new Error( \"The used prefix has not been declared\" );\n\n\t\t\ttokens = [ new StringLiteral( prefix ), PREFIX_SYMBOL, new StringLiteral( prefixIRI ) ];\n\t\t\tif( ! used ) this._prefixes.set( prefix, true );\n\t\t} else {\n\t\t\ttokens = resolve( relativeIRI, vocab ? this._vocab : void 0 );\n\t\t}\n\n\t\treturn tokens;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\nexport class StringToken implements TokenNode {\n\treadonly token:\"string\" = \"string\";\n\treadonly value:string;\n\n\tconstructor( value:string ) {\n\t\tthis.value = value;\n\t}\n\n\ttoString():string {\n\t\treturn `\"${ this.value }\"`;\n\t}\n}\n","import { isPrefixed } from \"./../iri\";\n\nimport { BooleanToken } from \"./BooleanToken\";\nimport { IRIToken } from \"./IRIToken\";\nimport { LanguageToken } from \"./LanguageToken\";\nimport { NumberToken } from \"./NumberToken\";\nimport { PrefixedNameToken } from \"./PrefixedNameToken\";\nimport { StringToken } from \"./StringToken\";\nimport { TokenNode } from \"./TokenNode\";\n\nexport class LiteralToken implements TokenNode {\n\treadonly token:\"literal\" = \"literal\";\n\tvalue?:NumberToken | BooleanToken | StringToken;\n\ttype?:IRIToken | PrefixedNameToken;\n\tlanguage?:LanguageToken;\n\n\tconstructor( value?:boolean | number | string ) {\n\t\tif( value === void 0 ) return;\n\t\tthis.setValue( value );\n\t}\n\n\tsetValue( value:boolean | number | string ):this {\n\t\tif( this.value && this.value.value === value ) return;\n\n\t\tthis.value = typeof  value === \"boolean\" ? new BooleanToken( value ) :\n\t\t\ttypeof value === \"number\" ? new NumberToken( value ) :\n\t\t\t\tnew StringToken( value );\n\n\t\treturn this;\n\t}\n\n\tsetType( type:string | IRIToken | PrefixedNameToken ):this {\n\t\tif( ! this.value ) throw new Error( \"Must set a value before a type.\" );\n\t\tif( this.value.token !== \"string\" ) this.value = new StringToken( `${ this.value }` );\n\n\t\tthis.type = typeof type === \"string\" ? isPrefixed( type ) ?\n\t\t\tnew PrefixedNameToken( type ) : new IRIToken( type ) : type;\n\n\t\treturn this;\n\t}\n\n\tsetLanguage( language:string ):this {\n\t\tif( ! this.value || this.value.token !== \"string\" ) throw new Error( \"Non-string value can't have a language.\" );\n\t\tthis.type = void 0;\n\t\tthis.language = new LanguageToken( language );\n\n\t\treturn this;\n\t}\n\n\ttoString():string {\n\t\tif( this.language ) return `${ this.value }${ this.language }`;\n\t\tif( this.type ) return `${ this.value }^^${ this.type }`;\n\t\treturn `${ this.value }`;\n\t}\n}\n","import { IRIToken } from \"./IRIToken\";\nimport { LiteralToken } from \"./LiteralToken\";\nimport { PrefixedNameToken } from \"./PrefixedNameToken\";\nimport { TokenNode } from \"./TokenNode\";\nimport { VariableToken } from \"./VariableToken\";\n\nexport class ValuesToken implements TokenNode {\n\treadonly token:\"values\" = \"values\";\n\treadonly variables:VariableToken[];\n\treadonly values:( IRIToken | PrefixedNameToken | LiteralToken | \"UNDEF\" )[][];\n\n\tconstructor() {\n\t\tthis.variables = [];\n\t\tthis.values = [];\n\t}\n\n\taddValues( variable:VariableToken, ...values:( IRIToken | PrefixedNameToken | LiteralToken | \"UNDEF\" )[] ):this {\n\t\tthis.variables.push( variable );\n\t\tthis.values.push( values );\n\n\t\treturn this;\n\t}\n\n\ttoString():string {\n\t\tconst variables:string = this.variables.length ? this.variables.length === 1 ? this.variables.join( \" \" ) :\n\t\t\t`( ${ this.variables.join( \" \" ) } )` : \"()\";\n\n\t\tconst values:any[] = this.variables.length ? this.variables.length === 1 ? this.values[ 0 ] :\n\t\t\tthis.values.map( varValues => `( ${ varValues.join( \" \" ) } )` ) : [ \"()\" ];\n\n\t\treturn `VALUES ${ variables } { ${ values.join( \" \" ) } }`;\n\t}\n}\n","import { TermToken } from \"./\";\nimport { PredicateToken } from \"./PredicateToken\";\nimport { TokenNode } from \"./TokenNode\";\nimport { VariableToken } from \"./VariableToken\";\n\nexport class SubjectToken implements TokenNode {\n\treadonly token:\"subject\" = \"subject\";\n\treadonly subject:VariableToken | TermToken;\n\treadonly predicates:PredicateToken[];\n\n\tconstructor( subject:VariableToken | TermToken ) {\n\t\tthis.subject = subject;\n\t\tthis.predicates = [];\n\t}\n\n\taddPredicate( predicate:PredicateToken ):this {\n\t\tthis.predicates.push( predicate );\n\t\treturn this;\n\t}\n\n\ttoString():string {\n\t\treturn `${ this.subject } ${ this.predicates.join( \"; \" ) }`;\n\t}\n}\n","import {\n\tObjectToken,\n\tVariableOrIRI,\n} from \"./\";\nimport { TokenNode } from \"./TokenNode\";\n\nexport class PredicateToken implements TokenNode {\n\treadonly token:\"predicate\" = \"predicate\";\n\treadonly predicate:VariableOrIRI | \"a\";\n\treadonly objects:ObjectToken[];\n\n\tconstructor( predicate:VariableOrIRI | \"a\" ) {\n\t\tthis.predicate = predicate;\n\t\tthis.objects = [];\n\t}\n\n\taddObject( object:ObjectToken ):this {\n\t\tthis.objects.push( object );\n\t\treturn this;\n\t}\n\n\ttoString():string {\n\t\treturn `${ this.predicate } ${ this.objects.join( \", \" ) }`;\n\t}\n}\n","import { PatternToken } from \"./\";\n\nexport const joinPatterns = ( patterns:PatternToken[] ):string => {\n\treturn patterns\n\t\t.map( pattern => {\n\t\t\tif( pattern.token === \"select\" ) return `{ ${ pattern } }`;\n\t\t\treturn pattern;\n\t\t} )\n\t\t.join( \". \" )\n\t\t;\n};\n","import { PatternToken } from \"./\";\nimport { TokenNode } from \"./TokenNode\";\nimport { joinPatterns } from \"./utils\";\n\nexport class OptionalToken implements TokenNode {\n\treadonly token:\"optional\" = \"optional\";\n\treadonly patterns:PatternToken[];\n\n\tconstructor() {\n\t\tthis.patterns = [];\n\t}\n\n\taddPattern( ...pattern:PatternToken[] ):this {\n\t\tthis.patterns.push( ...pattern );\n\t\treturn this;\n\t}\n\n\ttoString():string {\n\t\treturn `OPTIONAL { ${ joinPatterns( this.patterns ) } }`;\n\t}\n}\n","import {\n\tPatternToken,\n\tVariableOrIRI,\n} from \"./\";\nimport { TokenNode } from \"./TokenNode\";\nimport { joinPatterns } from \"./utils\";\n\nexport class GraphToken implements TokenNode {\n\treadonly token:\"graph\" = \"graph\";\n\treadonly graph:VariableOrIRI;\n\treadonly patterns:PatternToken[];\n\n\tconstructor( graph:VariableOrIRI ) {\n\t\tthis.graph = graph;\n\t\tthis.patterns = [];\n\t}\n\n\taddPattern( ...pattern:PatternToken[] ):this {\n\t\tthis.patterns.push( ...pattern );\n\t\treturn this;\n\t}\n\n\ttoString():string {\n\t\treturn `GRAPH ${ this.graph } { ${ joinPatterns( this.patterns ) } }`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\nimport { VariableToken } from \"./VariableToken\";\n\nexport class BindToken implements TokenNode {\n\treadonly token:\"bind\" = \"bind\";\n\treadonly expression:string;\n\treadonly variable:VariableToken;\n\n\tconstructor( expression:string, variable:VariableToken ) {\n\t\tthis.expression = expression;\n\t\tthis.variable = variable;\n\t}\n\n\ttoString():string {\n\t\treturn `BIND(${ this.expression } AS ${ this.variable })`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\nexport class FilterToken implements TokenNode {\n\treadonly token:\"filter\" = \"filter\";\n\treadonly constraint:string;\n\n\tconstructor( constraint:string ) {\n\t\tthis.constraint = constraint;\n\t}\n\n\ttoString():string {\n\t\treturn `FILTER( ${ this.constraint } )`;\n\t}\n}\n","import { IRIToken } from \"./IRIToken\";\nimport { TokenNode } from \"./TokenNode\";\n\nexport class PrefixToken implements TokenNode {\n\treadonly token:\"prefix\" = \"prefix\";\n\treadonly namespace:string;\n\treadonly iri:IRIToken;\n\n\tconstructor( namespace:string, iri:IRIToken ) {\n\t\tthis.namespace = namespace;\n\t\tthis.iri = iri;\n\t}\n\n\ttoString():string {\n\t\treturn `PREFIX ${ this.namespace }: ${ this.iri }`;\n\t}\n}\n","import {\n\tPatternToken,\n\tSolutionModifier,\n\tTripleToken,\n} from \"./\";\nimport { TokenNode } from \"./TokenNode\";\nimport { joinPatterns } from \"./utils\";\n\nexport class ConstructToken implements TokenNode {\n\treadonly token:\"construct\" = \"construct\";\n\treadonly triples:TripleToken[];\n\treadonly patterns:PatternToken[];\n\treadonly modifiers:SolutionModifier[];\n\n\tconstructor() {\n\t\tthis.triples = [];\n\t\tthis.patterns = [];\n\t\tthis.modifiers = [];\n\t}\n\n\taddTriple( ...triple:TripleToken[] ):this {\n\t\tthis.triples.push( ...triple );\n\t\treturn this;\n\t}\n\n\taddPattern( ...patterns:PatternToken[] ):this {\n\t\tthis.patterns.push( ...patterns );\n\t\treturn this;\n\t}\n\n\taddModifier( ...modifiers:SolutionModifier[] ):this {\n\t\tthis.modifiers.push( ...modifiers );\n\t\treturn this;\n\t}\n\n\ttoString():string {\n\t\tlet query:string = `CONSTRUCT { ${ this.triples.join( \". \" ) } } WHERE { ${ joinPatterns( this.patterns ) } }`;\n\t\tif( this.modifiers.length ) query += ` ${ this.modifiers.join( \" \" ) }`;\n\n\t\treturn query;\n\t}\n}\n","import {\n\tPatternToken,\n\tSolutionModifier,\n} from \"./\";\nimport { TokenNode } from \"./TokenNode\";\nimport { VariableToken } from \"./VariableToken\";\nimport { joinPatterns } from \"./utils\";\n\nexport class SelectToken implements TokenNode {\n\treadonly token:\"select\" = \"select\";\n\treadonly modifier?:\"DISTINCT\" | \"REDUCED\";\n\treadonly variables:VariableToken[];\n\treadonly patterns:PatternToken[];\n\treadonly modifiers:SolutionModifier[];\n\n\tconstructor( modifier?:\"DISTINCT\" | \"REDUCED\" ) {\n\t\tthis.modifier = modifier;\n\n\t\tthis.variables = [];\n\t\tthis.patterns = [];\n\t\tthis.modifiers = [];\n\t}\n\n\taddVariable( ...variables:VariableToken[] ):this {\n\t\tthis.variables.push( ...variables );\n\t\treturn this;\n\t}\n\n\taddPattern( ...patterns:PatternToken[] ):this {\n\t\tthis.patterns.push( ...patterns );\n\t\treturn this;\n\t}\n\n\taddModifier( ...modifier:SolutionModifier[] ):this {\n\t\tthis.modifiers.push( ...modifier );\n\t\treturn this;\n\t}\n\n\ttoString():string {\n\t\tlet query:string = `SELECT`;\n\n\t\tif( this.modifier ) query += ` ${ this.modifier }`;\n\t\tif( this.variables.length ) query += ` ${ this.variables.join( \" \" ) }`;\n\n\t\tquery += ` WHERE { ${ joinPatterns( this.patterns ) } }`;\n\n\t\tif( this.modifiers.length ) query += ` ${ this.modifiers.join( \" \" ) }`;\n\n\t\treturn query;\n\t}\n}\n","import { IRIToken } from \"./IRIToken\";\nimport { TokenNode } from \"./TokenNode\";\n\nexport class BaseToken implements TokenNode {\n\treadonly token:\"base\" = \"base\";\n\treadonly iri:IRIToken;\n\n\tconstructor( iri:IRIToken ) {\n\t\tthis.iri = iri;\n\t}\n\n\ttoString():string {\n\t\treturn `BASE ${ this.iri }`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\nimport { VariableToken } from \"./VariableToken\";\n\nexport class OrderToken implements TokenNode {\n\treadonly token:\"order\" = \"order\";\n\treadonly condition:VariableToken | string;\n\treadonly flow?:string;\n\n\tconstructor( condition:VariableToken | string, flow?:\"ASC\" | \"DESC\" ) {\n\t\tthis.condition = condition;\n\t\tif( flow ) this.flow = flow;\n\t}\n\n\ttoString():string {\n\t\treturn \"ORDER BY \" + ( this.flow ?\n\t\t\t`${ this.flow }( ${ this.condition } )` :\n\t\t\t`${ this.condition }` );\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\nexport class LimitToken implements TokenNode {\n\treadonly token:\"limit\" = \"limit\";\n\treadonly value:number;\n\n\tconstructor( value:number ) {\n\t\tthis.value = value;\n\t}\n\n\ttoString():string {\n\t\treturn `LIMIT ${ this.value }`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\nexport class OffsetToken implements TokenNode {\n\treadonly token:\"offset\" = \"offset\";\n\treadonly value:number;\n\n\tconstructor( value:number ) {\n\t\tthis.value = value;\n\t}\n\n\n\ttoString():string {\n\t\treturn `OFFSET ${ this.value }`;\n\t}\n}\n","import { BaseToken } from \"./BaseToken\";\nimport { ConstructToken } from \"./ConstructToken\";\nimport { PrefixToken } from \"./PrefixToken\";\nimport { TokenNode } from \"./TokenNode\";\nimport { ValuesToken } from \"./ValuesToken\";\n\nexport class QueryToken implements TokenNode {\n\treadonly token:\"query\" = \"query\";\n\treadonly prologues:( BaseToken | PrefixToken )[];\n\treadonly query:ConstructToken;\n\treadonly values?:ValuesToken;\n\n\tconstructor( query:ConstructToken, values?:ValuesToken ) {\n\t\tthis.prologues = [];\n\t\tthis.query = query;\n\t\tthis.values = values;\n\t}\n\n\taddPrologues( ...prologues:( BaseToken | PrefixToken )[] ):this {\n\t\tthis.prologues.push( ...prologues );\n\t\treturn this;\n\t}\n\n\ttoString():string {\n\t\tlet query:string = this.prologues.join( \" \" );\n\t\tif( this.prologues.length ) query += \" \";\n\n\t\tquery += this.query;\n\n\t\tif( this.values ) query += ` ${ this.values }`;\n\n\t\treturn query;\n\t}\n}\n","import { ObjectToken } from \"./\";\nimport { TokenNode } from \"./TokenNode\";\n\nexport class CollectionToken implements TokenNode {\n\treadonly token:\"collection\" = \"collection\";\n\treadonly objects:ObjectToken[];\n\n\tconstructor() {\n\t\tthis.objects = [];\n\t}\n\n\taddObject( object:ObjectToken ):this {\n\t\tthis.objects.push( object );\n\t\treturn this;\n\t}\n\n\ttoString():string {\n\t\tif( ! this.objects.length ) return \"()\";\n\t\treturn `( ${ this.objects.join( \" \" ) } )`;\n\t}\n}\n","import {\n\tIdentifier,\n\tLeftSymbol,\n\tNewLineSymbol,\n\tOperator,\n\tRightSymbol,\n} from \"./../tokens\";\n\nexport const VAR_SYMBOL:LeftSymbol = new LeftSymbol( \"?\" );\nexport const PREFIX_SYMBOL:Operator = new Operator( \":\" );\nexport const OFF_TYPE:Operator = new Operator( \"^^\" );\nexport const LANG_SYMBOL:Operator = new Operator( \"@\" );\nexport const ALL:RightSymbol = new RightSymbol( \"*\" );\n\nexport const OPEN_IRI:LeftSymbol = new LeftSymbol( \"<\" );\nexport const CLOSE_IRI:RightSymbol = new RightSymbol( \">\" );\n\nexport const OPEN_QUOTE:LeftSymbol = new LeftSymbol( \"\\\"\" );\nexport const CLOSE_QUOTE:RightSymbol = new RightSymbol( \"\\\"\" );\n\nexport const GRAPH_PATTERN_SEPARATOR:NewLineSymbol = new NewLineSymbol( \".\" );\nexport const SAME_SUBJECT_SEPARATOR:NewLineSymbol = new NewLineSymbol( \";\" );\nexport const SAME_PROPERTY_SEPARATOR:NewLineSymbol = new NewLineSymbol( \",\" );\nexport const EMPTY_SEPARATOR:NewLineSymbol = new NewLineSymbol( \"\" );\n\nexport const OPEN_MULTI_BLOCK:NewLineSymbol = new NewLineSymbol( \"{\" );\nexport const CLOSE_MULTI_BLOCK:NewLineSymbol = new NewLineSymbol( \"}\" );\nexport const OPEN_SINGLE_BLOCK:LeftSymbol = new LeftSymbol( \"{\" );\nexport const CLOSE_SINGLE_BLOCK:RightSymbol = new RightSymbol( \"}\" );\n\nexport const OPEN_MULTI_BN:NewLineSymbol = new NewLineSymbol( \"[\" );\nexport const CLOSE_MULTI_BN:NewLineSymbol = new NewLineSymbol( \"]\" );\nexport const OPEN_SINGLE_BN:LeftSymbol = new LeftSymbol( \"[\" );\nexport const CLOSE_SINGLE_BN:RightSymbol = new RightSymbol( \"]\" );\n\nexport const OPEN_MULTI_LIST:NewLineSymbol = new NewLineSymbol( \"(\" );\nexport const CLOSE_MULTI_LIST:NewLineSymbol = new NewLineSymbol( \")\" );\nexport const OPEN_SINGLE_LIST:LeftSymbol = new LeftSymbol( \"(\" );\nexport const CLOSE_SINGLE_LIST:RightSymbol = new RightSymbol( \")\" );\n\nexport const BASE:Identifier = new Identifier( \"BASE\" );\nexport const PREFIX:Identifier = new Identifier( \"PREFIX\" );\nexport const SELECT:Identifier = new Identifier( \"SELECT\" );\nexport const FROM:Identifier = new Identifier( \"FROM\" );\nexport const NAMED:Identifier = new Identifier( \"NAMED\" );\nexport const WHERE:Identifier = new Identifier( \"WHERE\" );\nexport const GROUP:Identifier = new Identifier( \"GROUP\" );\nexport const BY:Identifier = new Identifier( \"BY\" );\nexport const HAVING:Identifier = new Identifier( \"HAVING\" );\nexport const ORDER:Identifier = new Identifier( \"ORDER\" );\nexport const LIMIT:Identifier = new Identifier( \"LIMIT\" );\nexport const OFFSET:Identifier = new Identifier( \"OFFSET\" );\n\nexport const GRAPH:Identifier = new Identifier( \"GRAPH\" );\nexport const OPTIONAL:Identifier = new Identifier( \"OPTIONAL\" );\nexport const UNION:Identifier = new Identifier( \"UNION\" );\nexport const MINUS:Identifier = new Identifier( \"MINUS\" );\nexport const VALUES:Identifier = new Identifier( \"VALUES\" );\nexport const UNDEF:Identifier = new Identifier( \"UNDEF\" );\n\nexport const DISTINCT:Identifier = new Identifier( \"DISTINCT\" );\nexport const REDUCED:Identifier = new Identifier( \"REDUCED\" );\n\nexport const SERVICE:Identifier = new Identifier( \"SERVICE\" );\nexport const SILENT:Identifier = new Identifier( \"SILENT\" );\n\nexport const BIND:Identifier = new Identifier( \"BIND\" );\nexport const AS:Identifier = new Identifier( \"AS\" );\n\nexport const FILTER:Identifier = new Identifier( \"FILTER\" );\n\n","import {\n\tContainer,\n\tFinishClause,\n} from \"./..\";\nimport {\n\tBASE,\n\tCLOSE_MULTI_BLOCK,\n\tCLOSE_MULTI_BN,\n\tCLOSE_MULTI_LIST,\n\tEMPTY_SEPARATOR,\n\tGRAPH_PATTERN_SEPARATOR,\n\tOPEN_MULTI_BLOCK,\n\tOPEN_MULTI_BN,\n\tOPEN_MULTI_LIST,\n\tPREFIX,\n\tSAME_PROPERTY_SEPARATOR,\n\tSAME_SUBJECT_SEPARATOR,\n\tSELECT,\n\tWHERE,\n} from \"./../../patterns/tokens\";\nimport {\n\tNewLineSymbol,\n\tStringLiteral,\n\tToken,\n\tTokenFormat,\n} from \"./../../tokens\";\n\n/**\n * Constructs a compact SPARQL query string.\n * @returns The compact string.\n */\nfunction toCompactString( this:Container<FinishClause> ):string {\n\t// Optional tokens\n\tconst tokens:Token[] = this._tokens\n\t\t.filter( token => token !== WHERE );\n\n\tconst maxTokens:Token[] = [ SELECT ];\n\tlet baseTokens:Token[];\n\n\tfor( let index:number = 0, token:Token = tokens[ index ]; token && maxTokens.indexOf( token ) === - 1; ++ index, token = tokens[ index ] ) {\n\t\t// Remove unused prefixes\n\t\tif( token === PREFIX ) {\n\t\t\tconst nextToken:Token = tokens[ index + 1 ];\n\t\t\tif( ! this._iriResolver._prefixes.get( nextToken[ \"value\" ] ) ) {\n\t\t\t\ttokens.splice( index, 6 );\n\t\t\t\t-- index;\n\t\t\t}\n\t\t}\n\n\t\t// Remove bases and store the last one\n\t\telse if( token === BASE ) {\n\t\t\tbaseTokens = tokens.splice( index, 4 );\n\t\t\t-- index;\n\t\t}\n\t}\n\n\t// Add the last base as first element\n\tif( baseTokens ) {\n\t\t// TODO: Workaround on Stardog error parser\n\t\tconst baseString:string = baseTokens.reduce( ( res, token, index, thisArray ) => {\n\t\t\tlet nextToken:Token = thisArray[ index + 1 ];\n\t\t\treturn res + token.getTokenValue( TokenFormat.PRETTY, nextToken );\n\t\t}, \"\" ) + \"\\n\";\n\t\ttokens.unshift( new StringLiteral( baseString ) );\n\t}\n\n\treturn tokens.reduce( ( res, token, index, thisArray ) => {\n\t\tlet nextToken:Token = thisArray[ index + 1 ];\n\n\t\tif( nextToken === EMPTY_SEPARATOR ) nextToken = thisArray[ index + 2 ];\n\t\treturn res + token.getTokenValue( TokenFormat.COMPACT, nextToken );\n\t}, \"\" );\n}\n\n/**\n * Constructs a pretty SPARQL query string.\n * @returns The pretty string.\n */\nfunction toPrettyString( this:Container<FinishClause> ):string {\n\tconst stack:{ token:Token, indentation:number, subject:number, property:number, spaces:number }[] = [];\n\tlet actual:{ token:Token, indentation:number, subject:number, property:number, spaces:number } = {\n\t\ttoken: null,\n\t\tindentation: 0,\n\t\tsubject: 0,\n\t\tproperty: 0,\n\t\tspaces: 0,\n\t};\n\n\treturn this._tokens.reduce( ( res, token, index, tokens ) => {\n\t\tlet nextToken:Token = tokens[ index + 1 ];\n\t\tlet tokenString:string = token.getTokenValue( TokenFormat.PRETTY, nextToken );\n\n\t\t// Keep track of the indentation spaces\n\t\tif( actual.spaces === 0 ) {\n\t\t\tactual.subject += tokenString.length;\n\t\t\tif( tokenString.endsWith( \" \" ) ) actual.spaces ++;\n\t\t} else if( actual.spaces === 1 ) {\n\t\t\tactual.property += tokenString.length;\n\t\t\tif( tokenString.endsWith( \" \" ) ) actual.spaces ++;\n\t\t}\n\n\t\t// Check if a new block of lines\n\t\tif( [ OPEN_MULTI_BLOCK as Token, OPEN_MULTI_BN, OPEN_MULTI_LIST ].indexOf( token ) !== - 1 ) {\n\n\t\t\t// Record a new state for a block of triples\n\t\t\tstack.push( actual );\n\t\t\tactual = {\n\t\t\t\ttoken: token,\n\t\t\t\tindentation: actual.indentation + 4,\n\t\t\t\tsubject: 0,\n\t\t\t\tproperty: 0,\n\t\t\t\tspaces: token === OPEN_MULTI_BLOCK ? 0 : token === OPEN_MULTI_BN ? 1 : 2,\n\t\t\t};\n\n\t\t} else if( [ CLOSE_MULTI_LIST as Token ].indexOf( token ) !== - 1 ) {\n\t\t\tif( nextToken && ! ( nextToken instanceof NewLineSymbol ) ) {\n\n\t\t\t\t// Obtain parent state\n\t\t\t\tlet parent = actual;\n\t\t\t\twhile( [ OPEN_MULTI_BLOCK as Token, OPEN_MULTI_BN, OPEN_MULTI_LIST ].indexOf( parent.token ) === - 1 )\n\t\t\t\t\tparent = stack.pop();\n\t\t\t\tstack.push( parent );\n\n\t\t\t\t// Record a new state for properties of a collection\n\t\t\t\tactual = {\n\t\t\t\t\ttoken: token,\n\t\t\t\t\tindentation: parent.indentation + 4,\n\t\t\t\t\tsubject: 0,\n\t\t\t\t\tproperty: 0,\n\t\t\t\t\tspaces: 1,\n\t\t\t\t};\n\t\t\t}\n\n\t\t} else if( [ SAME_SUBJECT_SEPARATOR as Token, SAME_PROPERTY_SEPARATOR, CLOSE_MULTI_LIST ].indexOf( token ) !== - 1 ) {\n\n\t\t\t// Obtain parent state\n\t\t\tlet parent = actual;\n\t\t\twhile( [ OPEN_MULTI_BLOCK as Token, OPEN_MULTI_BN, OPEN_MULTI_LIST, CLOSE_MULTI_LIST, CLOSE_MULTI_BN ].indexOf( parent.token ) === - 1 )\n\t\t\t\tparent = stack.pop();\n\t\t\tstack.push( parent );\n\n\t\t\t// Record a new state for same subject properties\n\t\t\tif( token === SAME_SUBJECT_SEPARATOR ) {\n\t\t\t\tactual = {\n\t\t\t\t\ttoken: token,\n\t\t\t\t\tindentation: parent.indentation + actual.subject,\n\t\t\t\t\tsubject: actual.subject,\n\t\t\t\t\tproperty: 0,\n\t\t\t\t\tspaces: 1,\n\t\t\t\t};\n\n\t\t\t\t// Record a new state for a list of objects of a property\n\t\t\t} else if( token === SAME_PROPERTY_SEPARATOR ) {\n\t\t\t\tactual = {\n\t\t\t\t\ttoken: token,\n\t\t\t\t\tindentation: parent.indentation + actual.subject + actual.property,\n\t\t\t\t\tsubject: actual.subject,\n\t\t\t\t\tproperty: actual.property,\n\t\t\t\t\tspaces: 2,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Returns still a block state\n\t\t} else if( token === GRAPH_PATTERN_SEPARATOR ) {\n\t\t\twhile( actual.token !== OPEN_MULTI_BLOCK ) actual = stack.pop();\n\t\t\tactual.spaces = 0;\n\t\t\tactual.subject = 0;\n\t\t\tactual.property = 0;\n\t\t}\n\n\t\tif( nextToken === CLOSE_MULTI_BLOCK ) {\n\t\t\twhile( actual.token !== OPEN_MULTI_BLOCK ) actual = stack.pop();\n\t\t\tactual = stack.pop();\n\t\t} else if( nextToken === CLOSE_MULTI_BN ) {\n\t\t\twhile( actual.token !== OPEN_MULTI_BN ) actual = stack.pop();\n\t\t\tactual = stack.pop();\n\t\t} else if( nextToken === CLOSE_MULTI_LIST ) {\n\t\t\twhile( actual.token !== OPEN_MULTI_LIST ) actual = stack.pop();\n\t\t\tactual = stack.pop();\n\t\t}\n\n\t\tif( tokenString.endsWith( \"\\n\" ) ) {\n\t\t\ttokenString = tokenString + \" \".repeat( actual.indentation );\n\t\t}\n\n\t\treturn res + tokenString;\n\t}, \"\" );\n}\n\n/**\n * Decorator that binds the FinishClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object The object to add the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function finishDecorator<W extends object>( container:Container<FinishClause>, object:W ):W & FinishClause {\n\treturn Object.assign( object, {\n\t\ttoCompactString: toCompactString.bind( container ),\n\t\ttoPrettyString: toPrettyString.bind( container ),\n\t\ttoString: toPrettyString.bind( container ),\n\t} );\n}\n","import { SubFinishClause } from \"./..\";\nimport { Container } from \"./../Container\";\nimport {\n\tCLOSE_MULTI_BLOCK,\n\tOPEN_MULTI_BLOCK,\n} from \"./../../patterns/tokens\";\nimport { Token } from \"./../../tokens\";\n\n/**\n * Returns the tokens of the that represent all the subSelect clause\n * pattern.\n *\n * @returns Array of the tokens of the clause pattern.\n */\nfunction getPattern( this:Container<SubFinishClause> ):Token[] {\n\treturn [ OPEN_MULTI_BLOCK, ...this._tokens, CLOSE_MULTI_BLOCK ];\n}\n\n/**\n * Decorator that binds the {@link SubFinishClause} methods to a\n * container and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function subFinishDecorator<W extends object>( container:Container<SubFinishClause>, object:W ):W & SubFinishClause {\n\treturn Object.assign( object, {\n\t\tgetPattern: getPattern.bind( container ),\n\t} );\n}\n","import { finishDecorator as originalFinishDecorator } from \"./decorators/finish\";\nimport { subFinishDecorator } from \"./decorators/subFinish\";\nimport {\n\tFinishClause,\n\tSubFinishClause,\n} from \"./interfaces\";\nimport { IRIResolver } from \"./../iri/IRIResolver\";\nimport { Token } from \"./../tokens/Token\";\n\n\n/**\n * Interface of possible functions to be be used as finish decorators.\n *\n * Should accept a container with the query data as first parameter and\n * as second the object to decorate.\n */\nexport interface FinishDecorator<T extends FinishClause | SubFinishClause> extends Function {\n\t<W extends object>( container:Container<T>, object:W ):T & W;\n}\n\n/**\n * Immutable class that contains the hidden data of the query builder.\n *\n * Every step of the builder uses a different instance of the container\n * to make the query builder immutable-like.\n */\nexport class Container<T extends FinishClause | SubFinishClause = FinishClause> {\n\n\t/**\n\t * Array containing the query tokens.\n\t */\n\treadonly _tokens:Token[];\n\n\t/**\n\t * Decorator that extends the finish clause.\n\t */\n\treadonly _finishDecorator:FinishDecorator<T>;\n\n\t/**\n\t * Optional implementation of the IRI Resolver interface.\n\t */\n\treadonly _iriResolver?:IRIResolver;\n\n\t/**\n\t * Creates an empty container with the default finish decorator: {@link finishDecorator}.\n\t */\n\tconstructor();\n\t/**\n\t * Creates an empty container with a custom finish decorator.\n\t *\n\t * @param finishDecorator The finish decorated to be used in the container.\n\t */\n\tconstructor( finishDecorator:FinishDecorator<T> );\n\t/**\n\t * Creates a container copping the data of the previous container provided.\n\t *\n\t * If `newTokens` parameter is provided its data will be appended to the tokens\n\t * of the previous container tokens.\n\t *\n\t * If the `iriResolver` is provided, it will be used in the new container instead\n\t * of the IRIResolver of the previous container. But if the value is `null` the\n\t * `_iriResolver` property will be undefined.\n\t *\n\t * @param previousContainer Container to be copied.\n\t * @param newTokens Tokens to append to the to the previousContainer tokens copied.\n\t * @param iriResolver IRIResolver to be used.\n\t */\n\tconstructor( previousContainer:Container<any>, newTokens?:Token[], iriResolver?:IRIResolver );\n\tconstructor( containerOrFunction?:Container<any> | FinishDecorator<T>, newTokens?:Token[], iriResolver?:IRIResolver ) {\n\t\tconst container:Container<any> = containerOrFunction instanceof Function ?\n\t\t\tvoid 0 : containerOrFunction;\n\n\t\tconst finishDecorator:FinishDecorator<T> = containerOrFunction instanceof Function\n\t\t\t? containerOrFunction : originalFinishDecorator as FinishDecorator<T>;\n\n\t\tthis._iriResolver = finishDecorator !== subFinishDecorator ? ! iriResolver ? container ? container._iriResolver ?\n\t\t\tnew IRIResolver( container._iriResolver ) : void 0 : new IRIResolver() : iriResolver : void 0;\n\n\t\tconst previousTokens:Token[] = container ? container._tokens : [];\n\t\tif( ! newTokens ) newTokens = [];\n\t\tthis._tokens = previousTokens.concat( newTokens );\n\n\t\tthis._finishDecorator = container\n\t\t\t? container._finishDecorator\n\t\t\t: finishDecorator;\n\n\t\tif( new.target === Container ) Object.freeze( this );\n\t}\n}\n\nexport default Container;\n","import {\n\tFinishClause,\n\tFromClause,\n} from \"./..\";\nimport { Container } from \"./../Container\";\nimport { whereDecorator } from \"./\";\nimport { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tFROM,\n\tNAMED,\n} from \"./../../patterns/tokens\";\nimport { Token } from \"./../../tokens\";\n\n/**\n * Internal function that actually creates the tokens of the\n * FromClause methods.\n *\n * @param self The container that is bound to the FromClause methods.\n * @param tokens Initial tokens depending which methods is called.\n * @param iri The iri of the resource to be included.\n * @returns Object with the methods to keep constructing to query.\n * @private\n */\nfunction _from<T extends FinishClause>( self:Container<T>, tokens:Token[], iri:string ):FromClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( self._iriResolver );\n\ttokens.push( ...iriResolver.resolve( iri ) );\n\n\tconst container:Container<T> = new Container<T>( self, tokens, iriResolver );\n\treturn fromDecorator<T, {}>( container, {} );\n}\n\n/**\n * Set a default graph to be included as the RDF Dataset where to\n * look for the query solutions.\n *\n * @param iri IRI of the default graph to be included.\n * @returns Object with the methods to keep constructing to query.\n */\nfunction from<T extends FinishClause>( this:Container<T>, iri:string ):FromClause<T> {\n\treturn _from<T>( this, [ FROM ], iri );\n}\n\n/**\n * Set a named graph to be included as the RDF Dataset where to look for\n * the query solutions.\n *\n * @param iri IRI of the named graph to be included.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction fromNamed<T extends FinishClause>( this:Container<T>, iri:string ):FromClause<T> {\n\treturn _from<T>( this, [ FROM, NAMED ], iri );\n}\n\n/**\n * Decorator that binds the FromClause methods to a container and\n * adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function fromDecorator<T extends FinishClause, W extends object>( container:Container<T>, object:W ):W & FromClause<T> {\n\treturn Object.assign( whereDecorator( container, object ), {\n\t\tfrom: from.bind( container ),\n\t\tfromNamed: fromNamed.bind( container ),\n\t} );\n}\n","import {\n\tFinishClause,\n\tGroupClause,\n\tHavingClause,\n\tSubFinishClause,\n} from \"./..\";\nimport { Container } from \"./../Container\";\nimport { havingDecorator } from \"./\";\nimport {\n\tBY,\n\tGROUP,\n} from \"./../../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\n\n/**\n * Set a condition to be divide the solutions returned by the query\n * into one or more groups.\n *\n * @param rawCondition Raw condition to be applied to the solutions grouping.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction groupBy<T extends FinishClause | SubFinishClause>( this:Container<T>, rawCondition:string ):HavingClause<T> & T {\n\tconst tokens:Token[] = [ GROUP, BY, new StringLiteral( rawCondition ) ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens );\n\treturn this._finishDecorator<HavingClause<T>>( container, havingDecorator<T, {}>( container, {} ) );\n}\n\n/**\n * Decorator that binds the GroupClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function groupDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & GroupClause<T> {\n\treturn Object.assign( havingDecorator( container, object ), {\n\t\tgroupBy: groupBy.bind( container ),\n\t} );\n}\n","import { Container } from \"./../Container\";\nimport { orderDecorator } from \"./\";\nimport {\n\tFinishClause,\n\tHavingClause,\n\tOrderClause,\n\tSubFinishClause,\n} from \"./../interfaces\";\nimport { HAVING } from \"./../../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\n\n/**\n * Set a condition to filter the sequence of solutions the query will\n * retrieve.\n *\n * Notice: The current version of SPARQLER does not evaluate the condition\n * for possible errors\n *\n * @param rawCondition Raw condition to be applied for the solutions filtering.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction having<T extends FinishClause | SubFinishClause>( this:Container<T>, rawCondition:string ):OrderClause<T> & T {\n\tconst tokens:Token[] = [ HAVING, new StringLiteral( rawCondition ) ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens );\n\treturn this._finishDecorator<OrderClause<T>>( container, orderDecorator<T, {}>( container, {} ) );\n}\n\n// having( rawCondition:string ):OrderClause<T> & T;\n\n/**\n * Decorator that binds the HavingClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function havingDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & HavingClause<T> {\n\treturn Object.assign( orderDecorator<T, W>( container, object ), {\n\t\thaving: having.bind( container ),\n\t} );\n}\n","import { GraphPattern } from \"../interfaces\";\nimport { Token } from \"../../tokens/Token\";\n\nexport class NotTriplesPattern implements GraphPattern {\n\n\tprotected patternTokens:Token[];\n\n\tconstructor( tokens:Token[] ) {\n\t\tthis.patternTokens = tokens;\n\t}\n\n\tgetPattern():Token[] {\n\t\treturn this.patternTokens;\n\t}\n\n}\n\nexport default NotTriplesPattern;\n","export const NAMESPACE:string = \"http://www.w3.org/2001/XMLSchema#\";\n\nexport const dateTime:string = NAMESPACE + \"dateTime\";\n\nexport const integer:string = NAMESPACE + \"integer\";\n\nexport const float:string = NAMESPACE + \"float\";\n\nexport const boolean:string = NAMESPACE + \"boolean\";\n\nexport const string:string = NAMESPACE + \"string\";\n","import {\n\tSupportedNativeTypes,\n\tElementPattern\n} from \"../patterns/interfaces\";\nimport * as XSD from \"./XSD\";\nimport { Token } from \"../tokens/Token\";\nimport { StringLiteral } from \"../tokens/StringLiteral\";\nimport {\n\tOPEN_QUOTE,\n\tCLOSE_QUOTE,\n\tCLOSE_IRI,\n\tOPEN_IRI,\n\tOFF_TYPE,\n\tUNDEF\n} from \"../patterns/tokens\";\nimport { PatternBuilder } from \"../patterns/PatternBuilder\";\n\nexport function serialize( object:SupportedNativeTypes | ElementPattern ):Token[];\nexport function serialize( object ):Token[] {\n\n\tif( typeof object === \"string\" || object instanceof String ) {\n\t\tif( object === PatternBuilder.undefined ) return [ UNDEF ];\n\t\treturn [ OPEN_QUOTE, new StringLiteral( object as string ), CLOSE_QUOTE ];\n\t}\n\n\tif( typeof object === \"number\" || object instanceof Number ) {\n\t\tif( Number.isInteger( object.valueOf() ) )\n\t\t\treturn this.addType( object + \"\", \"integer\" );\n\t\treturn this.addType( object + \"\", \"float\" );\n\t}\n\n\tif( typeof object === \"boolean\" || object instanceof Boolean )\n\t\treturn this.addType( object + \"\", \"boolean\" );\n\n\tif( object instanceof Date )\n\t\treturn this.addType( object.toISOString(), \"dateTime\" );\n\n\treturn object.getSelfTokens();\n}\n\nexport function addType( value:string, type:string ):Token[] {\n\tif( type in XSD ) type = XSD[ type ];\n\treturn [ OPEN_QUOTE, new StringLiteral( value ), CLOSE_QUOTE, OFF_TYPE, OPEN_IRI, new StringLiteral( type ), CLOSE_IRI ];\n}\n\n","import { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tMultipleValuesPattern,\n\tMultipleValuesPatternMore,\n\tSingleValuesPattern,\n\tSingleValuesPatternMore,\n\tSupportedNativeTypes,\n\tUndefined,\n} from \"./..\";\nimport { NotTriplesPattern } from \"./\";\nimport {\n\tCLOSE_MULTI_BLOCK,\n\tCLOSE_SINGLE_BLOCK,\n\tCLOSE_SINGLE_LIST,\n\tOPEN_MULTI_BLOCK,\n\tOPEN_SINGLE_BLOCK,\n\tOPEN_SINGLE_LIST,\n\tVALUES,\n} from \"./../tokens\";\nimport {\n\tLiteral,\n\tResource,\n\tVariable,\n} from \"./../triples\";\nimport { Token } from \"./../../tokens\";\nimport { serialize } from \"./../../utils/ObjectPattern\";\n\nexport class ValuesPattern extends NotTriplesPattern implements SingleValuesPattern, MultipleValuesPattern {\n\n\tprivate resolver;\n\tprivate length:number;\n\n\tprotected interfaces:{\n\t\taddPattern:SingleValuesPatternMore | MultipleValuesPatternMore;\n\t};\n\n\tconstructor( resolver:IRIResolver, variables:Variable[] ) {\n\t\tsuper( [ VALUES ] );\n\t\tthis.init();\n\n\t\tthis.resolver = resolver;\n\t\tthis.length = variables.length;\n\n\t\tif( this.length === 1 ) {\n\t\t\tthis.patternTokens.push( ...variables[ 0 ].getSelfTokens(), OPEN_SINGLE_BLOCK );\n\t\t} else {\n\t\t\tthis.patternTokens.push( OPEN_SINGLE_LIST );\n\t\t\tvariables.forEach( variable => this.patternTokens.push( ...variable.getSelfTokens() ) );\n\t\t\tthis.patternTokens.push( CLOSE_SINGLE_LIST, OPEN_MULTI_BLOCK );\n\t\t}\n\t}\n\n\thas( value:SupportedNativeTypes ):SingleValuesPatternMore;\n\thas( value:Resource ):SingleValuesPatternMore;\n\thas( value:Literal ):SingleValuesPatternMore;\n\thas( value:Undefined ):SingleValuesPatternMore;\n\thas( ...values:( SupportedNativeTypes | Resource | Literal | Undefined )[] ):MultipleValuesPatternMore;\n\thas( ...values ):( SingleValuesPatternMore | MultipleValuesPatternMore ) {\n\t\tif( this.length !== values.length ) throw new Error( \"InvalidArgumentError: The number of variables and values are different.\" );\n\n\t\tif( this.length === 1 ) {\n\t\t\tthis.patternTokens.push( ...serialize( values[ 0 ] ) );\n\t\t} else {\n\t\t\tthis.patternTokens.push( OPEN_SINGLE_LIST );\n\t\t\tvalues.forEach( value => {\n\t\t\t\treturn this.patternTokens.push( ...serialize( value ) );\n\t\t\t} );\n\t\t\tthis.patternTokens.push( CLOSE_SINGLE_LIST );\n\t\t}\n\t\treturn this.interfaces.addPattern;\n\t}\n\n\tgetPattern():Token[] {\n\t\tif( this.length === 1 ) {\n\t\t\tthis.patternTokens.push( CLOSE_SINGLE_BLOCK );\n\t\t} else {\n\t\t\tthis.patternTokens.push( CLOSE_MULTI_BLOCK );\n\t\t}\n\n\t\treturn this.patternTokens;\n\t}\n\n\tprivate init():void {\n\t\tthis.interfaces = <any> {\n\t\t\taddPattern: {\n\t\t\t\tand: this.has.bind( this ),\n\t\t\t\tgetPattern: () => this.getPattern(),\n\t\t\t},\n\t\t};\n\t}\n\n}\n\nexport default ValuesPattern;","import { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tElementPattern,\n\tGraphPattern,\n\tSupportedNativeTypes,\n\tTriplesNodePattern,\n\tTriplesSameSubject,\n\tTriplesSameSubjectMore,\n} from \"./..\";\nimport {\n\tSAME_PROPERTY_SEPARATOR,\n\tSAME_SUBJECT_SEPARATOR,\n} from \"./../tokens\";\nimport {\n\tLiteral,\n\tResource,\n\tVariable,\n} from \"./\";\nimport {\n\tLeftSymbol,\n\tOperator,\n\tRightSymbol,\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\nimport { serialize } from \"./../../utils/ObjectPattern\";\n\nexport abstract class TriplesPattern<T extends GraphPattern> implements TriplesSameSubject<T>, ElementPattern {\n\n\tprotected abstract elementTokens:Token[];\n\tprotected patternTokens:Token[];\n\n\tprotected interfaces:{\n\t\taddPattern:TriplesSameSubjectMore<T>;\n\t\tgraphPattern?:T\n\t};\n\n\tprivate resolver:IRIResolver;\n\n\tconstructor( resolver:IRIResolver ) {\n\t\tthis.resolver = resolver;\n\t\tthis.patternTokens = [];\n\t\tthis.init();\n\t}\n\n\n\thas( property:string | Variable | Resource, object:SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern ):TriplesSameSubjectMore<T> & T;\n\thas( property:string | Variable | Resource, objects:(SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern)[] ):TriplesSameSubjectMore<T> & T;\n\thas( property:string | Variable | Resource, objects ):TriplesSameSubjectMore<T> & T {\n\t\tthis.patternTokens = [];\n\t\treturn this._addPattern( property, objects );\n\t}\n\n\tgetSelfTokens():Token[] {\n\t\treturn this.elementTokens;\n\t}\n\n\tprotected init():void {\n\t\tthis.interfaces = {\n\t\t\taddPattern: {\n\t\t\t\tand: ( property, objects ) => {\n\t\t\t\t\tthis.patternTokens.push( SAME_SUBJECT_SEPARATOR );\n\t\t\t\t\treturn this._addPattern( property, objects );\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t};\n\n\tprivate _addPattern( property:string | Variable | Resource, objects:ElementPattern | ElementPattern[] ):TriplesSameSubjectMore<T> & T {\n\t\tlet tokens:Token[] = ( typeof property === \"string\" )\n\t\t\t? this._resolvePath( property )\n\t\t\t: property.getSelfTokens();\n\n\t\tobjects = Array.isArray( objects ) ? objects : [ objects ];\n\t\tobjects.forEach( ( value, index, array ) => {\n\t\t\ttokens.push( ...serialize( value ) );\n\t\t\tif( index < array.length - 1 ) tokens.push( SAME_PROPERTY_SEPARATOR );\n\t\t} );\n\n\t\tthis.patternTokens.push( ...tokens );\n\t\treturn Object.assign( {}, this.interfaces.addPattern, this.interfaces.graphPattern );\n\t}\n\n\tprivate static PATH_OPERATORS:string[] = [ \"|\", \"/\", \"^\", \"?\", \"*\", \"+\", \"!\", \"(\", \")\" ];\n\n\tprivate _resolvePath( propertyPath:string ):Token[] {\n\t\tconst tokens:Token[] = propertyPath\n\t\t\t.split( /(<.*?>)/ ).reduce( ( array:string[], part:string ) => {\n\t\t\t\t// Is an IRI\n\t\t\t\tif( part.startsWith( \"<\" ) ) {\n\t\t\t\t\tarray.push( part );\n\t\t\t\t}\n\n\t\t\t\t// Everything else\n\t\t\t\telse {\n\t\t\t\t\tarray.push( ...part.split( /([|/^?*+!()])/ ) )\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\t\t\t}, [] )\n\t\t\t.reduce( ( array:Token[], part:string ) => {\n\t\t\t\tif( ! part ) return array;\n\n\t\t\t\t// Operators\n\t\t\t\tif( TriplesPattern.PATH_OPERATORS.indexOf( part ) !== - 1 ) {\n\t\t\t\t\tarray.push( new Operator( part ) );\n\t\t\t\t}\n\n\t\t\t\t// \"a\" keyword\n\t\t\t\telse if( part === \"a\" ) {\n\t\t\t\t\tarray.push( new StringLiteral( part ) );\n\t\t\t\t}\n\n\t\t\t\t// IRI or prefix\n\t\t\t\telse {\n\t\t\t\t\tif( part.startsWith( \"<\" ) && part.endsWith( \">\" ) ) part = part.slice( 1, - 1 );\n\t\t\t\t\tarray.push( ...this.resolver.resolve( part, true ) );\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\t\t\t}, [] );\n\n\n\t\tif( tokens[ 0 ] instanceof Operator )\n\t\t\ttokens.unshift( new LeftSymbol( \"\" ) );\n\t\tif( tokens[ tokens.length - 1 ] instanceof Operator )\n\t\t\ttokens.push( new RightSymbol( \"\" ) );\n\n\t\treturn tokens;\n\t}\n\n}\n\nexport default TriplesPattern;\n","import { TriplesNodePattern } from \"./..\";\nimport {\n\tCLOSE_MULTI_BN,\n\tCLOSE_SINGLE_BN,\n\tOPEN_MULTI_BN,\n\tOPEN_SINGLE_BN,\n\tSAME_PROPERTY_SEPARATOR,\n\tSAME_SUBJECT_SEPARATOR,\n} from \"./../tokens\";\nimport { TriplesPattern } from \"./TriplesPattern\";\nimport { Token } from \"./../../tokens\";\n\nexport class BlankNode extends TriplesPattern<TriplesNodePattern> {\n\n\tprotected elementTokens:Token[];\n\n\tgetSelfTokens():Token[] {\n\t\tif( ! this.patternTokens.find( token => token === SAME_SUBJECT_SEPARATOR || token === SAME_PROPERTY_SEPARATOR ) )\n\t\t\treturn [ OPEN_SINGLE_BN, ...this.patternTokens, CLOSE_SINGLE_BN ];\n\n\t\treturn [ OPEN_MULTI_BN, ...this.patternTokens, CLOSE_MULTI_BN ];\n\t}\n\n\tprotected init():void {\n\t\tsuper.init();\n\t\tthis.interfaces.graphPattern = {\n\t\t\tgetPattern: () => this.getSelfTokens(),\n\t\t\tgetSelfTokens: () => this.getSelfTokens(),\n\t\t};\n\t}\n\n}\n\nexport default BlankNode;\n","import { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tSupportedNativeTypes,\n\tTriplesNodePattern,\n} from \"./..\";\nimport {\n\tCLOSE_MULTI_LIST,\n\tCLOSE_SINGLE_LIST,\n\tEMPTY_SEPARATOR,\n\tOPEN_MULTI_LIST,\n\tOPEN_SINGLE_LIST,\n} from \"./../tokens\";\nimport {\n\tLiteral,\n\tResource,\n\tVariable,\n} from \"./\";\nimport {\n\tNewLineSymbol,\n\tToken,\n} from \"./../../tokens\";\nimport { serialize } from \"./../../utils/ObjectPattern\";\nimport { TriplesPattern } from \"./TriplesPattern\";\n\nexport class Collection extends TriplesPattern<TriplesNodePattern> implements TriplesNodePattern {\n\n\tprotected elementTokens:Token[];\n\n\tconstructor( resolver:IRIResolver, values:(SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern)[] ) {\n\t\tsuper( resolver );\n\n\t\tlet tokens:Token[] = [];\n\t\tvalues.forEach( ( value, index ) => {\n\t\t\ttokens.push( ...serialize( value as SupportedNativeTypes ) );\n\t\t\tif( index < values.length - 1 ) tokens.push( EMPTY_SEPARATOR );\n\t\t} );\n\n\t\tlet isSingle:boolean = values.length <= 1 && ! tokens.find( token => token instanceof NewLineSymbol );\n\t\tthis.elementTokens = [\n\t\t\tisSingle ? OPEN_SINGLE_LIST : OPEN_MULTI_LIST,\n\t\t\t...tokens,\n\t\t\tisSingle ? CLOSE_SINGLE_LIST : CLOSE_MULTI_LIST,\n\t\t];\n\t}\n\n\tgetPattern():Token[] {\n\t\treturn this.getSelfTokens().concat( this.patternTokens );\n\t}\n\n\tprotected init():void {\n\t\tsuper.init();\n\t\tthis.interfaces.graphPattern = {\n\t\t\tgetPattern: () => this.getPattern(),\n\t\t\tgetSelfTokens: () => this.getSelfTokens(),\n\t\t};\n\t}\n\n}\n\nexport default Collection;\n","import { GraphPattern } from \"./..\";\nimport { Token } from \"./../../tokens\";\nimport { TriplesPattern } from \"./TriplesPattern\";\n\nexport abstract class TriplesSubject extends TriplesPattern<GraphPattern> {\n\n\tprotected init():void {\n\t\tsuper.init();\n\t\tthis.interfaces.graphPattern = {\n\t\t\tgetPattern: ():Token[] => {\n\t\t\t\treturn this.getSelfTokens().concat( this.patternTokens );\n\t\t\t},\n\t\t};\n\t}\n\n}\n\nexport default TriplesSubject;","import { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tCLOSE_QUOTE,\n\tLANG_SYMBOL,\n\tOPEN_QUOTE,\n} from \"./../tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\nimport { addType } from \"./../../utils/ObjectPattern\";\nimport { TriplesSubject } from \"./TriplesSubject\";\n\nexport abstract class Literal extends TriplesSubject {\n\n\tprotected value:string;\n\n\tconstructor( resolver:IRIResolver, value:string | number | boolean ) {\n\t\tsuper( resolver );\n\t\tthis.value = value + \"\";\n\t}\n\n}\n\nexport class RDFLiteral extends Literal {\n\n\tprotected elementTokens:Token[];\n\n\tconstructor( resolver:IRIResolver, value:string ) {\n\t\tsuper( resolver, value );\n\t\tthis.elementTokens = [ OPEN_QUOTE, new StringLiteral( value ), CLOSE_QUOTE ];\n\t}\n\n\tofType( type:string ):Literal {\n\t\tthis.elementTokens = addType( this.value, type );\n\t\treturn this;\n\t};\n\n\twithLanguage( language:string ):Literal {\n\t\tthis.elementTokens = [ OPEN_QUOTE, new StringLiteral( this.value ), CLOSE_QUOTE, LANG_SYMBOL, new StringLiteral( language ) ];\n\t\treturn this;\n\t};\n\n}\n\nexport class NumericLiteral extends Literal {\n\n\tprotected elementTokens:Token[];\n\n\tconstructor( resolver:IRIResolver, value:number ) {\n\t\tsuper( resolver, value );\n\n\t\tlet type:string = Number.isInteger( value ) ? \"integer\" : \"float\";\n\t\tthis.elementTokens = addType( this.value, type );\n\t}\n\n}\n\nexport class BooleanLiteral extends Literal {\n\n\tprotected elementTokens:Token[];\n\n\tconstructor( resolver:IRIResolver, value:boolean ) {\n\t\tsuper( resolver, value );\n\t\tthis.elementTokens = addType( this.value, \"boolean\" );\n\t}\n\n}\n","import { IRIResolver } from \"./../../iri/IRIResolver\";\nimport { Token } from \"./../../tokens\";\nimport { TriplesSubject } from \"./TriplesSubject\";\n\nexport class Resource extends TriplesSubject {\n\n\tprotected elementTokens:Token[];\n\n\tconstructor( resolver:IRIResolver, iri:string ) {\n\t\tsuper( resolver );\n\t\tthis.elementTokens = resolver.resolve( iri );\n\t}\n\n}\n\nexport default Resource;\n","import { IRIResolver } from \"./../../iri/IRIResolver\";\nimport { VAR_SYMBOL } from \"./../tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\nimport { TriplesSubject } from \"./TriplesSubject\";\n\nconst nameRegex:RegExp = /^((?:[0-9A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]))((?:[0-9A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]))*$/;\n\nexport class Variable extends TriplesSubject {\n\n\tprotected elementTokens:Token[];\n\n\tconstructor( resolver:IRIResolver, name:string ) {\n\t\tif( ! nameRegex.test( name ) ) throw new Error( \"Invalid variable name\" );\n\n\t\tsuper( resolver );\n\t\tthis.elementTokens = [ VAR_SYMBOL, new StringLiteral( name ) ];\n\t}\n\n}\n\nexport default Variable;\n","import { GraphPattern } from \"./../patterns\";\nimport {\n\tCLOSE_MULTI_BLOCK,\n\tCLOSE_SINGLE_BLOCK,\n\tGRAPH_PATTERN_SEPARATOR,\n\tOPEN_MULTI_BLOCK,\n\tOPEN_SINGLE_BLOCK,\n} from \"./../patterns/tokens\";\nimport {\n\tIdentifier,\n\tNewLineSymbol,\n\tToken,\n} from \"./../tokens\";\n\nexport function getBlockTokens( patterns:GraphPattern | GraphPattern[] ):Token[] {\n\tlet tokens:Token[] = this.getTokens( patterns );\n\n\tlet openToken:Token = OPEN_SINGLE_BLOCK;\n\tlet closeToken:Token = CLOSE_SINGLE_BLOCK;\n\tif( this.isMultiLine( tokens ) ) {\n\t\topenToken = OPEN_MULTI_BLOCK;\n\t\tcloseToken = CLOSE_MULTI_BLOCK;\n\t}\n\n\treturn [ openToken, ...tokens, closeToken ];\n}\n\nexport function getTokens( patterns:GraphPattern | GraphPattern[] ):Token[] {\n\tconst patternArray:GraphPattern[] = Array.isArray( patterns ) ? patterns : [ patterns ];\n\n\tlet triplesTokens:Token[] = [];\n\tlet lastToken:Token = void 0;\n\n\tpatternArray.forEach( ( graphPattern, index, array ) => {\n\t\tlet tokens:Token[] = graphPattern.getPattern();\n\n\t\tif( lastToken === GRAPH_PATTERN_SEPARATOR && ( tokens[ 0 ] instanceof Identifier || tokens[ 0 ] === OPEN_MULTI_BLOCK || tokens[ 0 ] === OPEN_SINGLE_BLOCK ) ) triplesTokens.pop();\n\n\t\ttriplesTokens.push( ...tokens );\n\n\t\tlastToken = tokens[ tokens.length - 1 ];\n\t\tif( index < array.length - 1 && lastToken !== CLOSE_MULTI_BLOCK && lastToken !== CLOSE_SINGLE_BLOCK ) {\n\t\t\ttriplesTokens.push( lastToken = GRAPH_PATTERN_SEPARATOR );\n\t\t}\n\t} );\n\n\treturn triplesTokens;\n}\n\nexport function isMultiLine( tokens:Token[] ):boolean {\n\treturn tokens.find( token => token instanceof NewLineSymbol && [ \".\", \";\", \",\", \"\" ].indexOf( token[ \"value\" ] ) !== - 1 ) !== void 0;\n}\n","import { Container } from \"./../clauses/Container\";\nimport {\n\tselectDecorator,\n\tsubFinishDecorator,\n} from \"./../clauses/decorators\";\nimport {\n\tSubSelectClause,\n\tSubWhereClause,\n} from \"./../clauses/interfaces\";\nimport { IRIResolver } from \"./../iri/IRIResolver\";\nimport {\n\tGraphPattern,\n\tMultipleValuesPattern,\n\tNotTriplesPatternBuilder,\n\tSingleValuesPattern,\n\tSupportedNativeTypes,\n\tTriplesNodePattern,\n\tTriplesPatternBuilder,\n} from \"./interfaces\";\nimport { NotTriplesPattern } from \"./notTriples/NotTriplesPattern\";\nimport { ValuesPattern } from \"./notTriples/ValuesPattern\";\nimport {\n\tAS,\n\tBIND,\n\tCLOSE_SINGLE_LIST,\n\tFILTER,\n\tGRAPH,\n\tMINUS,\n\tOPEN_SINGLE_LIST,\n\tOPTIONAL,\n\tSERVICE,\n\tSILENT,\n\tUNION,\n} from \"./tokens\";\nimport { BlankNode } from \"./triples/BlankNode\";\nimport { Collection } from \"./triples/Collection\";\nimport {\n\tBooleanLiteral,\n\tLiteral,\n\tNumericLiteral,\n\tRDFLiteral,\n} from \"./triples/Literals\";\nimport { Resource } from \"./triples/Resource\";\nimport { Variable } from \"./triples/Variable\";\nimport { StringLiteral } from \"./../tokens/StringLiteral\";\nimport { Token } from \"./../tokens/Token\";\nimport { getBlockTokens } from \"./../utils/Patterns\";\n\nexport type Undefined = \"UNDEF\";\n\nexport class PatternBuilder implements TriplesPatternBuilder,\n                                       NotTriplesPatternBuilder,\n                                       SubSelectClause {\n\n\tpublic static get undefined():Undefined { return \"UNDEF\"; };\n\n\tpublic get undefined():Undefined { return PatternBuilder.undefined; };\n\n\tprivate iriResolver:IRIResolver;\n\n\tconstructor( iriResolver:IRIResolver ) {\n\t\tthis.iriResolver = iriResolver;\n\t\tselectDecorator( new Container( subFinishDecorator ), this );\n\t}\n\n\tresource( iri:string ):Resource {\n\t\treturn new Resource( this.iriResolver, iri );\n\t}\n\n\tvar( name:string ):Variable {\n\t\treturn new Variable( this.iriResolver, name );\n\t}\n\n\tliteral( value:string ):RDFLiteral;\n\tliteral( value:number ):NumericLiteral;\n\tliteral( value:boolean ):BooleanLiteral;\n\tliteral( value ):any {\n\t\tif( typeof value === \"string\" || value instanceof String )\n\t\t\treturn new RDFLiteral( this.iriResolver, value as string );\n\n\t\tif( typeof value === \"number\" || value instanceof Number )\n\t\t\treturn new NumericLiteral( this.iriResolver, value as number );\n\n\t\tif( typeof value === \"boolean\" || value instanceof Boolean )\n\t\t\treturn new BooleanLiteral( this.iriResolver, value as boolean );\n\n\t\tthrow new Error( \"No valid value of a literal was provided.\" );\n\t}\n\n\tcollection( ...values:(SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern)[] ):Collection {\n\t\tif( values.length === 0 ) throw Error( \"The collection needs at least one value.\" );\n\t\treturn new Collection( this.iriResolver, values );\n\t}\n\n\tblankNode():BlankNode {\n\t\treturn new BlankNode( this.iriResolver );\n\t}\n\n\tgraph( iri:string, pattern:GraphPattern ):NotTriplesPattern;\n\tgraph( iri:string, patterns:GraphPattern[] ):NotTriplesPattern;\n\tgraph( variable:Variable, pattern:GraphPattern ):NotTriplesPattern;\n\tgraph( variable:Variable, patterns:GraphPattern[] ):NotTriplesPattern;\n\tgraph( iriOrVariable, patterns ):NotTriplesPattern {\n\t\tlet graph:Token[] = ( typeof iriOrVariable === \"string\" )\n\t\t\t? this.iriResolver.resolve( iriOrVariable )\n\t\t\t: iriOrVariable.getSelfTokens();\n\n\t\tlet patternTokens:Token[] = getBlockTokens( patterns );\n\t\treturn new NotTriplesPattern( [ GRAPH, ...graph, ...patternTokens ] );\n\t}\n\n\toptional( pattern:GraphPattern ):NotTriplesPattern;\n\toptional( patterns:GraphPattern[] ):NotTriplesPattern;\n\toptional( patterns ):NotTriplesPattern {\n\t\tlet patternTokens:Token[] = getBlockTokens( patterns );\n\n\t\treturn new NotTriplesPattern( [ OPTIONAL, ...patternTokens ] );\n\t}\n\n\tunion( pattern1:GraphPattern, pattern2:GraphPattern ):NotTriplesPattern;\n\tunion( pattern1:GraphPattern, patterns2:GraphPattern[] ):NotTriplesPattern;\n\tunion( patterns1:GraphPattern[], pattern2:GraphPattern ):NotTriplesPattern;\n\tunion( patterns1:GraphPattern[], patterns2:GraphPattern[] ):NotTriplesPattern;\n\tunion( patterns1, patterns2 ):NotTriplesPattern {\n\t\tlet leftPatternTokens:Token[] = getBlockTokens( patterns1 );\n\t\tlet rightPatternTokens:Token[] = getBlockTokens( patterns2 );\n\n\t\treturn new NotTriplesPattern( [ ...leftPatternTokens, UNION, ...rightPatternTokens ] );\n\t}\n\n\tminus( pattern:GraphPattern ):NotTriplesPattern;\n\tminus( firstPattern:GraphPattern, ...restPatterns:GraphPattern[] ):NotTriplesPattern;\n\tminus( ...patterns:GraphPattern[] ):NotTriplesPattern {\n\t\tlet patternTokens:Token[] = getBlockTokens( patterns );\n\n\t\treturn new NotTriplesPattern( [ MINUS, ...patternTokens ] );\n\t}\n\n\tvalues( variable:Variable ):SingleValuesPattern;\n\tvalues( ...variables:Variable[] ):MultipleValuesPattern;\n\tvalues( ...variables:Variable[] ):SingleValuesPattern | MultipleValuesPattern {\n\t\treturn new ValuesPattern( this.iriResolver, variables );\n\t}\n\n\tservice( resource:string | Resource | Variable, patterns:GraphPattern | GraphPattern[] ):NotTriplesPattern {\n\t\tconst serviceTokens:Token[] = typeof resource === \"string\" ?\n\t\t\tthis.iriResolver.resolve( resource ) :\n\t\t\tresource.getSelfTokens();\n\n\t\tconst patternTokens:Token[] = getBlockTokens( patterns );\n\t\treturn new NotTriplesPattern( [ SERVICE, ...serviceTokens, ...patternTokens ] );\n\t}\n\n\tserviceSilent( resource:string | Resource | Variable, patterns:GraphPattern | GraphPattern[] ):NotTriplesPattern {\n\t\tconst serviceTokens:Token[] = typeof resource === \"string\" ?\n\t\t\tthis.iriResolver.resolve( resource ) :\n\t\t\tresource.getSelfTokens();\n\n\t\tconst patternTokens:Token[] = getBlockTokens( patterns );\n\t\treturn new NotTriplesPattern( [ SERVICE, SILENT, ...serviceTokens, ...patternTokens ] );\n\t}\n\n\tbind( rawExpression:string, variable:string | Variable ):NotTriplesPattern {\n\t\tvariable = typeof variable === \"string\" ? this.var( variable ) : variable;\n\t\tconst patternTokens:Token[] = [ BIND, OPEN_SINGLE_LIST, new StringLiteral( rawExpression ), AS, ...variable.getSelfTokens(), CLOSE_SINGLE_LIST ];\n\t\treturn new NotTriplesPattern( patternTokens );\n\t}\n\n\tfilter( rawConstraint:string ):NotTriplesPattern {\n\t\treturn new NotTriplesPattern( [ FILTER, new StringLiteral( rawConstraint ) ] );\n\t}\n\n\t// SubSelect Clauses methods, decorated in constructor\n\tselect:( ...variables:string[] ) => SubWhereClause;\n\tselectDistinct:( ...variables:string[] ) => SubWhereClause;\n\tselectReduced:( ...variables:string[] ) => SubWhereClause;\n\tselectAll:() => SubWhereClause;\n\tselectAllDistinct:() => SubWhereClause;\n\tselectAllReduced:() => SubWhereClause;\n\n}\n\nexport default PatternBuilder;\n","import { ValuesClause, } from \"./..\";\nimport { Container } from \"./../Container\";\nimport {\n\tFinishClause,\n\tSubFinishClause,\n} from \"./../interfaces\";\nimport { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tPatternBuilder,\n\tSupportedNativeTypes,\n\tUndefined,\n} from \"./../../patterns\";\nimport {\n\tCLOSE_MULTI_BLOCK,\n\tCLOSE_SINGLE_BLOCK,\n\tCLOSE_SINGLE_LIST,\n\tOPEN_MULTI_BLOCK,\n\tOPEN_SINGLE_BLOCK,\n\tOPEN_SINGLE_LIST,\n\tVALUES,\n} from \"./../../patterns/tokens\";\nimport {\n\tLiteral,\n\tResource,\n\tVariable,\n} from \"./../../patterns/triples\";\nimport { Token } from \"./../../tokens\";\nimport { serialize } from \"./../../utils/ObjectPattern\";\n\ntype PossibleTypes = SupportedNativeTypes | Resource | Literal | Undefined;\n\n/**\n * Set the values of a variable to be combined into the results query.\n *\n * @param variable Variable to add values.\n * @param values The values to be combined.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variable:string, values:SupportedNativeTypes | SupportedNativeTypes[] ):T;\n/**\n * Set the values of a variable to be combined into the results query.\n *\n * The values are constructed with a function that receives a\n * pattern builder.\n *\n * @param variable Variable to add values.\n * @param valuesBuilder Functions that returns the values to be added.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variable:string, valuesBuilder:( builder:PatternBuilder ) => ( SupportedNativeTypes | Resource | Literal | Undefined ) | ( SupportedNativeTypes | Resource | Literal | Undefined )[] ):T;\n/**\n * Set the values of multiple variables to be combined into the results\n * query.\n *\n * @param variables Variables to add values.\n * @param values The values to be combined.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variables:string[], values:SupportedNativeTypes[] | SupportedNativeTypes[][] ):T;\n/**\n * Set the values of multiple variables to be combined into the results\n * query.\n *\n * The values are constructed with a function that receives a\n * pattern builder.\n *\n * @param variables Variables to add values.\n * @param valuesBuilder Functions that returns the values to be added.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variables:string[], valuesBuilder:( builder:PatternBuilder ) => ( SupportedNativeTypes | Resource | Literal | Undefined )[] | ( SupportedNativeTypes | Resource | Literal | Undefined )[][] ):T;\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variableOrVariables:string | string[], valuesOrBuilder ):T {\n\tconst isSingle:boolean = ! Array.isArray( variableOrVariables );\n\tconst variables:Variable[] = ( isSingle ?\n\t\t[ variableOrVariables as string ] : variableOrVariables as string[] )\n\t\t.map( name => new Variable( null, name ) );\n\tconst tokens:Token[] = [ VALUES ];\n\n\tif( isSingle ) {\n\t\ttokens.push( ...variables[ 0 ].getSelfTokens(), OPEN_SINGLE_BLOCK );\n\t} else {\n\t\ttokens.push( OPEN_SINGLE_LIST );\n\t\tvariables.forEach( variable => tokens.push( ...variable.getSelfTokens() ) );\n\t\ttokens.push( CLOSE_SINGLE_LIST, OPEN_MULTI_BLOCK );\n\t}\n\n\tlet iriResolver:IRIResolver = void 0;\n\tconst rawValues:PossibleTypes | PossibleTypes[] | PossibleTypes[][] =\n\t\ttypeof valuesOrBuilder === \"function\" ?\n\t\t\tvaluesOrBuilder( new PatternBuilder( iriResolver = new IRIResolver( this._iriResolver ) ) ) :\n\t\t\tvaluesOrBuilder;\n\n\tconst values:PossibleTypes[][] = isSingle ?\n\t\tArray.isArray( rawValues ) ? (rawValues as PossibleTypes[]).map( value => [ value ] ) : [ [ rawValues ] ] :\n\t\tArray.isArray( rawValues[ 0 ] ) ? rawValues as PossibleTypes[][] : [ rawValues ] as PossibleTypes[][];\n\n\tvalues.forEach( ( valuesRow ) => {\n\t\tif( isSingle ) {\n\t\t\ttokens.push( ...serialize( valuesRow[ 0 ] ) );\n\t\t} else {\n\t\t\ttokens.push( OPEN_SINGLE_LIST );\n\t\t\tvaluesRow.forEach( value => tokens.push( ...serialize( value ) ) );\n\t\t\ttokens.push( CLOSE_SINGLE_LIST );\n\t\t}\n\t} );\n\n\ttokens.push( isSingle ? CLOSE_SINGLE_BLOCK : CLOSE_MULTI_BLOCK );\n\n\tconst container:Container<T> = new Container<T>( this, tokens, iriResolver );\n\treturn this._finishDecorator( container, {} );\n}\n\n/**\n * Decorator that binds the {@link ValuesClause} methods to a\n * container and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function valuesDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & ValuesClause<T> {\n\treturn Object.assign( object, {\n\t\tvalues: values.bind( container ),\n\t} );\n}","import { ValuesClause } from \"./..\";\nimport { Container } from \"./../Container\";\nimport { valuesDecorator } from \"./values\";\nimport {\n\tFinishClause,\n\tLimitClause,\n\tLimitOffsetClause,\n\tOffsetClause,\n\tSubFinishClause,\n} from \"./../interfaces\";\nimport {\n\tLIMIT,\n\tOFFSET,\n} from \"./../../patterns/tokens\";\nimport {\n\tNumberLiteral,\n\tToken,\n} from \"./../../tokens\";\n\n\n/**\n * Enum to specify which method is creating the LimitOffsetContainer.\n */\nexport enum CurrentMethod {\n\tLIMIT,\n\tOFFSET,\n}\n\n/**\n * Container to be used by the limit and offset methods to keep track of which method is called first.\n */\nexport class LimitOffsetContainer<T extends FinishClause | SubFinishClause = FinishClause> extends Container<T> {\n\n\t/**\n\t * Property indicating that limit method has been used first.\n\t */\n\treadonly _limitUsed:boolean;\n\n\t/**\n\t * Property indicating that offset method has been used first.\n\t */\n\treadonly _offsetUsed:boolean;\n\n\t/**\n\t * Creates the container specifying the method that it's creating it.\n\t *\n\t * @param previousContainer The previous container data to be copied.\n\t * @param newTokens The new tokens to be added.\n\t * @param currentMethod The method that is creating the current container.\n\t */\n\tconstructor( previousContainer:Container<any>, newTokens:Token[], currentMethod:CurrentMethod ) {\n\t\tsuper( previousContainer, newTokens );\n\t\tthis._offsetUsed = currentMethod === CurrentMethod.OFFSET;\n\t\tthis._limitUsed = currentMethod === CurrentMethod.LIMIT;\n\n\t\tObject.freeze( this );\n\t}\n}\n\n/**\n * Set the limit of results the query should return.\n *\n * @param limit The number to be applied as limit.\n * @returns A OffsetClause or the FinishClause/SubFinishClause depending\n * if the offset method has been called before or not.\n */\nexport function limit<T extends FinishClause | SubFinishClause>( this:LimitOffsetContainer<T>, limit:number ):( T & ValuesClause<T> ) | ( OffsetClause<T & ValuesClause<T>> & ValuesClause<T> & T ) {\n\tconst tokens:Token[] = [ LIMIT, new NumberLiteral( limit ) ];\n\n\t// Return T & ValuesClause<T>\n\tif( this._offsetUsed ) {\n\t\tconst container:Container<T> = new Container<T>( this, tokens );\n\t\treturn this._finishDecorator( container, valuesDecorator( container, {} ) );\n\t}\n\n\t// Return OffsetClause<T & ValuesClause<T>> & ValuesClause<T> & T\n\tconst container:LimitOffsetContainer<T> = new LimitOffsetContainer<T>( this, tokens, CurrentMethod.LIMIT );\n\treturn this._finishDecorator( container, offsetDecorator( container, {} ) );\n}\n\n/**\n * Set the offset of results the query should return from.\n *\n * @param offset The number to be applied as offset.\n * @returns A LimitClause or the FinishClause/SubFinishClause depending\n * if the limit method has been called before or not.\n */\nexport function offset<T extends FinishClause | SubFinishClause>( this:LimitOffsetContainer<T>, offset:number ):( T & ValuesClause<T> ) | ( LimitClause<T & ValuesClause<T>> & ValuesClause<T> & T ) {\n\tconst tokens:Token[] = [ OFFSET, new NumberLiteral( offset ) ];\n\n\t// Return T & ValuesClause<T>\n\tif( this._limitUsed ) {\n\t\tconst container:Container<T> = new Container<T>( this, tokens );\n\t\treturn this._finishDecorator( container, valuesDecorator( container, {} ) );\n\t}\n\n\t// Return LimitClause<T & ValuesClause<T>> & ValuesClause<T> & T\n\tconst container:LimitOffsetContainer<T> = new LimitOffsetContainer<T>( this, tokens, CurrentMethod.OFFSET );\n\treturn this._finishDecorator( container, limitDecorator( container, {} ) );\n}\n\n\n/**\n * Decorator that binds the LimitClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function limitDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & LimitClause<T & ValuesClause<T>> & ValuesClause<T> {\n\treturn Object.assign( valuesDecorator( container, object ), {\n\t\tlimit: limit.bind( container ),\n\t} );\n}\n\n/**\n * Decorator that binds the OffsetClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function offsetDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & OffsetClause<T & ValuesClause<T>> & ValuesClause<T> {\n\treturn Object.assign( valuesDecorator( container, object ), {\n\t\toffset: offset.bind( container ),\n\t} );\n}\n\n/**\n * Decorator that binds the LimitOffsetClause methods to a container and adds\n * them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function limitOffsetDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & LimitOffsetClause<T> {\n\treturn Object.assign( valuesDecorator( container, object ), {\n\t\tlimit: limit.bind( container ),\n\t\toffset: offset.bind( container ),\n\t} );\n}\n","import { Container } from \"./../Container\";\nimport { limitOffsetDecorator } from \"./\";\nimport {\n\tFinishClause,\n\tLimitOffsetClause,\n\tOrderClause,\n\tSubFinishClause,\n} from \"./../interfaces\";\nimport {\n\tBY,\n\tORDER,\n} from \"./../../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\n\n/**\n * Set a condition to be used as the order of the sequence of solutions the\n * query will retrieve.\n *\n * Notice: The current version of SPARQLER does not evaluate the condition\n * for possible errors.\n *\n * @param rawCondition Raw condition to be applied for the solutions order.\n * @returns Object with the methods to keep constructing the query.\n */\nexport function orderBy<T extends FinishClause | SubFinishClause>( this:Container<T>, rawCondition:string ):LimitOffsetClause<T> & T {\n\tconst tokens:Token[] = [ ORDER, BY, new StringLiteral( rawCondition ) ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens );\n\treturn this._finishDecorator<LimitOffsetClause<T>>( container, limitOffsetDecorator<T, {}>( container, {} ) );\n}\n\n/**\n * Decorator that binds the OrderClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function orderDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & OrderClause<T> {\n\treturn Object.assign( limitOffsetDecorator<T, W>( container, object ), {\n\t\t\torderBy: orderBy.bind( container ),\n\t\t},\n\t);\n}\n","import { Container } from \"./../Container\";\nimport { selectDecorator } from \"./\";\nimport {\n\tFinishClause,\n\tQueryClause,\n} from \"./../interfaces\";\nimport { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tBASE,\n\tCLOSE_IRI,\n\tOPEN_IRI,\n\tPREFIX,\n\tPREFIX_SYMBOL,\n} from \"./../../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\n\n/**\n * Add a base IRI the query uses to resolve any relative IRIs.\n *\n * If a default vocabulary is set with the {@link QueryClause.vocab}\n * method, the base is ignored for relative predicates.\n *\n * @param iri IRI to be used as the query BASE.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction base<T extends FinishClause>( this:Container<T>, iri:string ):QueryClause<T> {\n\tconst tokens:Token[] = [ BASE, OPEN_IRI, new StringLiteral( iri ), CLOSE_IRI ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens );\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\n/**\n * Add a default vocabulary to be used to resolve relative IRIs when\n * used as a predicate in a triple pattern.\n *\n * @param iri IRI to append to prepend to any relative predicate.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction vocab<T extends FinishClause>( this:Container<T>, iri:string ):QueryClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this._iriResolver, iri );\n\n\tconst container:Container<T> = new Container<T>( this, null, iriResolver );\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\n/**\n * Add a prefix to the query.\n *\n * If the prefix is not used in any part of the query it is not added\n * in the compact query string.\n *\n * @param name Name the prefix will be identified for.\n * @param iri The IRI of the current PREFIX.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction prefix<T extends FinishClause>( this:Container<T>, name:string, iri:string ):QueryClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this._iriResolver );\n\n\tconst previousIndex = iriResolver._prefixes.has( name ) ?\n\t\tthis._tokens.findIndex( token => token instanceof StringLiteral && token[ \"value\" ] === name ) :\n\t\t- 1;\n\n\tiriResolver._prefixes.set( name, false );\n\n\tconst tokens:Token[] = [ PREFIX, new StringLiteral( name ), PREFIX_SYMBOL, OPEN_IRI, new StringLiteral( iri ), CLOSE_IRI ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens, iriResolver );\n\n\tif( previousIndex !== - 1 ) {\n\t\tcontainer._tokens.splice( previousIndex - 1, 6 );\n\t}\n\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\n/**\n * Decorator that bind {@link QueryClause} methods to container and\n * adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function queryDecorator<T extends FinishClause, W extends object>( container:Container<T>, object:W ):W & QueryClause<T> {\n\treturn Object.assign( selectDecorator( container, object ), {\n\t\tbase: base.bind( container ),\n\t\tvocab: vocab.bind( container ),\n\t\tprefix: prefix.bind( container ),\n\t} );\n}\n","import { Container, } from \"./../Container\";\nimport {\n\tfromDecorator,\n\tsubFinishDecorator,\n\tsubWhereDecorator,\n} from \"./\";\nimport {\n\tFinishClause,\n\tFromClause,\n\tSelectClause,\n\tSubFinishClause,\n\tSubSelectClause,\n\tSubWhereClause,\n} from \"./../interfaces\";\nimport {\n\tALL,\n\tDISTINCT,\n\tREDUCED,\n\tSELECT,\n\tVAR_SYMBOL,\n} from \"./../../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\n\n/**\n * Internal function that actually creates the tokens of the\n * SelectClause and SubSelectClause methods.\n *\n * @param self The container that is bound to the FromClause methods.\n * @param tokens Initial tokens depending which method the function\n * is called from.\n * @param variables Optional variables to be converted in tokens.\n * @returns Object with the methods to keep constructing the query.\n * Depending of the self container it will return a `FromClause`, as\n * `SelectClause` indicates; or a `WhereClause<SubFinishClause>`, as\n * `SubSelectClause` also indicates.\n * @private\n */\nfunction _select<T extends FinishClause>( self:Container<T | SubFinishClause>, tokens:Token[], variables?:string[] ):SubWhereClause | FromClause<T> {\n\tif( variables && variables.length === 0 ) throw new Error( \"Need to provide al least one variable.\" );\n\n\tif( variables ) variables.forEach( variable => tokens.push( VAR_SYMBOL, new StringLiteral( variable ) ) );\n\n\tconst container:Container<T | SubFinishClause> = new Container<T | SubFinishClause>( self, tokens );\n\n\tif( self._finishDecorator === subFinishDecorator )\n\t\treturn subWhereDecorator<SubFinishClause, {}>( container as Container<SubFinishClause>, {} );\n\treturn fromDecorator<T, {}>( container as Container<T>, {} );\n}\n\n/**\n * Set a list of variables to be retrieved by the query.\n *\n * @param variables The list of variables.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction select<T extends FinishClause>( this:Container<T>, ...variables:string[] ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT ], variables ) as FromClause<T>;\n}\n\n/**\n * Set a list of variables to be retrieved by the query ensuring no\n * repetitions in the set of solutions.\n *\n * @param variables The list of variables.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectDistinct<T extends FinishClause>( this:Container<T>, ...variables:string[] ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, DISTINCT ], variables ) as FromClause<T>;\n}\n\n/**\n * Set a list of variables to be retrieved by the query permitting\n * eliminations of non-distinct solutions, but not ensuring a set of\n * unique ones.\n *\n * @param variables The list of variables.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectReduced<T extends FinishClause>( this:Container<T>, ...variables:string[] ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, REDUCED ], variables ) as FromClause<T>;\n}\n\n/**\n * Set that the query must return all the solutions for the variables\n * used in the where pattern matching.\n *\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectAll<T extends FinishClause>( this:Container<T> ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, ALL ] ) as FromClause<T>;\n}\n\n/**\n * Set that the query must return all the solutions for the variables\n * used in the where pattern matching, ensuring there is not\n * duplicated solutions.\n *\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectAllDistinct<T extends FinishClause>( this:Container<T> ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, DISTINCT, ALL ] ) as FromClause<T>;\n}\n\n/**\n * Set that the query must return all the solutions for the variables\n * used in the where pattern matching, permitting eliminations of\n * non-distinct solutions, but not ensuring a set of unique ones.\n *\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectAllReduced<T extends FinishClause>( this:Container<T> ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, REDUCED, ALL ] ) as FromClause<T>;\n}\n\n/**\n * Decorator that binds the {@link SelectClause} methods to a\n * container and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function selectDecorator<T extends FinishClause, W extends object>( container:Container<T>, object:W ):W & SelectClause<T>;\n/**\n * Decorator that binds the {@link SubSelectClause} methods to a subSelect\n * container and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function selectDecorator<W extends object>( container:Container<SubFinishClause>, object:W ):W & SubSelectClause;\nexport function selectDecorator<T extends FinishClause, W extends object>( container:Container<T | SubFinishClause>, object:W ):W & (SelectClause<T> | SubSelectClause) {\n\treturn Object.assign( object, {\n\t\tselect: select.bind( container ),\n\t\tselectDistinct: selectDistinct.bind( container ),\n\t\tselectReduced: selectReduced.bind( container ),\n\t\tselectAll: selectAll.bind( container ),\n\t\tselectAllDistinct: selectAllDistinct.bind( container ),\n\t\tselectAllReduced: selectAllReduced.bind( container ),\n\t} );\n}\n","import { SubFinishClause } from \"./..\";\nimport { Container } from \"./../Container\";\nimport { groupDecorator } from \"./\";\nimport {\n\tFinishClause,\n\tGroupClause,\n\tSubWhereClause,\n\tWhereClause,\n} from \"./../interfaces\";\nimport { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tGraphPattern,\n\tPatternBuilder,\n} from \"./../../patterns\";\nimport { WHERE } from \"./../../patterns/tokens\";\nimport { Token } from \"./../../tokens\";\nimport { getBlockTokens } from \"./../../utils/Patterns\";\n\n/**\n * Sets the graph patterns the sub-query should match to retrieve the\n * sub-solutions data.\n *\n * @param patterns Patterns the sub-query should match.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction subWhere( this:Container<SubFinishClause>, patterns:GraphPattern | GraphPattern[] ):GroupClause<SubFinishClause> & SubFinishClause {\n\tconst tokens:Token[] = [ WHERE, ...getBlockTokens( patterns ) ];\n\n\tconst container:Container<SubFinishClause> = new Container<SubFinishClause>( this, tokens );\n\treturn this._finishDecorator( container, groupDecorator( container, {} ) );\n}\n\n/**\n * Specifies the graph patterns the query should match to retrieve\n * the solutions results.\n *\n * This pattern are created by a pattern constructor function that\n * receives a {@link PatternBuilder} which is a class that exposes\n * the possible elements and configurations the patterns chan have.\n *\n * @param patternFunction Function that retrieves a pattern or an\n * array of patterns to match.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction where<T extends FinishClause>( this:Container<T>, patternFunction:( builder:PatternBuilder ) => GraphPattern | GraphPattern[ ] ):GroupClause<T> & T {\n\tconst iriResolver:IRIResolver = new IRIResolver( this._iriResolver );\n\tconst patterns:GraphPattern | GraphPattern[] = patternFunction( new PatternBuilder( iriResolver ) );\n\n\tconst tokens:Token[] = [ WHERE, ...getBlockTokens( patterns ) ];\n\tconst container:Container<T> = new Container<T>( this, tokens, iriResolver );\n\n\treturn this._finishDecorator( container, groupDecorator( container, {} ) );\n}\n\n/**\n * Decorator that binds the {@link WhereClause} methods to a container\n * and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function whereDecorator<T extends FinishClause, W extends object>( container:Container<T>, object:W ):W & WhereClause<T> {\n\treturn Object.assign( object, {\n\t\twhere: where.bind( container ),\n\t} );\n}\n\n/**\n * Decorator that binds the {@link SubWhereClause} clause pattern\n * methods to a container and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function subWhereDecorator<T extends SubFinishClause, W extends object>( container:Container<T>, object:W ):W & SubWhereClause {\n\treturn Object.assign( object, {\n\t\twhere: subWhere.bind( container ),\n\t} );\n}\n","import {\n\tFinishClause,\n\tQueryClause,\n} from \"./clauses/interfaces\";\nimport { Container }  from \"./clauses/Container\";\nimport { queryDecorator } from \"./clauses/decorators\";\n\nexport interface FinishDecorator<T> extends Function {\n\t<W extends object>( container:Container<T & FinishClause>, object:W ):T & W & FinishClause;\n}\n\n// Comment\nexport interface SPARQLER<T extends FinishClause = FinishClause> extends QueryClause<T> {}\nexport class SPARQLER<T extends FinishClause = FinishClause> {\n\n\tconstructor( finishDecorator?:FinishDecorator<T> ) {\n\t\tconst container:Container<T> = new Container<T>( finishDecorator );\n\t\treturn queryDecorator<T, {}>( container, this );\n\t}\n\n}\n\nexport default SPARQLER;\n"],"names":["tslib_1.__extends","EMPTY_SEPARATOR","finishDecorator","originalFinishDecorator","fromDecorator","whereDecorator","havingDecorator","orderDecorator","ValuesPattern","selectDecorator","orderBy","queryDecorator","subWhereDecorator","groupDecorator"],"mappings":"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"}