{"version":3,"sources":["clauses/Container.ts"],"names":[],"mappings":";;AAAA,6DAAgG;AAEhG,wDAAuD;AAqBvD;IAyCC,mBAAa,kCAAuE,EAAE,SAAkB,EAAE,WAAwB;;QACjI,IAAM,SAAS,GAAkB,kCAAkC,YAAY,QAAQ;cACpF,KAAK,CAAC;cACN,kCAAkC,CAAC;QAEtC,IAAM,eAAe,GAAsB,kCAAkC,YAAY,QAAQ;cAC9F,kCAAkC;cAClC,wBAA6C,CAAC;QAEjD,IAAI,CAAC,YAAY,GAAG,WAAW;cAC5B,WAAW,GAAG,SAAS;cACtB,IAAI,yBAAW,CAAE,SAAS,CAAC,YAAY,CAAE;cACzC,IAAI,yBAAW,EAAE,CAAC;QAEtB,IAAM,cAAc,GAAW,SAAS,GAAG,SAAS,CAAC,OAAO,GAAG,EAAE,CAAC;QAClE,EAAE,CAAA,CAAE,CAAE,SAAU,CAAC;YAAC,SAAS,GAAG,EAAE,CAAC;QACjC,IAAI,CAAC,OAAO,GAAG,cAAc,CAAC,MAAM,CAAE,SAAS,CAAE,CAAC;QAElD,IAAI,CAAC,gBAAgB,GAAG,SAAS;cAC9B,SAAS,CAAC,gBAAgB;cAC1B,eAAe,CAAC;QAEnB,EAAE,CAAA,CAAE,eAAe,SAAU,CAAC;YAAC,MAAM,CAAC,MAAM,CAAE,IAAI,CAAE,CAAC;IACtD,CAAC;IACF,gBAAC;AAAD,CAjEA,AAiEC,IAAA;AAjEY,8BAAS;AAmEtB,kBAAe,SAAS,CAAC","file":"Container.js","sourcesContent":["import { finishDecorator as originalFinishDecorator } from \"sparqler/clauses/decorators/finish\";\nimport { FinishClause } from \"sparqler/clauses/interfaces\";\nimport { IRIResolver } from \"sparqler/iri/IRIResolver\";\nimport { GraphPattern } from \"sparqler/patterns/interfaces\";\nimport { Token } from \"sparqler/tokens/Token\";\n\n\n/**\n * Interface of possible functions to be be used as finish decorators.\n *\n * Should accept a container with the query data as first parameter and\n * as second the object to decorate.\n */\nexport interface FinishDecorator<T extends FinishClause | GraphPattern> extends Function {\n\t<W extends object>( container:Container<T>, object:W ):T & W;\n}\n\n/**\n * Immutable class that contains the hidden data of the query builder.\n *\n * Every step of the builder uses a different instance of the container\n * to make the query builder immutable-like.\n */\nexport class Container<T extends FinishClause | GraphPattern = FinishClause> {\n\n\t/**\n\t * Array containing the query tokens.\n\t */\n\treadonly _tokens:Token[];\n\n\t/**\n\t * Decorator that extends the finish clause.\n\t */\n\treadonly _finishDecorator:FinishDecorator<T>;\n\n\t/**\n\t * Implementation of the IRI Resolver interface.\n\t */\n\treadonly _iriResolver:IRIResolver;\n\n\t/**\n\t * Creates an empty container with the default finish decorator: {@link finishDecorator}.\n\t */\n\tconstructor();\n\t/**\n\t * Creates an empty container with a custom finish decorator.\n\t *\n\t * @param finishDecorator The finish decorated to be used in the container.\n\t */\n\tconstructor( finishDecorator:FinishDecorator<T> );\n\t/**\n\t * Creates a container copping the data of the previous container provided.\n\t *\n\t * If `newTokens` parameter is provided its data will be appended to the tokens\n\t * of the previous container tokens.\n\t *\n\t * If the `iriResolver` is provided, it will be used in the new container instead\n\t * of the IRIResolver of the previous container.\n\t *\n\t * @param previousContainer Container to be copied.\n\t * @param newTokens Tokens to append to the to the previousContainer tokens copied.\n\t * @param iriResolver IRIResolver to be used.\n\t */\n\tconstructor( previousContainer:Container<any>, newTokens?:Token[], iriResolver?:IRIResolver );\n\tconstructor( previousContainerOrFinishDecorator?:Container<any> | FinishDecorator<T>, newTokens?:Token[], iriResolver?:IRIResolver ) {\n\t\tconst container:Container<any> = previousContainerOrFinishDecorator instanceof Function\n\t\t\t? void 0\n\t\t\t: previousContainerOrFinishDecorator;\n\n\t\tconst finishDecorator:FinishDecorator<T> = previousContainerOrFinishDecorator instanceof Function\n\t\t\t? previousContainerOrFinishDecorator\n\t\t\t: originalFinishDecorator as FinishDecorator<T>;\n\n\t\tthis._iriResolver = iriResolver\n\t\t\t? iriResolver : container\n\t\t\t\t? new IRIResolver( container._iriResolver )\n\t\t\t\t: new IRIResolver();\n\n\t\tconst previousTokens:Token[] = container ? container._tokens : [];\n\t\tif( ! newTokens ) newTokens = [];\n\t\tthis._tokens = previousTokens.concat( newTokens );\n\n\t\tthis._finishDecorator = container\n\t\t\t? container._finishDecorator\n\t\t\t: finishDecorator;\n\n\t\tif( new.target === Container ) Object.freeze( this );\n\t}\n}\n\nexport default Container;\n"]}