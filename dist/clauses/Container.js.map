{"version":3,"sources":["clauses/Container.ts"],"names":[],"mappings":";;AAAA,6DAAgG;AAChG,mEAA2E;AAK3E,wDAAuD;AAoBvD;IA0CC,mBAAa,mBAAwD,EAAE,SAAkB,EAAE,WAAwB;;QAClH,IAAM,SAAS,GAAkB,mBAAmB,YAAY,QAAQ;YACvE,KAAK,CAAC,GAAG,mBAAmB,CAAC;QAE9B,IAAM,eAAe,GAAsB,mBAAmB,YAAY,QAAQ;cAC/E,mBAAmB,GAAG,wBAA6C,CAAC;QAEvE,IAAI,CAAC,YAAY,GAAG,eAAe,KAAK,8BAAkB,GAAG,CAAE,WAAW,GAAG,SAAS,GAAG,SAAS,CAAC,YAAY;YAC9G,IAAI,yBAAW,CAAE,SAAS,CAAC,YAAY,CAAE,GAAG,KAAK,CAAC,GAAG,IAAI,yBAAW,EAAE,GAAG,WAAW,GAAG,KAAK,CAAC,CAAC;QAE/F,IAAM,cAAc,GAAW,SAAS,GAAG,SAAS,CAAC,OAAO,GAAG,EAAE,CAAC;QAClE,EAAE,CAAA,CAAE,CAAE,SAAU,CAAC;YAAC,SAAS,GAAG,EAAE,CAAC;QACjC,IAAI,CAAC,OAAO,GAAG,cAAc,CAAC,MAAM,CAAE,SAAS,CAAE,CAAC;QAElD,IAAI,CAAC,gBAAgB,GAAG,SAAS;cAC9B,SAAS,CAAC,gBAAgB;cAC1B,eAAe,CAAC;QAEnB,EAAE,CAAA,CAAE,eAAe,SAAU,CAAC;YAAC,MAAM,CAAC,MAAM,CAAE,IAAI,CAAE,CAAC;IACtD,CAAC;IACF,gBAAC;AAAD,CA9DA,AA8DC,IAAA;AA9DY,8BAAS;AAgEtB,kBAAe,SAAS,CAAC","file":"Container.js","sourcesContent":["import { finishDecorator as originalFinishDecorator } from \"sparqler/clauses/decorators/finish\";\nimport { subFinishDecorator } from \"sparqler/clauses/decorators/subFinish\";\nimport {\n\tFinishClause,\n\tSubFinishClause,\n} from \"sparqler/clauses/interfaces\";\nimport { IRIResolver } from \"sparqler/iri/IRIResolver\";\nimport { Token } from \"sparqler/tokens/Token\";\n\n\n/**\n * Interface of possible functions to be be used as finish decorators.\n *\n * Should accept a container with the query data as first parameter and\n * as second the object to decorate.\n */\nexport interface FinishDecorator<T extends FinishClause | SubFinishClause> extends Function {\n\t<W extends object>( container:Container<T>, object:W ):T & W;\n}\n\n/**\n * Immutable class that contains the hidden data of the query builder.\n *\n * Every step of the builder uses a different instance of the container\n * to make the query builder immutable-like.\n */\nexport class Container<T extends FinishClause | SubFinishClause = FinishClause> {\n\n\t/**\n\t * Array containing the query tokens.\n\t */\n\treadonly _tokens:Token[];\n\n\t/**\n\t * Decorator that extends the finish clause.\n\t */\n\treadonly _finishDecorator:FinishDecorator<T>;\n\n\t/**\n\t * Optional implementation of the IRI Resolver interface.\n\t */\n\treadonly _iriResolver?:IRIResolver;\n\n\t/**\n\t * Creates an empty container with a custom finish decorator if set.\n\t * If none is provided {@link clauses/decorators/finishDecorator}\n\t * will be used.\n\t *\n\t * @param finishDecorator The finish decorator to be used in the container.\n\t */\n\tconstructor( finishDecorator?:FinishDecorator<T> );\n\t/**\n\t * Creates a container copping the data of the previous container provided.\n\t *\n\t * If `newTokens` parameter is provided its data will be appended to the tokens\n\t * of the previous container tokens.\n\t *\n\t * If the `iriResolver` is provided, it will be used in the new container instead\n\t * of the IRIResolver of the previous container.\n\t *\n\t * If the previousContainer has {@link subFinishDecorator} as finish decorator,\n\t * the `_iriResolver` property will be un set.\n\t *\n\t * @param previousContainer Container to copied its properties.\n\t * @param newTokens Tokens to append to the to the `previousContainer` tokens copied.\n\t * @param iriResolver IRIResolver to be used for the new container.\n\t */\n\tconstructor( previousContainer:Container<any>, newTokens?:Token[], iriResolver?:IRIResolver );\n\tconstructor( containerOrFunction?:Container<any> | FinishDecorator<T>, newTokens?:Token[], iriResolver?:IRIResolver ) {\n\t\tconst container:Container<any> = containerOrFunction instanceof Function ?\n\t\t\tvoid 0 : containerOrFunction;\n\n\t\tconst finishDecorator:FinishDecorator<T> = containerOrFunction instanceof Function\n\t\t\t? containerOrFunction : originalFinishDecorator as FinishDecorator<T>;\n\n\t\tthis._iriResolver = finishDecorator !== subFinishDecorator ? ! iriResolver ? container ? container._iriResolver ?\n\t\t\tnew IRIResolver( container._iriResolver ) : void 0 : new IRIResolver() : iriResolver : void 0;\n\n\t\tconst previousTokens:Token[] = container ? container._tokens : [];\n\t\tif( ! newTokens ) newTokens = [];\n\t\tthis._tokens = previousTokens.concat( newTokens );\n\n\t\tthis._finishDecorator = container\n\t\t\t? container._finishDecorator\n\t\t\t: finishDecorator;\n\n\t\tif( new.target === Container ) Object.freeze( this );\n\t}\n}\n\nexport default Container;\n"]}