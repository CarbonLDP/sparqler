{"version":3,"sources":["clauses/Container.ts"],"names":[],"mappings":";;AAAA,8CAAiF;AACjF,oDAA4D;AAK5D,oDAAmD;AAoBnD;IA0CC,mBAAa,mBAAwD,EAAE,SAAkB,EAAE,WAAwB;;QAClH,IAAM,SAAS,GAAkB,mBAAmB,YAAY,QAAQ,CAAC,CAAC;YACzE,KAAK,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC;QAE9B,IAAM,eAAe,GAAsB,mBAAmB,YAAY,QAAQ;YACjF,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC,wBAA6C,CAAC;QAEvE,IAAI,CAAC,YAAY,GAAG,eAAe,KAAK,8BAAkB,CAAC,CAAC,CAAC,CAAE,WAAW,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;YAChH,IAAI,yBAAW,CAAE,SAAS,CAAC,YAAY,CAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,yBAAW,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QAE/F,IAAM,cAAc,GAAW,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;QAClE,IAAI,CAAE,SAAS;YAAG,SAAS,GAAG,EAAE,CAAC;QACjC,IAAI,CAAC,OAAO,GAAG,cAAc,CAAC,MAAM,CAAE,SAAS,CAAE,CAAC;QAElD,IAAI,CAAC,gBAAgB,GAAG,SAAS;YAChC,CAAC,CAAC,SAAS,CAAC,gBAAgB;YAC5B,CAAC,CAAC,eAAe,CAAC;QAEnB,IAAI,eAAe,SAAS;YAAG,MAAM,CAAC,MAAM,CAAE,IAAI,CAAE,CAAC;IACtD,CAAC;IACF,gBAAC;AAAD,CA9DA,AA8DC,IAAA;AA9DY,8BAAS;AAgEtB,kBAAe,SAAS,CAAC","file":"Container.js","sourcesContent":["import { finishDecorator as originalFinishDecorator } from \"./decorators/finish\";\nimport { subFinishDecorator } from \"./decorators/subFinish\";\nimport { FinishClause } from \"./FinishClause\";\nimport {\n\tSubFinishClause,\n} from \"./interfaces\";\nimport { IRIResolver } from \"./../iri/IRIResolver\";\nimport { Token } from \"./../tokens/Token\";\n\n\n/**\n * Interface of possible functions to be be used as finish decorators.\n *\n * Should accept a container with the query data as first parameter and\n * as second the object to decorate.\n */\nexport interface FinishDecorator<T extends FinishClause | SubFinishClause> extends Function {\n\t<W extends object>( container:Container<T>, object:W ):T & W;\n}\n\n/**\n * Immutable class that contains the hidden data of the query builder.\n *\n * Every step of the builder uses a different instance of the container\n * to make the query builder immutable-like.\n */\nexport class Container<T extends FinishClause | SubFinishClause = FinishClause> {\n\n\t/**\n\t * Array containing the query tokens.\n\t */\n\treadonly _tokens:Token[];\n\n\t/**\n\t * Decorator that extends the finish clause.\n\t */\n\treadonly _finishDecorator:FinishDecorator<T>;\n\n\t/**\n\t * Optional implementation of the IRI Resolver interface.\n\t */\n\treadonly _iriResolver?:IRIResolver;\n\n\t/**\n\t * Creates an empty container with the default finish decorator: {@link finishDecorator}.\n\t */\n\tconstructor();\n\t/**\n\t * Creates an empty container with a custom finish decorator.\n\t *\n\t * @param finishDecorator The finish decorated to be used in the container.\n\t */\n\tconstructor( finishDecorator?:FinishDecorator<T> );\n\t/**\n\t * Creates a container copping the data of the previous container provided.\n\t *\n\t * If `newTokens` parameter is provided its data will be appended to the tokens\n\t * of the previous container tokens.\n\t *\n\t * If the `iriResolver` is provided, it will be used in the new container instead\n\t * of the IRIResolver of the previous container. But if the value is `null` the\n\t * `_iriResolver` property will be undefined.\n\t *\n\t * @param previousContainer Container to be copied.\n\t * @param newTokens Tokens to append to the to the previousContainer tokens copied.\n\t * @param iriResolver IRIResolver to be used.\n\t */\n\tconstructor( previousContainer:Container<any>, newTokens?:Token[], iriResolver?:IRIResolver );\n\tconstructor( containerOrFunction?:Container<any> | FinishDecorator<T>, newTokens?:Token[], iriResolver?:IRIResolver ) {\n\t\tconst container:Container<any> = containerOrFunction instanceof Function ?\n\t\t\tvoid 0 : containerOrFunction;\n\n\t\tconst finishDecorator:FinishDecorator<T> = containerOrFunction instanceof Function\n\t\t\t? containerOrFunction : originalFinishDecorator as FinishDecorator<T>;\n\n\t\tthis._iriResolver = finishDecorator !== subFinishDecorator ? ! iriResolver ? container ? container._iriResolver ?\n\t\t\tnew IRIResolver( container._iriResolver ) : void 0 : new IRIResolver() : iriResolver : void 0;\n\n\t\tconst previousTokens:Token[] = container ? container._tokens : [];\n\t\tif( ! newTokens ) newTokens = [];\n\t\tthis._tokens = previousTokens.concat( newTokens );\n\n\t\tthis._finishDecorator = container\n\t\t\t? container._finishDecorator\n\t\t\t: finishDecorator;\n\n\t\tif( new.target === Container ) Object.freeze( this );\n\t}\n}\n\nexport default Container;\n"]}