{"version":3,"sources":["clauses/FinishClause.ts"],"names":[],"mappings":";;AAuCa,QAAA,YAAY,GAAG;IAC3B,UAAU,EAAV,UAA8B,SAA8B,EAAE,MAAQ;QACrE,IAAM,cAAc,GAAoC;YACvD,OAAA,SAAS,CAAC,WAAW,CAAC,QAAQ,CAAE,CAAC,CAAE;QAAnC,CAAmC,CAAC;QAErC,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAC7B,eAAe,EAAE,cAAM,OAAA,SAAS,CAAC,WAAW,CAAC,QAAQ,EAAE,EAAhC,CAAgC;YACvD,cAAc,EAAE,cAAc;YAC9B,QAAQ,EAAE,cAAc;SACxB,CAAE,CAAC;IACL,CAAC;CACD,CAAC","file":"FinishClause.js","sourcesContent":["import { Container } from \"../data/Container\";\n\nimport { TokenNode } from \"../tokens/TokenNode\";\n\n\n/**\n * Interface with methods to construct the final SPARQL query string.\n */\nexport interface FinishClause {\n\t/**\n\t * Constructs a compact SPARQL query string.\n\t *\n\t * Tries to minimize the optional elements and the blank spaces\n\t * between the elements of the query.\n\t *\n\t * @returns The compact string.\n\t */\n\ttoCompactString():string;\n\n\t/**\n\t * Constructs a pretty SPARQL query string.\n\t *\n\t * Prints the statements with indentation and also print all the\n\t * elements even if their are optional ones.\n\t *\n\t * @returns The pretty string.\n\t */\n\ttoPrettyString():string;\n\n\t/**\n\t * Return the same result as {@link FinishClause.toPrettyString}\n\t */\n\ttoString():string;\n}\n\n\n/**\n * Constant with the utils for {@link FinishClause} objects.\n */\nexport const FinishClause = {\n\tcreateFrom<O extends object>( container:Container<TokenNode>, object:O ):O & FinishClause {\n\t\tconst toPrettyString:FinishClause[ \"toPrettyString\" ] = () =>\n\t\t\tcontainer.targetToken.toString( 0 );\n\n\t\treturn Object.assign( object, {\n\t\t\ttoCompactString: () => container.targetToken.toString(),\n\t\t\ttoPrettyString: toPrettyString,\n\t\t\ttoString: toPrettyString,\n\t\t} );\n\t}\n};"]}