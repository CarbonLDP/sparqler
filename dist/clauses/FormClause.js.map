{"version":3,"sources":["clauses/FormClause.ts"],"names":[],"mappings":";;AAAA,oDAAmD;AAEnD,iDAAgD;AAOhD,iCAAuC;AACvC,6CAA4C;AAsC5C,mBAA8E,cAAkC,EAAE,SAAW,EAAE,KAAc;IAC5I,OAAO,UAAE,GAAU;QAClB,IAAM,WAAW,GAAgB,IAAI,2BAAY,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;QAE3E,IAAI,KAAK,GAAoB,SAAS,CAAC,WAAW,CAAC,WAAW,CAAC;QAC/D,IAAI,KAAK,CAAC,KAAK,KAAK,QAAQ;YAAG,MAAM,IAAI,KAAK,CAAE,sDAAsD,CAAE,CAAC;QAEzG,KAAK,GAAG,oBAAY,CAAE,KAAK,EAAE;YAC5B,OAAO,EAAE,IAAI,qBAAS,CAAE,WAAW,CAAC,OAAO,CAAE,GAAG,CAAE,EAAE,KAAK,CAAE;SAC3D,CAAE,CAAC;QAEJ,IAAM,UAAU,GAAc,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,WAAW,EAAE,KAAK,EAAE,CAAE,CAAC;QAC5F,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE;YAC7C,WAAW,aAAA;YACX,WAAW,EAAE,UAAU;SACT,CAAE,CAAC;QAElB,OAAO,kBAAU,CAAC,MAAM,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IAC9D,CAAC,CAAA;AACF,CAAC;AAMY,QAAA,UAAU,GAAG;IACzB,MAAM,EAAN,UAAoF,cAAiD,EAAE,SAAW,EAAE,MAAQ;QAC3J,OAAO,yBAAW,CAAC,MAAM,CAAE,cAAc,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAC5E,IAAI,EAAE,SAAS,CAAE,cAAc,EAAE,SAAS,CAAE;YAC5C,SAAS,EAAE,SAAS,CAAE,cAAc,EAAE,SAAS,EAAE,IAAI,CAAE;SACvD,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"FormClause.js","sourcesContent":["import { IRIResolver2 } from \"../iri/IRIResolver2\";\n\nimport { FromToken } from \"../tokens/FromToken\";\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\n\nimport { ClauseFactory } from \"./ClauseFactory\";\nimport { Container2 } from \"./Container2\";\nimport { FinishClause } from \"./FinishClause\";\nimport { cloneElement } from \"./utils\";\nimport { WhereClause } from \"./WhereClause\";\n\n\nexport interface FromClause<T extends FinishClause> extends WhereClause<T> {\n\t/**\n\t * Set a default graph to be included as the RDF Dataset where to\n\t * look for the query solutions.\n\t *\n\t * @param iri IRI of the default graph to be included.\n\t * @returns Object with the methods to keep constructing to query.\n\t */\n\tfrom( iri:string ):FromClause<T>;\n\n\t/**\n\t * Set a named graph to be included as the RDF Dataset where to look for\n\t * the query solutions.\n\t *\n\t * @param iri IRI of the named graph to be included.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tfromNamed( iri:string ):FromClause<T>;\n}\n\n\n/**\n * Function that creates a generic {@link FromClause.from} function.\n * This function is used to create all the methods for the {@link FromClause}\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link FromClause} receives.\n * @param container The container that is bound to the FromClause methods.\n * @param named Optional boolean that indicates if the dataset graph is named or not.\n *\n * @returns The generic \"from\" function that shares the {@link FromClause.from} signature.\n * It behaviour depends if the {@param named} was set or not.\n *\n * @private\n */\nfunction getFromFn<C extends Container2<QueryToken>, T extends FinishClause>( genericFactory:ClauseFactory<C, T>, container:C, named?:boolean ):FromClause<T>[ \"from\" ] {\n\treturn ( iri:string ) => {\n\t\tconst iriResolver:IRIResolver2 = new IRIResolver2( container.iriResolver );\n\n\t\tlet query:QueryClauseToken = container.targetToken.queryClause;\n\t\tif( query.token !== \"select\" ) throw new Error( \"Does not exists a SELECT token to add the FROM data.\" );\n\n\t\tquery = cloneElement( query, {\n\t\t\tdataset: new FromToken( iriResolver.resolve( iri ), named )\n\t\t} );\n\n\t\tconst queryToken:QueryToken = cloneElement( container.targetToken, { queryClause: query } );\n\t\tconst newContainer = cloneElement( container, {\n\t\t\tiriResolver,\n\t\t\ttargetToken: queryToken,\n\t\t} as Partial<C> );\n\n\t\treturn FromClause.create( genericFactory, newContainer, {} );\n\t}\n}\n\n\n/**\n * @todo\n */\nexport const FromClause = {\n\tcreate<C extends Container2<QueryToken>, T extends FinishClause, O extends object>( genericFactory:ClauseFactory<typeof container, T>, container:C, object:O ):O & FromClause<T> {\n\t\treturn WhereClause.create( genericFactory, container, Object.assign( object, {\n\t\t\tfrom: getFromFn( genericFactory, container ),\n\t\t\tfromNamed: getFromFn( genericFactory, container, true ),\n\t\t} ) );\n\t},\n};"]}