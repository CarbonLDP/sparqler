{"version":3,"sources":["clauses/FormClause.ts"],"names":[],"mappings":";;AAGA,qDAAoD;AACpD,uCAA6C;AAE7C,iDAAgD;AAIhD,6CAA4C;AAsC5C,mBAA2F,cAA4B,EAAE,SAAW,EAAE,KAAc;IACnJ,OAAO,UAAE,GAAU;QAClB,IAAM,WAAW,GAAgB,IAAI,2BAAY,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;QAE3E,IAAM,WAAW,GAAG,oBAAY,CAAE,SAAS,CAAC,WAAW,CAAC,WAAW,EAAE;YACpE,OAAO,EAAE,IAAI,qBAAS,CAAE,WAAW,CAAC,OAAO,CAAE,GAAG,CAAE,EAAE,KAAK,CAAE;SAC3D,CAAE,CAAC;QAEJ,IAAM,UAAU,GAAc,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,WAAW,aAAA,EAAE,CAAE,CAAC;QACrF,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE;YAC7C,WAAW,aAAA;YACX,WAAW,EAAE,UAAU;SACT,CAAE,CAAC;QAElB,OAAO,kBAAU,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IAClE,CAAC,CAAA;AACF,CAAC;AAMY,QAAA,UAAU,GAAG;IACzB,UAAU,EAAV,UAAqG,cAA4B,EAAE,SAAW,EAAE,MAAQ;QACvJ,OAAO,yBAAW,CAAC,UAAU,CAAE,cAAc,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAChF,IAAI,EAAE,SAAS,CAAE,cAAc,EAAE,SAAS,CAAE;YAC5C,SAAS,EAAE,SAAS,CAAE,cAAc,EAAE,SAAS,EAAE,IAAI,CAAE;SACvD,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"FormClause.js","sourcesContent":["import { SelectToken } from \"./../tokens\";\nimport { Container2 } from \"../data/Container2\";\nimport { Factory } from \"../data/Factory\";\nimport { IRIResolver2 } from \"../data/IRIResolver2\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { FromToken } from \"../tokens/FromToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { WhereClause } from \"./WhereClause\";\n\n\nexport interface FromClause<T extends FinishClause> extends WhereClause<T> {\n\t/**\n\t * Set a default graph to be included as the RDF Dataset where to\n\t * look for the query solutions.\n\t *\n\t * @param iri IRI of the default graph to be included.\n\t * @returns Object with the methods to keep constructing to query.\n\t */\n\tfrom( iri:string ):FromClause<T>;\n\n\t/**\n\t * Set a named graph to be included as the RDF Dataset where to look for\n\t * the query solutions.\n\t *\n\t * @param iri IRI of the named graph to be included.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tfromNamed( iri:string ):FromClause<T>;\n}\n\n\n/**\n * Function that creates a generic {@link FromClause.from} function.\n * This function is used to create all the methods for the {@link FromClause}\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link FromClause} receives.\n * @param container The container that is bound to the FromClause methods.\n * @param named Optional boolean that indicates if the dataset graph is named or not.\n *\n * @returns The generic \"from\" function that shares the {@link FromClause.from} signature.\n * It behaviour depends if the {@param named} was set or not.\n *\n * @private\n */\nfunction getFromFn<C extends Container2<QueryToken<SelectToken>>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C, named?:boolean ):FromClause<T>[ \"from\" ] {\n\treturn ( iri:string ) => {\n\t\tconst iriResolver:IRIResolver2 = new IRIResolver2( container.iriResolver );\n\n\t\tconst queryClause = cloneElement( container.targetToken.queryClause, {\n\t\t\tdataset: new FromToken( iriResolver.resolve( iri ), named )\n\t\t} );\n\n\t\tconst queryToken:QueryToken = cloneElement( container.targetToken, { queryClause } );\n\t\tconst newContainer = cloneElement( container, {\n\t\t\tiriResolver,\n\t\t\ttargetToken: queryToken,\n\t\t} as Partial<C> );\n\n\t\treturn FromClause.createFrom( genericFactory, newContainer, {} );\n\t}\n}\n\n\n/**\n * @todo\n */\nexport const FromClause = {\n\tcreateFrom<C extends Container2<QueryToken<SelectToken>>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & FromClause<T> {\n\t\treturn WhereClause.createFrom( genericFactory, container, Object.assign( object, {\n\t\t\tfrom: getFromFn( genericFactory, container ),\n\t\t\tfromNamed: getFromFn( genericFactory, container, true ),\n\t\t} ) );\n\t},\n};"]}