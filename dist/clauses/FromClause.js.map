{"version":3,"sources":["clauses/FromClause.ts"],"names":[],"mappings":";;AAEA,mDAAkD;AAClD,uCAA6C;AAE7C,iDAAgD;AAKhD,6CAA4C;AAyC5C,SAAS,SAAS,CAAwE,cAA4B,EAAE,SAAW,EAAE,KAAc;IAClJ,OAAO,UAAE,GAAU;QAClB,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;QAEzE,IAAM,WAAW,GAAG,oBAAY,CAAE,SAAS,CAAC,WAAW,CAAC,WAAW,EAAE;YACpE,OAAO,EAAE,IAAI,qBAAS,CAAE,WAAW,CAAC,OAAO,CAAE,GAAG,CAAE,EAAE,KAAK,CAAE;SAC3D,CAAE,CAAC;QAEJ,IAAM,UAAU,GAAc,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,WAAW,aAAA,EAAE,CAAE,CAAC;QACrF,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE;YAC7C,WAAW,aAAA;YACX,WAAW,EAAE,UAAU;SACT,CAAE,CAAC;QAElB,OAAO,kBAAU,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IAClE,CAAC,CAAA;AACF,CAAC;AAMY,QAAA,UAAU,GAgBnB;IACH,UAAU,EAAV,UAAoG,cAA4B,EAAE,SAAW,EAAE,MAAQ;QACtJ,OAAO,yBAAW,CAAC,UAAU,CAAE,cAAc,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAChF,IAAI,EAAE,SAAS,CAAE,cAAc,EAAE,SAAS,CAAE;YAC5C,SAAS,EAAE,SAAS,CAAE,cAAc,EAAE,SAAS,EAAE,IAAI,CAAE;SACvD,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"FromClause.js","sourcesContent":["import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\nimport { IRIResolver } from \"../data/IRIResolver\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { FromToken } from \"../tokens/FromToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SelectToken } from \"../tokens/SelectToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { WhereClause } from \"./WhereClause\";\n\n\n/**\n * Interface with the methods available to make a FROM statement.\n */\nexport interface FromClause<T extends FinishClause> extends WhereClause<T> {\n\t/**\n\t * Set a default graph to be included as the RDF Dataset where to\n\t * look for the query solutions.\n\t *\n\t * @param iri IRI of the default graph to be included.\n\t * @returns Object with the methods to keep constructing to query.\n\t */\n\tfrom( iri:string ):FromClause<T>;\n\n\t/**\n\t * Set a named graph to be included as the RDF Dataset where to look for\n\t * the query solutions.\n\t *\n\t * @param iri IRI of the named graph to be included.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tfromNamed( iri:string ):FromClause<T>;\n}\n\n\n/**\n * Function that creates a generic {@link FromClause.from} function.\n * This function is used to create all the methods for the {@link FromClause}\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link FromClause} receives.\n * @param container The container that is bound to the FromClause methods.\n * @param named Optional boolean that indicates if the dataset graph is named or not.\n *\n * @returns The generic \"from\" function that shares the {@link FromClause.from} signature.\n * It behaviour depends if the {@param named} was set or not.\n *\n * @private\n */\nfunction getFromFn<C extends Container<QueryToken<SelectToken>>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C, named?:boolean ):FromClause<T>[ \"from\" ] {\n\treturn ( iri:string ) => {\n\t\tconst iriResolver:IRIResolver = new IRIResolver( container.iriResolver );\n\n\t\tconst queryClause = cloneElement( container.targetToken.queryClause, {\n\t\t\tdataset: new FromToken( iriResolver.resolve( iri ), named )\n\t\t} );\n\n\t\tconst queryToken:QueryToken = cloneElement( container.targetToken, { queryClause } );\n\t\tconst newContainer = cloneElement( container, {\n\t\t\tiriResolver,\n\t\t\ttargetToken: queryToken,\n\t\t} as Partial<C> );\n\n\t\treturn FromClause.createFrom( genericFactory, newContainer, {} );\n\t}\n}\n\n\n/**\n * Constant with the utils for {@link FromClause} objects.\n */\nexport const FromClause:{\n\t/**\n\t * Factory function that allows to crete a {@link FromClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link FromClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link FromClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link FromClause} statement.\n\t *\n\t * @return The {@link FromClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken<SelectToken>>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & FromClause<T>;\n} = {\n\tcreateFrom<C extends Container<QueryToken<SelectToken>>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & FromClause<T> {\n\t\treturn WhereClause.createFrom( genericFactory, container, Object.assign( object, {\n\t\t\tfrom: getFromFn( genericFactory, container ),\n\t\t\tfromNamed: getFromFn( genericFactory, container, true ),\n\t\t} ) );\n\t},\n};"]}