{"version":3,"sources":["clauses/HavingClause.ts"],"names":[],"mappings":";;AAGA,qDAAoD;AAMpD,6CAA4C;AAC5C,mEAA0E;AAiC1E,SAAS,WAAW,CAA8F,cAA4B,EAAE,SAAW;IAC1J,OAAO,UAAE,YAAmB;QAC3B,IAAM,KAAK,GAAe,IAAI,yBAAW,CAAE,YAAY,CAAE,CAAC;QAC1D,IAAM,YAAY,GAAG,uDAA8B,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;QAExE,IAAM,WAAW,GAAkB,yBAAW,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;QAC9F,OAAO,cAAc,CAAE,YAAY,EAAE,WAAW,CAAE,CAAC;IACpD,CAAC,CAAA;AACF,CAAC;AAMY,QAAA,YAAY,GAgBrB;IACH,UAAU,EAAV,UAA0H,cAA2C,EAAE,SAAW,EAAE,MAAQ;QAC3L,OAAO,yBAAW,CAAC,UAAU,CAAE,cAAc,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAChF,MAAM,EAAE,WAAW,CAAE,cAAc,EAAE,SAAS,CAAE;SAChD,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"HavingClause.js","sourcesContent":["import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\n\nimport { HavingToken } from \"../tokens/HavingToken\";\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { OrderClause } from \"./OrderClause\";\nimport { cloneSolutionModifierContainer } from \"./SolutionModifierClause\";\n\n\n/**\n * Interface with the methods available to make a HAVING statement.\n */\nexport interface HavingClause<T extends FinishClause> extends OrderClause<T> {\n\t/**\n\t * Set a condition to filter the sequence of solutions the query will\n\t * retrieve.\n\t *\n\t * Notice: The current version of SPARQLER does not evaluate the condition\n\t * for possible errors\n\t *\n\t * @param rawCondition Raw condition to be applied for the solutions filtering.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\t// TODO: create having condition expressions\n\thaving( rawCondition:string ):OrderClause<T> & T;\n}\n\n\n/**\n * Function that creates the {@link HavingClause.having} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link HavingClause} receives.\n * @param container The container with the query data of the statement.\n *\n * @returns The {@link HavingClause.having} function.\n *\n * @private\n */\nfunction getHavingFn<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C ):HavingClause<T>[ \"having\" ] {\n\treturn ( rawCondition:string ) => {\n\t\tconst token:HavingToken = new HavingToken( rawCondition );\n\t\tconst newContainer = cloneSolutionModifierContainer( container, token );\n\n\t\tconst orderClause:OrderClause<T> = OrderClause.createFrom( genericFactory, newContainer, {} );\n\t\treturn genericFactory( newContainer, orderClause );\n\t}\n}\n\n\n/**\n * Constant with the utils for {@link HavingClause} objects.\n */\nexport const HavingClause:{\n\t/**\n\t * Factory function that allows to crete a {@link HavingClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link HavingClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link HavingClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link HavingClause} statement.\n\t *\n\t * @return The {@link HavingClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & HavingClause<T>;\n} = {\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & HavingClause<T> {\n\t\treturn OrderClause.createFrom( genericFactory, container, Object.assign( object, {\n\t\t\thaving: getHavingFn( genericFactory, container ),\n\t\t} ) );\n\t},\n};\n"]}