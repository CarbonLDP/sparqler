{"version":3,"sources":["clauses/LimitOffsetClause.ts"],"names":[],"mappings":";;AACA,2CAA0C;AAO1C,6CAA4C;AAC5C,+CAA8C;AAC9C,+CAA8C;AAqD9C,SAAS,gBAAgB,CAA4D,aAAqD;IACzI,IAAM,mBAAmB,GAAyD,2BAAY;SAC5F,UAAU,CAAC,IAAI,CAAE,IAAI,EAAE,aAAa,CAAE,CAAC;IAEzC,OAAO,UAAE,UAAU,EAAE,OAAO,IAAM,OAAA,yBAAW;SAC3C,UAAU,CAAE,iBAAO,CAAC,UAAU,CAAE,mBAAmB,EAAE,aAAa,CAAE,EAAE,UAAU,EAAE,OAAO,CAAE,EAD3D,CAC2D,CAAC;AAC/F,CAAC;AAED,SAAS,iBAAiB,CAA4D,aAAqD;IAC1I,IAAM,kBAAkB,GAAwD,yBAAW;SACzF,UAAU,CAAC,IAAI,CAAE,IAAI,EAAE,aAAa,CAAE,CAAC;IAEzC,OAAO,UAAE,UAAU,EAAE,OAAO,IAAM,OAAA,2BAAY;SAC5C,UAAU,CAAE,iBAAO,CAAC,UAAU,CAAE,aAAa,EAAE,kBAAkB,CAAE,EAAE,UAAU,EAAE,OAAO,CAAE,EAD1D,CAC0D,CAAC;AAC9F,CAAC;AAMY,QAAA,iBAAiB,GAgB1B;IACH,UAAU,EAAV,UAA0H,cAA4B,EAAE,SAAW,EAAE,MAAQ;QAC5K,IAAM,aAAa,GAA+B,2BAAY;aAC5D,UAAU,CAAC,IAAI,CAAE,IAAI,EAAE,cAAc,CAAE,CAAC;QAE1C,IAAM,uBAAuB,GAAG,iBAAO,CAAC,UAAU,CAAE,cAAc,EAAE,aAAa,CAAE,CAAC;QAEpF,OAAO,iBAAO,CAAC,UAAU,CACxB,gBAAgB,CAAQ,uBAAuB,CAAE,EACjD,iBAAiB,CAAQ,uBAAuB,CAAE,EAClD,aAAa,CACb,CAAE,SAAS,EAAE,MAAM,CAAE,CAAC;IACxB,CAAC;CACD,CAAC","file":"LimitOffsetClause.js","sourcesContent":["import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\n\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { LimitClause } from \"./LimitClause\";\nimport { OffsetClause } from \"./OffsetClause\";\nimport { ValuesClause } from \"./ValuesClause\";\n\n\n/**\n * Interface that specify union of the LIMIT and OFFSET statements.\n * Its specified in a form one can use `limit` and `offset` in\n * this order or viceversa, but not be able to repeat the `limit`\n * or `offset` methods.\n *\n * Example:\n *  - Correct:\n *  ```typescript\n *      import { LimitOffsetClause } from \"./\";\n *      let query:LimitOffsetClause;\n *\n *      query\n *          .limit( &#47;*...*&#47; )\n *          .offset( &#47;*...*&#47; )\n *      ;\n *\n *      query\n *          .offset( &#47;*...*&#47; )\n *          .limit( &#47;*...*&#47; )\n *      ;\n *\n *      query\n *          .limit( &#47;*...*&#47; )\n *      ;\n * ```\n *\n *  - Incorrect:\n *  ```typescript\n *      import { LimitOffsetClause } from \"./../Clauses\";\n *      let query:LimitOffsetClause;\n *\n *      query\n *          .limit( &#47;*...*&#47; )\n *          .limit( &#47;*...*&#47; ) // Not possible\n *          .offset( &#47;*...*&#47; )\n *      ;\n *\n *      query\n *          .offset( &#47;*...*&#47; )\n *          .limit( &#47;*...*&#47; )\n *          .offset( &#47;*...*&#47; ) // Not possible\n *      ;\n * ```\n */\nexport interface LimitOffsetClause<T extends FinishClause> extends LimitClause<OffsetClause<ValuesClause<T> & T> & ValuesClause<T> & T>,\n                                                                   OffsetClause<LimitClause<ValuesClause<T> & T> & ValuesClause<T> & T>,\n                                                                   ValuesClause<T> {}\n\n\nfunction _getLimitFactory<CONTAINER extends Container<any>, T extends FinishClause>( valuesFactory:Factory<CONTAINER, ValuesClause<T> & T> ):Factory<CONTAINER, LimitClause<OffsetClause<ValuesClause<T> & T> & ValuesClause<T> & T>> {\n\tconst offsetValuesFactory:Factory<CONTAINER, OffsetClause<ValuesClause<T> & T>> = OffsetClause\n\t\t.createFrom.bind( null, valuesFactory );\n\n\treturn ( container1, object1 ) => LimitClause\n\t\t.createFrom( Factory.createFrom( offsetValuesFactory, valuesFactory ), container1, object1 );\n}\n\nfunction _getOffsetFactory<CONTAINER extends Container<any>, T extends FinishClause>( valuesFactory:Factory<CONTAINER, ValuesClause<T> & T> ):Factory<CONTAINER, OffsetClause<LimitClause<ValuesClause<T> & T> & ValuesClause<T> & T>> {\n\tconst limitValuesFactory:Factory<CONTAINER, LimitClause<ValuesClause<T> & T>> = LimitClause\n\t\t.createFrom.bind( null, valuesFactory );\n\n\treturn ( container1, object1 ) => OffsetClause\n\t\t.createFrom( Factory.createFrom( valuesFactory, limitValuesFactory ), container1, object1 );\n}\n\n\n/**\n * Constant with the utils for {@link LimitOffsetClause} objects.\n */\nexport const LimitOffsetClause:{\n\t/**\n\t * Factory function that allows to crete a {@link LimitOffsetClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link LimitOffsetClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link LimitOffsetClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link LimitOffsetClause} statement.\n\t *\n\t * @return The {@link LimitOffsetClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & LimitOffsetClause<T>;\n} = {\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & LimitOffsetClause<T> {\n\t\tconst valuesFactory:Factory<C, ValuesClause<T>> = ValuesClause\n\t\t\t.createFrom.bind( null, genericFactory );\n\n\t\tconst genericAndValuesFactory = Factory.createFrom( genericFactory, valuesFactory );\n\n\t\treturn Factory.createFrom(\n\t\t\t_getLimitFactory<C, T>( genericAndValuesFactory ),\n\t\t\t_getOffsetFactory<C, T>( genericAndValuesFactory ),\n\t\t\tvaluesFactory\n\t\t)( container, object );\n\t},\n};\n"]}