{"version":3,"sources":["clauses/OrderClause.ts"],"names":[],"mappings":";;AACA,mDAAkD;AAOlD,yDAAwD;AACxD,mEAA0E;AAsB1E,sBAAoH,cAAkC,EAAE,SAAW;IAClK,OAAO,UAAE,YAAmB;QAC3B,IAAM,KAAK,GAAc,IAAI,uBAAU,CAAE,YAAY,CAAE,CAAC;QACxD,IAAM,YAAY,GAAG,uDAA8B,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;QAExE,IAAM,iBAAiB,GAAwB,qCAAiB,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;QAChH,OAAO,cAAc,CAAE,YAAY,EAAE,iBAAiB,CAAE,CAAC;IAC1D,CAAC,CAAC;AACH,CAAC;AAMY,QAAA,WAAW,GAAG;IAC1B,UAAU,EAAV,UAA2H,cAAiD,EAAE,SAAW,EAAE,MAAQ;QAClM,OAAO,qCAAiB,CAAC,UAAU,CAAE,cAAc,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YACtF,OAAO,EAAE,YAAY,CAAE,cAAc,EAAE,SAAS,CAAE;SAClD,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"OrderClause.js","sourcesContent":["import { FinishClause } from \"./FinishClause\";\nimport { OrderToken } from \"../tokens/OrderToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\n\nimport { ClauseFactory } from \"./ClauseFactory\";\nimport { Container2 } from \"./Container2\";\nimport { SubFinishClause } from \"./interfaces\";\nimport { LimitOffsetClause } from \"./LimitOffsetClause\";\nimport { cloneSolutionModifierContainer } from \"./SolutionModifierClause\";\n\n\nexport interface OrderClause<T extends FinishClause | SubFinishClause> extends LimitOffsetClause<T> {\n\t/**\n\t * Set a condition to be used as the order of the sequence of solutions the\n\t * query will retrieve.\n\t *\n\t * Notice: The current version of SPARQLER does not evaluate the condition\n\t * for possible errors.\n\t *\n\t * @param rawCondition Raw condition to be applied for the solutions order.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\t// TODO: create order condition expressions\n\torderBy( rawCondition:string ):LimitOffsetClause<T> & T;\n}\n\n\n/**\n * @todo\n */\nfunction getOrderByFn<C extends Container2<QueryToken | SubSelectToken>, T extends FinishClause | SubFinishClause>( genericFactory:ClauseFactory<C, T>, container:C ):OrderClause<T>[ \"orderBy\" ] {\n\treturn ( rawCondition:string ) => {\n\t\tconst token:OrderToken = new OrderToken( rawCondition );\n\t\tconst newContainer = cloneSolutionModifierContainer( container, token );\n\n\t\tconst limitOffsetClause:LimitOffsetClause<T> = LimitOffsetClause.createFrom( genericFactory, newContainer, {} );\n\t\treturn genericFactory( newContainer, limitOffsetClause );\n\t};\n}\n\n\n/**\n * @todo\n */\nexport const OrderClause = {\n\tcreateFrom<C extends Container2<QueryToken | SubSelectToken>, T extends FinishClause | SubFinishClause, O extends object>( genericFactory:ClauseFactory<typeof container, T>, container:C, object:O ):O & OrderClause<T> {\n\t\treturn LimitOffsetClause.createFrom( genericFactory, container, Object.assign( object, {\n\t\t\torderBy: getOrderByFn( genericFactory, container ),\n\t\t} ) );\n\t}\n};\n"]}