{"version":3,"sources":["clauses/QueryClause.ts"],"names":[],"mappings":";;AAAA,2CAA0C;AAC1C,mDAAkD;AAElD,uCAA6C;AAE7C,iDAAgD;AAChD,qDAAoD;AACpD,qDAAoD;AAIpD,+CAA8C;AAmD9C,SAAS,IAAI,CAAsD,GAAU;IAC5E,IAAM,KAAK,GAAa,IAAI,qBAAS,CAAE,IAAI,yBAAW,CAAE,GAAG,CAAE,CAAE,CAAC;IAEhE,IAAM,SAAS,GAA6B,IAAI,CAAC,WAAW;SAC1D,SAAS,CAAC,MAAM,CAAE,KAAK,CAAE,CAAC;IAE5B,IAAM,UAAU,GAAc,oBAAY,CAAE,IAAI,CAAC,WAAW,EAAE,EAAE,SAAS,WAAA,EAAE,CAAE,CAAC;IAC9E,IAAM,SAAS,GAAyB,oBAAY,CAAE,IAAI,EAAE,EAAE,WAAW,EAAE,UAAU,EAAE,CAAE,CAAC;IAE1F,OAAO,mBAAW,CAAC,UAAU,CAAE,SAAS,EAAE,EAAE,CAAE,CAAC;AAChD,CAAC;AAKD,SAAS,KAAK,CAAsD,GAAU;IAC7E,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,IAAI,CAAC,WAAW,EAAE,GAAG,CAAE,CAAC;IACzE,IAAM,SAAS,GAAyB,oBAAY,CAAE,IAAI,EAAE,EAAE,WAAW,aAAA,EAAE,CAAE,CAAC;IAE9E,OAAO,mBAAW,CAAC,UAAU,CAAE,SAAS,EAAE,EAAE,CAAE,CAAC;AAChD,CAAC;AAKD,SAAS,MAAM,CAAsD,IAAW,EAAE,GAAU;IAC3F,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,IAAI,CAAC,WAAW,CAAE,CAAC;IAGpE,IAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;IAErD,IAAI,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAE,IAAI,CAAE,EAAG;QACtC,IAAM,KAAK,GAAU,SAAS;aAC5B,SAAS,CAAE,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,SAAS,KAAK,IAAI,EAApD,CAAoD,CAAE,CAAC;QAE7E,IAAI,KAAK,KAAK,CAAE,CAAC;YAChB,SAAS,CAAC,MAAM,CAAE,KAAK,EAAE,CAAC,CAAE,CAAC;KAC9B;IAED,SAAS,CAAC,IAAI,CAAE,IAAI,yBAAW,CAAE,IAAI,EAAE,IAAI,yBAAW,CAAE,GAAG,CAAE,CAAE,CAAE,CAAC;IAClE,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAE,IAAI,EAAE,KAAK,CAAE,CAAC;IAGxC,IAAM,UAAU,GAAc,oBAAY,CAAE,IAAI,CAAC,WAAW,EAAE,EAAE,SAAS,WAAA,EAAE,CAAE,CAAC;IAC9E,IAAM,SAAS,GAAyB,oBAAY,CAAE,IAAI,EAAE;QAC3D,WAAW,aAAA;QACX,WAAW,EAAE,UAAU;KACvB,CAAE,CAAC;IAEJ,OAAO,mBAAW,CAAC,UAAU,CAAE,SAAS,EAAE,EAAE,CAAE,CAAC;AAChD,CAAC;AAMY,QAAA,WAAW,GAcpB;IACH,UAAU,EAAV,UAAiG,SAAW,EAAE,MAAQ;QACrH,IAAM,aAAa,GAAoC,2BAAY;aACjE,UAAU,CAAC,IAAI,CAAE,IAAI,EAAE,SAAS,CAAC,yBAAyB,CAAE,CAAC;QAE/D,OAAO,iBAAO,CAAC,UAAU,CACxB,aAAa,CACb,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YACpC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAE,SAAS,CAAE;YAC5B,KAAK,EAAE,KAAK,CAAC,IAAI,CAAE,SAAS,CAAE;YAC9B,MAAM,EAAE,MAAM,CAAC,IAAI,CAAE,SAAS,CAAE;SAChC,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"QueryClause.js","sourcesContent":["import { Factory } from \"../data/Factory\";\nimport { IRIResolver } from \"../data/IRIResolver\";\nimport { QueryUnitContainer } from \"../data/QueryUnitContainer\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { BaseToken } from \"../tokens/BaseToken\";\nimport { IRIRefToken } from \"../tokens/IRIRefToken\";\nimport { PrefixToken } from \"../tokens/PrefixToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { SelectClause } from \"./SelectClause\";\n\n\n/**\n * Interface that describes the base entry of any query statement.\n *\n * It allows to add the prologues `BASE` and `PREFIX`.\n * And also add support for specify a `vocab` used to resolve\n * relative properties/predicates.\n *\n * The current query types supported are:\n * - `SELECT`, specified by the extension of {@link SelectClause}\n */\nexport interface QueryClause<T extends FinishClause> extends SelectClause<T> {\n\t/**\n\t * Add a base IRI the query uses to resolve any relative IRIs.\n\t *\n\t * If a default vocabulary is set with the {@link QueryClause.vocab}\n\t * method, the base is ignored for relative predicates.\n\t *\n\t * @param iri IRI to be used as the query BASE.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tbase( iri:string ):QueryClause<T>;\n\n\t/**\n\t * Add a default vocabulary to be used to resolve relative IRIs when\n\t * used as a predicate in a triple pattern.\n\t *\n\t * @param iri IRI to append to prepend to any relative predicate.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvocab( iri:string ):QueryClause<T>;\n\n\t/**\n\t * Add a prefix to the query.\n\t *\n\t * If the prefix is not used in any part of the query it is not added\n\t * in the compact query string.\n\t *\n\t * @param name Name the prefix will be identified for.\n\t * @param iri The IRI of the current PREFIX.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tprefix( name:string, iri:string ):QueryClause<T>;\n}\n\n\n/**\n * @see {@link QueryClause.base}\n */\nfunction base<T extends FinishClause>( this:QueryUnitContainer<T>, iri:string ):QueryClause<T> {\n\tconst token:BaseToken = new BaseToken( new IRIRefToken( iri ) );\n\n\tconst prologues:QueryToken[ \"prologues\" ] = this.targetToken\n\t\t.prologues.concat( token );\n\n\tconst queryToken:QueryToken = cloneElement( this.targetToken, { prologues } );\n\tconst container:QueryUnitContainer<T> = cloneElement( this, { targetToken: queryToken } );\n\n\treturn QueryClause.createFrom( container, {} );\n}\n\n/**\n * @see {@link QueryClause.vocab}\n */\nfunction vocab<T extends FinishClause>( this:QueryUnitContainer<T>, iri:string ):QueryClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this.iriResolver, iri );\n\tconst container:QueryUnitContainer<T> = cloneElement( this, { iriResolver } );\n\n\treturn QueryClause.createFrom( container, {} );\n}\n\n/**\n * @see {@link QueryClause.prefix}\n */\nfunction prefix<T extends FinishClause>( this:QueryUnitContainer<T>, name:string, iri:string ):QueryClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this.iriResolver );\n\n\n\tconst prologues = this.targetToken.prologues.slice();\n\n\tif( iriResolver.prefixes.has( name ) ) {\n\t\tconst index:number = prologues\n\t\t\t.findIndex( token => token.token === \"prefix\" && token.namespace === name );\n\n\t\tif( index !== - 1 )\n\t\t\tprologues.splice( index, 1 );\n\t}\n\n\tprologues.push( new PrefixToken( name, new IRIRefToken( iri ) ) );\n\tiriResolver.prefixes.set( name, false );\n\n\n\tconst queryToken:QueryToken = cloneElement( this.targetToken, { prologues } );\n\tconst container:QueryUnitContainer<T> = cloneElement( this, {\n\t\tiriResolver,\n\t\ttargetToken: queryToken,\n\t} );\n\n\treturn QueryClause.createFrom( container, {} );\n}\n\n\n/**\n * Constant with the utils functions for {@link QueryClause} objects.\n */\nexport const QueryClause:{\n\t/**\n\t * Factory function that allows to crete a {@link QueryClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link QueryClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link QueryClause} statement.\n\t *\n\t * @return The {@link QueryClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends QueryUnitContainer<SELECT>, SELECT extends FinishClause, T extends object>( container:C, object:T ):T & QueryClause<SELECT>;\n} = {\n\tcreateFrom<C extends QueryUnitContainer<SELECT>, SELECT extends FinishClause, T extends object>( container:C, object:T ):T & QueryClause<SELECT> {\n\t\tconst selectFactory:Factory<C, SelectClause<SELECT>> = SelectClause\n\t\t\t.createFrom.bind( null, container.selectFinishClauseFactory );\n\n\t\treturn Factory.createFrom(\n\t\t\tselectFactory\n\t\t)( container, Object.assign( object, {\n\t\t\tbase: base.bind( container ),\n\t\t\tvocab: vocab.bind( container ),\n\t\t\tprefix: prefix.bind( container ),\n\t\t} ) );\n\t},\n};"]}