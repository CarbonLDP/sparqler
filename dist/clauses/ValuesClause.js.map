{"version":3,"sources":["clauses/ValuesClause.ts"],"names":[],"mappings":";;AACA,0CAAgF;AAEhF,sCAAqE;AAErE,oDAAmD;AAInD,wDAAsD;AAKtD,iCAAuC;AA2DvC,6BAA8B,mBAAqC;IAClE,IAAI,KAAK,CAAC,OAAO,CAAE,mBAAmB,CAAE;QACvC,OAAO,mBAAmB,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,IAAI,sBAAa,CAAE,CAAC,CAAE,EAAtB,CAAsB,CAAE,CAAC;IAE/D,OAAO,CAAE,IAAI,sBAAa,CAAE,mBAAmB,CAAE,CAAE,CAAC;AACrD,CAAC;AAED,6BAA8B,eAA+B,EAAE,WAAwB;IACtF,IAAM,SAAS,GAAkC,OAAO,eAAe,KAAK,UAAU,CAAC,CAAC;QAEvF,eAAe,CAAE,IAAI,yBAAc,CAAE,WAAkB,CAAE,CAAE,CAAC,CAAC;QAC7D,eAAe,CAAC;IAGjB,IAAI,CAAE,KAAK,CAAC,OAAO,CAAE,SAAS,CAAE;QAC/B,OAAO,CAAE,CAAE,SAAS,CAAE,CAAE,CAAC;IAE1B,OAAO,SAAS,CAAC,GAAG,CAAE,UAAA,QAAQ;QAC7B,IAAI,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE;YAAG,OAAO,QAAQ,CAAC;QAChD,OAAO,CAAE,QAAQ,CAAE,CAAC;IACrB,CAAC,CAAE,CAAC;AACL,CAAC;AAED,wBAAsH,cAAkC,EAAE,SAAW;IACpK,OAAO,UAAE,mBAAqC,EAAE,eAA+B;QAC9E,IAAM,WAAW,GAAgB,IAAI,2BAAY,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;QAC3E,IAAM,MAAM,GAAc,mBAAmB,CAAE,eAAe,EAAE,WAAW,CAAE,CAAC;QAE9E,IAAM,SAAS,GAAmB,mBAAmB,CAAE,mBAAmB,CAAE,CAAC;QAE7E,IAAM,KAAK,GAAe,IAAI,oBAAW,EAAE,CAAC;QAC5C,MAAM,CAAC,OAAO,CAAE,UAAE,SAAS,EAAE,KAAK;YACjC,KAAK,CAAC,SAAS,OAAf,KAAK,GAAY,SAAS,CAAE,KAAK,CAAE,SAAK,SAAS,CAAC,GAAG,CAAE,4BAAY,CAAE,GAAG;QACzE,CAAC,CAAE,CAAC;QAEJ,IAAM,WAAW,GAAG,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAE,CAAC;QAC7E,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;QAC3F,OAAO,cAAc,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IAC3C,CAAC,CAAA;AACF,CAAC;AAMY,QAAA,YAAY,GAAG;IAC3B,MAAM,EAAN,UAAqG,cAAkC,EAAE,SAAW,EAAE,MAAQ;QAC7J,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAC7B,MAAM,EAAE,cAAc,CAAE,cAAc,EAAE,SAAS,CAAE;SACnD,CAAE,CAAC;IACL,CAAC;CACD,CAAC","file":"ValuesClause.js","sourcesContent":["import { FinishClause } from \"./FinishClause\";\nimport { PatternBuilder, SupportedNativeTypes, Undefined } from \"./../patterns\";\nimport { Literal, Resource } from \"./../patterns/triples\";\nimport { QueryToken, ValuesToken, VariableToken } from \"./../tokens\";\n\nimport { IRIResolver2 } from \"../iri/IRIResolver2\";\n\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\n\nimport { convertValue } from \"../utils/ObjectPattern\";\n\nimport { ClauseFactory } from \"./ClauseFactory\";\nimport { Container2 } from \"./Container2\";\nimport { SubFinishClause } from \"./interfaces\";\nimport { cloneElement } from \"./utils\";\n\n\nexport interface ValuesClause<T extends FinishClause | SubFinishClause> {\n\t/**\n\t * Set the values of a variable to be combined into the results query.\n\t *\n\t * @param variable Variable to add values.\n\t * @param values The values to be combined.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variable:string, values:SupportedNativeTypes | SupportedNativeTypes[] ):T;\n\n\t/**\n\t * Set the values of a variable to be combined into the results query.\n\t *\n\t * The values are constructed with a function that receives a\n\t * pattern builder.\n\t *\n\t * @param variable Variable to add values.\n\t * @param valuesBuilder Functions that returns the values to be added.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variable:string, valuesBuilder:( builder:PatternBuilder ) => (SupportedNativeTypes | Resource | Literal | Undefined) | (SupportedNativeTypes | Resource | Literal | Undefined)[] ):T;\n\n\t/**\n\t * Set the values of multiple variables to be combined into the results\n\t * query.\n\t *\n\t * @param variables Variables to add values.\n\t * @param values The values to be combined.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variables:string[], values:SupportedNativeTypes[] | SupportedNativeTypes[][] ):T;\n\n\t/**\n\t * Set the values of multiple variables to be combined into the results\n\t * query.\n\t *\n\t * The values are constructed with a function that receives a\n\t * pattern builder.\n\t *\n\t * @param variables Variables to add values.\n\t * @param valuesBuilder Functions that returns the values to be added.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variables:string[], valuesBuilder:( builder:PatternBuilder ) => (SupportedNativeTypes | Resource | Literal | Undefined)[] | (SupportedNativeTypes | Resource | Literal | Undefined)[][] ):T;\n}\n\n\ntype Values = SupportedNativeTypes | Resource | Literal | Undefined;\n\ntype ValuesOrBuilder =\n\t| (SupportedNativeTypes | SupportedNativeTypes[])\n\t| (SupportedNativeTypes[] | SupportedNativeTypes[][])\n\t| (( builder:PatternBuilder ) => Values | Values[])\n\t| (( builder:PatternBuilder ) => Values[] | Values[][])\n\t;\n\nfunction _normalizeVariables( variableOrVariables:string | string[] ):VariableToken[] {\n\tif( Array.isArray( variableOrVariables ) )\n\t\treturn variableOrVariables.map( x => new VariableToken( x ) );\n\n\treturn [ new VariableToken( variableOrVariables ) ];\n}\n\nfunction _normalizeRawValues( valuesOrBuilder:ValuesOrBuilder, iriResolver:IRIResolver2 ):Values[][] {\n\tconst rawValues:Values | (Values | Values[])[] = typeof valuesOrBuilder === \"function\" ?\n\t\t// FIXME\n\t\tvaluesOrBuilder( new PatternBuilder( iriResolver as any ) ) :\n\t\tvaluesOrBuilder;\n\n\n\tif( ! Array.isArray( rawValues ) )\n\t\treturn [ [ rawValues ] ];\n\n\treturn rawValues.map( rawValue => {\n\t\tif( Array.isArray( rawValue ) ) return rawValue;\n\t\treturn [ rawValue ];\n\t} );\n}\n\nfunction createValuesFn<C extends Container2<QueryToken | SubSelectToken>, T extends FinishClause | SubFinishClause>( genericFactory:ClauseFactory<C, T>, container:C ):ValuesClause<T>[ \"values\" ] {\n\treturn ( variableOrVariables:string | string[], valuesOrBuilder:ValuesOrBuilder ) => {\n\t\tconst iriResolver:IRIResolver2 = new IRIResolver2( container.iriResolver );\n\t\tconst values:Values[][] = _normalizeRawValues( valuesOrBuilder, iriResolver );\n\n\t\tconst variables:VariableToken[] = _normalizeVariables( variableOrVariables );\n\n\t\tconst token:ValuesToken = new ValuesToken();\n\t\tvalues.forEach( ( valuesRow, index ) => {\n\t\t\ttoken.addValues( variables[ index ], ...valuesRow.map( convertValue ) );\n\t\t} );\n\n\t\tconst targetToken = cloneElement( container.targetToken, { values: token } );\n\t\tconst newContainer = cloneElement( container, { iriResolver, targetToken } as Partial<C> );\n\t\treturn genericFactory( newContainer, {} );\n\t}\n}\n\n\n/**\n * @todo\n */\nexport const ValuesClause = {\n\tcreate<C extends Container2<QueryToken | SubSelectToken>, T extends FinishClause | SubFinishClause>( genericFactory:ClauseFactory<C, T>, container:C, object:T ):T & ValuesClause<T> {\n\t\treturn Object.assign( object, {\n\t\t\tvalues: createValuesFn( genericFactory, container ),\n\t\t} );\n\t},\n};\n"]}