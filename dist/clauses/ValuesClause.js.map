{"version":3,"sources":["clauses/ValuesClause.ts"],"names":[],"mappings":";;AAEA,mDAAkD;AAClD,uCAA6C;AAE7C,+DAA8D;AAK9D,2CAAiD;AAIjD,qDAAoD;AACpD,yDAAwD;AA6DxD,SAAS,mBAAmB,CAAE,mBAAsC;IACnE,IAAM,SAAS,GAAY,KAAK,CAAC,OAAO,CAAE,mBAAmB,CAAE,CAAC,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAE,mBAAmB,CAAE,CAAC;IAChH,OAAO,SAAS,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,IAAI,6BAAa,CAAE,CAAC,CAAE,EAAtB,CAAsB,CAAE,CAAC;AACrD,CAAC;AAED,SAAS,mBAAmB,CAAE,eAA+B,EAAE,WAAuB,EAAE,QAAgB;IACvG,IAAI,SAAS,GAAkC,OAAO,eAAe,KAAK,UAAU,CAAC,CAAC;QACrF,eAAe,CAAE,iCAAe,CAAC,MAAM,CAAE,WAAW,CAAE,CAAE,CAAC,CAAC;QAC1D,eAAe,CAAC;IAGjB,IAAI,CAAE,KAAK,CAAC,OAAO,CAAE,SAAS,CAAE;QAC/B,OAAO,CAAE,CAAE,SAAS,CAAE,CAAE,CAAC;IAE1B,IAAI,QAAQ;QACX,SAAS,CAAC,GAAG,CAAE,UAAA,KAAK,IAAI,OAAA,CAAE,KAAK,CAAE,EAAT,CAAS,CAAE,CAAC;IAIrC,IAAI,SAAS,CAAC,IAAI,CAAE,KAAK,CAAC,OAAO,CAAE;QAClC,OAAO,SAAuB,CAAC;IAEhC,OAAO,CAAE,SAAqB,CAAE,CAAC;AAClC,CAAC;AAaD,SAAS,cAAc,CAA4E,cAA4B,EAAE,SAAW;IAC3I,OAAO,UAAE,mBAAsC,EAAE,eAA+B;QAC/E,IAAM,KAAK,GAAe,IAAI,yBAAW,EAAE,CAAC;QAE5C,IAAM,SAAS,GAAmB,mBAAmB,CAAE,mBAAmB,CAAE,CAAC;QAC7E,KAAK,CAAC,YAAY,OAAlB,KAAK,EAAkB,SAAS,EAAG;QAEnC,IAAM,QAAQ,GAAW,CAAE,KAAK,CAAC,OAAO,CAAE,mBAAmB,CAAE,CAAC;QAChE,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;QACzE,IAAM,MAAM,GAAc,mBAAmB,CAAE,eAAe,EAAE,WAAW,EAAE,QAAQ,CAAE,CAAC;QACxF,MAAM,CAAC,OAAO,CAAE,UAAE,SAAS,IAAM,OAAA,KAAK,CAAC,SAAS,OAAf,KAAK,EAAe,SAAS,CAAC,GAAG,CAAE,oBAAY,CAAE,GAAjD,CAAmD,CAAE,CAAC;QAEvF,IAAM,WAAW,GAAG,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAE,CAAC;QAC7E,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;QAC3F,OAAO,cAAc,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IAC3C,CAAC,CAAA;AACF,CAAC;AAMY,QAAA,YAAY,GAgBrB;IACH,UAAU,EAAV,UAAwG,cAA4B,EAAE,SAAW,EAAE,MAAQ;QAC1J,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAC7B,MAAM,EAAE,cAAc,CAAE,cAAc,EAAE,SAAS,CAAE;SACnD,CAAE,CAAC;IACL,CAAC;CACD,CAAC","file":"ValuesClause.js","sourcesContent":["import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\nimport { IRIResolver } from \"../data/IRIResolver\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { PatternBuilder2 } from \"../patterns/PatternBuilder2\";\nimport { SupportedNativeTypes } from \"../patterns/SupportedNativeTypes\";\nimport { Literal } from \"../patterns/triplePatterns/Literal\";\nimport { Resource } from \"../patterns/triplePatterns/Resource\";\nimport { Undefined } from \"../patterns/Undefined\";\nimport { convertValue } from \"../patterns/utils\";\n\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\nimport { ValuesToken } from \"../tokens/ValuesToken\";\nimport { VariableToken } from \"../tokens/VariableToken\";\n\nimport { FinishClause } from \"./FinishClause\";\n\n\nexport interface ValuesClause<T extends FinishClause> {\n\t/**\n\t * Set the values of a variable to be combined into the results query.\n\t *\n\t * @param variable Variable to add values.\n\t * @param values The values to be combined.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variable:string, values:SupportedNativeTypes | SupportedNativeTypes[] ):T;\n\n\t/**\n\t * Set the values of a variable to be combined into the results query.\n\t *\n\t * The values are constructed with a function that receives a\n\t * pattern builder.\n\t *\n\t * @param variable Variable to add values.\n\t * @param valuesBuilder Functions that returns the values to be added.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variable:string, valuesBuilder:( builder:PatternBuilder2 ) => (SupportedNativeTypes | Resource | Literal | Undefined) | (SupportedNativeTypes | Resource | Literal | Undefined)[] ):T;\n\n\t/**\n\t * Set the values of multiple variables to be combined into the results\n\t * query.\n\t *\n\t * @param variables Variables to add values.\n\t * @param values The values to be combined.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variables:string[], values:SupportedNativeTypes[] | SupportedNativeTypes[][] ):T;\n\n\t/**\n\t * Set the values of multiple variables to be combined into the results\n\t * query.\n\t *\n\t * The values are constructed with a function that receives a\n\t * pattern builder.\n\t *\n\t * @param variables Variables to add values.\n\t * @param valuesBuilder Functions that returns the values to be added.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variables:string[], valuesBuilder:( builder:PatternBuilder2 ) => (SupportedNativeTypes | Resource | Literal | Undefined)[] | (SupportedNativeTypes | Resource | Literal | Undefined)[][] ):T;\n}\n\n\ntype Values = SupportedNativeTypes | Resource | Literal | \"UNDEF\";\n\ntype ValuesOrBuilder =\n\t| (SupportedNativeTypes | SupportedNativeTypes[])\n\t| (SupportedNativeTypes[] | SupportedNativeTypes[][])\n\t| (( builder:PatternBuilder2 ) => Values | Values[])\n\t| (( builder:PatternBuilder2 ) => Values[] | Values[][])\n\t;\n\nfunction _normalizeVariables( variableOrVariables:string | string [] ):VariableToken[] {\n\tconst variables:string[] = Array.isArray( variableOrVariables ) ? variableOrVariables : [ variableOrVariables ];\n\treturn variables.map( x => new VariableToken( x ) );\n}\n\nfunction _normalizeRawValues( valuesOrBuilder:ValuesOrBuilder, iriResolver:IRIResolver, isSingle:boolean ):Values[][] {\n\tlet rawValues:Values | (Values | Values[])[] = typeof valuesOrBuilder === \"function\" ?\n\t\tvaluesOrBuilder( PatternBuilder2.create( iriResolver ) ) :\n\t\tvaluesOrBuilder;\n\n\t// When single variable\n\tif( ! Array.isArray( rawValues ) )\n\t\treturn [ [ rawValues ] ];\n\n\tif( isSingle )\n\t\trawValues.map( value => [ value ] );\n\n\n\t// When multiple variables\n\tif( rawValues.some( Array.isArray ) )\n\t\treturn rawValues as Values[][];\n\n\treturn [ rawValues as Values[] ];\n}\n\n/**\n * Function that creates the {@link ValuesClause.values} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link ValuesClause} receives.\n * @param container The container with the query data of the statement.\n *\n * @returns The {@link ValuesClause.values} function.\n *\n * @private\n */\nfunction createValuesFn<C extends Container<QueryToken | SubSelectToken>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C ):ValuesClause<T>[ \"values\" ] {\n\treturn ( variableOrVariables:string | string [], valuesOrBuilder:ValuesOrBuilder ) => {\n\t\tconst token:ValuesToken = new ValuesToken();\n\n\t\tconst variables:VariableToken[] = _normalizeVariables( variableOrVariables );\n\t\ttoken.addVariables( ...variables );\n\n\t\tconst isSingle:boolean = ! Array.isArray( variableOrVariables );\n\t\tconst iriResolver:IRIResolver = new IRIResolver( container.iriResolver );\n\t\tconst values:Values[][] = _normalizeRawValues( valuesOrBuilder, iriResolver, isSingle );\n\t\tvalues.forEach( ( valuesRow ) => token.addValues( ...valuesRow.map( convertValue ) ) );\n\n\t\tconst targetToken = cloneElement( container.targetToken, { values: token } );\n\t\tconst newContainer = cloneElement( container, { iriResolver, targetToken } as Partial<C> );\n\t\treturn genericFactory( newContainer, {} );\n\t}\n}\n\n\n/**\n * Constant with the utils for {@link ValuesClause} objects.\n */\nexport const ValuesClause:{\n\t/**\n\t * Factory function that allows to crete a {@link ValuesClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link ValuesClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link ValuesClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link ValuesClause} statement.\n\t *\n\t * @return The {@link ValuesClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & ValuesClause<T>\n} = {\n\tcreateFrom<C extends Container<QueryToken | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & ValuesClause<T> {\n\t\treturn Object.assign( object, {\n\t\t\tvalues: createValuesFn( genericFactory, container ),\n\t\t} );\n\t},\n};\n"]}