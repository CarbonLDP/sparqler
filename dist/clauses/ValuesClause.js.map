{"version":3,"sources":["clauses/ValuesClause.ts"],"names":[],"mappings":";;AAEA,qDAAoD;AACpD,uCAA6C;AAE7C,+DAA8D;AAM9D,2CAAiD;AAIjD,qDAAoD;AACpD,yDAAwD;AA6DxD,SAAS,mBAAmB,CAAE,mBAA6D;IAC1F,IAAM,SAAS,GAAG,KAAK,CAAC,OAAO,CAAE,mBAAmB,CAAE,CAAC,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAE,mBAAmB,CAAE,CAAC;IAEvG,OAAO,SAAS,CAAC,GAAG,CAAE,UAAA,CAAC;QACtB,IAAI,OAAO,CAAC,KAAK,QAAQ;YAAG,OAAO,IAAI,6BAAa,CAAE,CAAC,CAAE,CAAC;QAC1D,OAAO,CAAC,CAAC,UAAU,EAAE,CAAC;IACvB,CAAC,CAAE,CAAC;AACL,CAAC;AAED,SAAS,mBAAmB,CAAE,eAA+B,EAAE,WAAwB,EAAE,QAAgB;IACxG,IAAI,SAAS,GAAkC,OAAO,eAAe,KAAK,UAAU,CAAC,CAAC;QACrF,eAAe,CAAE,iCAAe,CAAC,MAAM,CAAE,WAAW,CAAE,CAAE,CAAC,CAAC;QAC1D,eAAe,CAAC;IAGjB,IAAI,CAAE,KAAK,CAAC,OAAO,CAAE,SAAS,CAAE;QAC/B,OAAO,CAAE,CAAE,SAAS,CAAE,CAAE,CAAC;IAE1B,IAAI,QAAQ;QACX,SAAS,CAAC,GAAG,CAAE,UAAA,KAAK,IAAI,OAAA,CAAE,KAAK,CAAE,EAAT,CAAS,CAAE,CAAC;IAIrC,IAAI,SAAS,CAAC,IAAI,CAAE,KAAK,CAAC,OAAO,CAAE;QAClC,OAAO,SAAuB,CAAC;IAEhC,OAAO,CAAE,SAAqB,CAAE,CAAC;AAClC,CAAC;AAED,SAAS,cAAc,CAA6E,cAA4B,EAAE,SAAW;IAC5I,OAAO,UAAE,mBAA6D,EAAE,eAA+B;QACtG,IAAM,WAAW,GAAgB,IAAI,2BAAY,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;QAE3E,IAAM,QAAQ,GAAW,CAAE,KAAK,CAAC,OAAO,CAAE,mBAAmB,CAAE,CAAC;QAChE,IAAM,MAAM,GAAc,mBAAmB,CAAE,eAAe,EAAE,WAAW,EAAE,QAAQ,CAAE,CAAC;QACxF,IAAM,SAAS,GAAmB,mBAAmB,CAAE,mBAAmB,CAAE,CAAC;QAE7E,IAAM,KAAK,GAAe,IAAI,yBAAW,EAAE,CAAC;QAC5C,MAAM,CAAC,OAAO,CAAE,UAAE,SAAS,EAAE,KAAK;YACjC,KAAK,CAAC,SAAS,OAAf,KAAK,GAAY,SAAS,CAAE,KAAK,CAAE,SAAK,SAAS,CAAC,GAAG,CAAE,oBAAY,CAAE,GAAG;QACzE,CAAC,CAAE,CAAC;QAEJ,IAAM,WAAW,GAAG,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAE,CAAC;QAC7E,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;QAC3F,OAAO,cAAc,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IAC3C,CAAC,CAAA;AACF,CAAC;AAMY,QAAA,YAAY,GAErB;IACH,UAAU,EAAV,UAAuF,cAA4B,EAAE,SAAW,EAAE,MAAQ;QACzI,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAC7B,MAAM,EAAE,cAAc,CAAE,cAAc,EAAE,SAAS,CAAE;SACnD,CAAE,CAAC;IACL,CAAC;CACD,CAAC","file":"ValuesClause.js","sourcesContent":["import { Container2 } from \"../data/Container2\";\nimport { Factory } from \"../data/Factory\";\nimport { IRIResolver2 } from \"../data/IRIResolver2\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { PatternBuilder2 } from \"../patterns/PatternBuilder2\";\nimport { SupportedNativeTypes } from \"../patterns/SupportedNativeTypes\";\nimport { Literal } from \"../patterns/triplePatterns/Literal\";\nimport { Resource } from \"../patterns/triplePatterns/Resource\";\nimport { Variable } from \"../patterns/triplePatterns/Variable\";\nimport { Undefined } from \"../patterns/Undefined\";\nimport { convertValue } from \"../patterns/utils\";\n\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\nimport { ValuesToken } from \"../tokens/ValuesToken\";\nimport { VariableToken } from \"../tokens/VariableToken\";\n\nimport { FinishClause } from \"./FinishClause\";\n\n\nexport interface ValuesClause<T extends FinishClause> {\n\t/**\n\t * Set the values of a variable to be combined into the results query.\n\t *\n\t * @param variable Variable to add values.\n\t * @param values The values to be combined.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variable:string | Variable, values:SupportedNativeTypes | SupportedNativeTypes[] ):T;\n\n\t/**\n\t * Set the values of a variable to be combined into the results query.\n\t *\n\t * The values are constructed with a function that receives a\n\t * pattern builder.\n\t *\n\t * @param variable Variable to add values.\n\t * @param valuesBuilder Functions that returns the values to be added.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variable:string | Variable, valuesBuilder:( builder:PatternBuilder2 ) => (SupportedNativeTypes | Resource | Literal | Undefined) | (SupportedNativeTypes | Resource | Literal | Undefined)[] ):T;\n\n\t/**\n\t * Set the values of multiple variables to be combined into the results\n\t * query.\n\t *\n\t * @param variables Variables to add values.\n\t * @param values The values to be combined.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variables:(string | Variable)[], values:SupportedNativeTypes[] | SupportedNativeTypes[][] ):T;\n\n\t/**\n\t * Set the values of multiple variables to be combined into the results\n\t * query.\n\t *\n\t * The values are constructed with a function that receives a\n\t * pattern builder.\n\t *\n\t * @param variables Variables to add values.\n\t * @param valuesBuilder Functions that returns the values to be added.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variables:(string | Variable)[], valuesBuilder:( builder:PatternBuilder2 ) => (SupportedNativeTypes | Resource | Literal | Undefined)[] | (SupportedNativeTypes | Resource | Literal | Undefined)[][] ):T;\n}\n\n\ntype Values = SupportedNativeTypes | Resource | Literal | \"UNDEF\";\n\ntype ValuesOrBuilder =\n\t| (SupportedNativeTypes | SupportedNativeTypes[])\n\t| (SupportedNativeTypes[] | SupportedNativeTypes[][])\n\t| (( builder:PatternBuilder2 ) => Values | Values[])\n\t| (( builder:PatternBuilder2 ) => Values[] | Values[][])\n\t;\n\nfunction _normalizeVariables( variableOrVariables:string | Variable | (string | Variable)[] ):VariableToken[] {\n\tconst variables = Array.isArray( variableOrVariables ) ? variableOrVariables : [ variableOrVariables ];\n\n\treturn variables.map( x => {\n\t\tif( typeof x === \"string\" ) return new VariableToken( x );\n\t\treturn x.getSubject();\n\t} );\n}\n\nfunction _normalizeRawValues( valuesOrBuilder:ValuesOrBuilder, iriResolver:IRIResolver2, isSingle:boolean ):Values[][] {\n\tlet rawValues:Values | (Values | Values[])[] = typeof valuesOrBuilder === \"function\" ?\n\t\tvaluesOrBuilder( PatternBuilder2.create( iriResolver ) ) :\n\t\tvaluesOrBuilder;\n\n\t// When single variable\n\tif( ! Array.isArray( rawValues ) )\n\t\treturn [ [ rawValues ] ];\n\n\tif( isSingle )\n\t\trawValues.map( value => [ value ] );\n\n\n\t// When multiple variables\n\tif( rawValues.some( Array.isArray ) )\n\t\treturn rawValues as Values[][];\n\n\treturn [ rawValues as Values[] ];\n}\n\nfunction createValuesFn<C extends Container2<QueryToken | SubSelectToken>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C ):ValuesClause<T>[ \"values\" ] {\n\treturn ( variableOrVariables:string | Variable | (string | Variable)[], valuesOrBuilder:ValuesOrBuilder ) => {\n\t\tconst iriResolver:IRIResolver2 = new IRIResolver2( container.iriResolver );\n\n\t\tconst isSingle:boolean = ! Array.isArray( variableOrVariables );\n\t\tconst values:Values[][] = _normalizeRawValues( valuesOrBuilder, iriResolver, isSingle );\n\t\tconst variables:VariableToken[] = _normalizeVariables( variableOrVariables );\n\n\t\tconst token:ValuesToken = new ValuesToken();\n\t\tvalues.forEach( ( valuesRow, index ) => {\n\t\t\ttoken.addValues( variables[ index ], ...valuesRow.map( convertValue ) );\n\t\t} );\n\n\t\tconst targetToken = cloneElement( container.targetToken, { values: token } );\n\t\tconst newContainer = cloneElement( container, { iriResolver, targetToken } as Partial<C> );\n\t\treturn genericFactory( newContainer, {} );\n\t}\n}\n\n\n/**\n * @todo\n */\nexport const ValuesClause:{\n\tcreateFrom<C extends Container2<QueryToken | SubSelectToken>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C, object:T ):T & ValuesClause<T>\n} = {\n\tcreateFrom<C extends Container2<QueryToken | SubSelectToken>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C, object:T ):T & ValuesClause<T> {\n\t\treturn Object.assign( object, {\n\t\t\tvalues: createValuesFn( genericFactory, container ),\n\t\t} );\n\t},\n};\n"]}