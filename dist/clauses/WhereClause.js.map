{"version":3,"sources":["clauses/WhereClause.ts"],"names":[],"mappings":";;AAEA,mDAAkD;AAClD,uCAA6C;AAG7C,6DAA4D;AAK5D,mDAAkD;AAGlD,6CAA4C;AAuB5C,SAAS,YAAY,CAAE,WAAuB,EAAE,eAAiE;IAChH,IAAM,iBAAiB,GAAuB,eAAe,CAAE,+BAAc,CAAC,MAAM,CAAE,WAAW,CAAE,CAAE,CAAC;IACtG,IAAM,QAAQ,GAAa,KAAK,CAAC,OAAO,CAAE,iBAAiB,CAAE,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAE,iBAAiB,CAAE,CAAC;IAE1G,OAAO,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,EAAd,CAAc,CAAE,CAAC;AAC5C,CAAC;AAaD,SAAS,UAAU,CAA6E,cAA4B,EAAE,SAAW;IACxI,OAAO,UAAE,eAAiE;;QACzE,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;QACzE,IAAM,QAAQ,GAAkB,YAAY,CAAE,WAAW,EAAE,eAAe,CAAE,CAAC;QAE7E,IAAM,KAAK,GAAG,CAAA,KAAA,oBAAY,CAAE,SAAS,CAAC,WAAW,CAAC,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,uBAAU,EAAE,EAAE,CAAE,CAAA,CAC1F,UAAU,WAAK,QAAQ,CAAE,CAAC;QAE5B,IAAM,UAAU,GAAc,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,WAAW,EAAE,KAAK,EAAE,CAAE,CAAC;QAC5F,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAE,WAAW,EAAE,UAAU,EAAgB,CAAE,CAAC;QAEvG,IAAM,WAAW,GAAkB,yBAAW,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;QAC9F,OAAO,cAAc,CAAE,YAAY,EAAE,WAAW,CAAE,CAAC;IACpD,CAAC,CAAC;AACH,CAAC;AAMY,QAAA,WAAW,GAgBpB;IACH,UAAU,EAAV,UAAyG,cAA2C,EAAE,SAAW,EAAE,MAAQ;QAC1K,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAC7B,KAAK,EAAE,UAAU,CAAE,cAAc,EAAE,SAAS,CAAE;SAC9C,CAAE,CAAC;IACL,CAAC;CACD,CAAC","file":"WhereClause.js","sourcesContent":["import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\nimport { IRIResolver } from \"../data/IRIResolver\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { Pattern } from \"../patterns/Pattern\";\nimport { PatternBuilder } from \"../patterns/PatternBuilder\";\n\nimport { PatternToken } from \"../tokens/PatternToken\";\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { WhereToken } from \"../tokens/WhereToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { GroupClause } from \"./GroupClause\";\n\n\n/**\n * Interface with the methods available to make a WHERE statement.\n */\nexport interface WhereClause<T extends FinishClause> {\n\t/**\n\t * Specifies the graph patterns the query should match to retrieve\n\t * the solutions results.\n\t *\n\t * This pattern are created by a pattern constructor function that\n\t * receives a {@link PatternBuilder} which is a class that exposes\n\t * the possible elements and configurations the patterns chan have.\n\t *\n\t * @param patternFunction Function that retrieves a pattern or an\n\t * array of patterns to match.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\twhere( patternFunction:( builder:PatternBuilder ) => Pattern | Pattern[] ):GroupClause<T> & T;\n}\n\n\nfunction _getPatterns( iriResolver:IRIResolver, patternFunction:( builder:PatternBuilder ) => Pattern | Pattern[] ):PatternToken[] {\n\tconst patternOrPatterns:Pattern | Pattern[] = patternFunction( PatternBuilder.create( iriResolver ) );\n\tconst patterns:Pattern[] = Array.isArray( patternOrPatterns ) ? patternOrPatterns : [ patternOrPatterns ];\n\n\treturn patterns.map( x => x.getPattern() );\n}\n\n/**\n * Function that creates the {@link WhereClause.where} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link WhereClause} receives.\n * @param container The container with the query data of the statement.\n *\n * @returns The {@link WhereClause.where} function.\n *\n * @private\n */\nfunction getWhereFn<C extends Container<QueryToken<QueryClauseToken>>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C ):WhereClause<T>[ \"where\" ] {\n\treturn ( patternFunction:( builder:PatternBuilder ) => Pattern | Pattern[] ) => {\n\t\tconst iriResolver:IRIResolver = new IRIResolver( container.iriResolver );\n\t\tconst patterns:PatternToken[] = _getPatterns( iriResolver, patternFunction );\n\n\t\tconst query = cloneElement( container.targetToken.queryClause, { where: new WhereToken() } )\n\t\t\t.addPattern( ...patterns );\n\n\t\tconst queryToken:QueryToken = cloneElement( container.targetToken, { queryClause: query } );\n\t\tconst newContainer = cloneElement( container, { iriResolver, targetToken: queryToken } as Partial<C> );\n\n\t\tconst groupClause:GroupClause<T> = GroupClause.createFrom( genericFactory, newContainer, {} );\n\t\treturn genericFactory( newContainer, groupClause );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link WhereClause} objects.\n */\nexport const WhereClause:{\n\t/**\n\t * Factory function that allows to crete a {@link WhereClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link WhereClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link WhereClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link WhereClause} statement.\n\t *\n\t * @return The {@link WhereClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken>>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & WhereClause<T>\n} = {\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken>>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & WhereClause<T> {\n\t\treturn Object.assign( object, {\n\t\t\twhere: getWhereFn( genericFactory, container ),\n\t\t} );\n\t},\n};\n"]}