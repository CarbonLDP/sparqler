{"version":3,"sources":["clauses/WhereClause.ts"],"names":[],"mappings":";;AAAA,oDAAmD;AAGnD,6DAA4D;AAG5D,mDAAkD;AAIlD,6CAA4C;AAE5C,iCAAuC;AAuBvC,oBAA+E,cAAkC,EAAE,SAAW;IAC7H,OAAO,UAAE,eAA4E;;QACpF,IAAM,WAAW,GAAgB,IAAI,2BAAY,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;QAC3E,IAAM,QAAQ,GAAiC,eAAe,CAAC,IAAI,CAAE,KAAK,CAAC,EAAE,IAAI,+BAAc,CAAE,WAAkB,CAAE,CAAE,CAAC;QAGxH,IAAM,KAAK,GAAG,CAAA,KAAA,oBAAY,CAAE,SAAS,CAAC,WAAW,CAAC,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,uBAAU,EAAE,EAAE,CAAE,CAAA,CAC1F,UAAU,WAAK,QAAe,CAAE,CAAC;QAEnC,IAAM,UAAU,GAAc,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,WAAW,EAAE,KAAK,EAAE,CAAE,CAAC;QAC5F,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE,EAAE,WAAW,EAAE,UAAU,EAAgB,CAAE,CAAC;QAE1F,IAAM,WAAW,GAAkB,yBAAW,CAAC,MAAM,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;QAC1F,OAAO,cAAc,CAAE,YAAY,EAAE,WAAW,CAAE,CAAC;IACpD,CAAC,CAAC;AACH,CAAC;AAMY,QAAA,WAAW,GAAG;IAC1B,MAAM,EAAN,UAAoF,cAAiD,EAAE,SAAW,EAAE,MAAQ;QAC3J,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAC7B,KAAK,EAAE,UAAU,CAAE,cAAc,EAAE,SAAS,CAAE;SAC9C,CAAE,CAAC;IACL,CAAC;CACD,CAAC","file":"WhereClause.js","sourcesContent":["import { IRIResolver2 } from \"../iri/IRIResolver2\";\n\nimport { GraphPattern } from \"../patterns/interfaces\";\nimport { PatternBuilder } from \"../patterns/PatternBuilder\";\n\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { WhereToken } from \"../tokens/WhereToken\";\n\nimport { ClauseFactory } from \"./ClauseFactory\";\nimport { Container2 } from \"./Container2\";\nimport { GroupClause } from \"./GroupClause\";\nimport { FinishClause } from \"./FinishClause\";\nimport { cloneElement } from \"./utils\";\n\n\nexport interface WhereClause<T extends FinishClause> {\n\t/**\n\t * Specifies the graph patterns the query should match to retrieve\n\t * the solutions results.\n\t *\n\t * This pattern are created by a pattern constructor function that\n\t * receives a {@link PatternBuilder} which is a class that exposes\n\t * the possible elements and configurations the patterns chan have.\n\t *\n\t * @param patternFunction Function that retrieves a pattern or an\n\t * array of patterns to match.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\twhere( patternFunction:( builder:PatternBuilder ) => GraphPattern | GraphPattern[] ):GroupClause<T> & T;\n}\n\n\n/**\n * @todo\n */\nfunction getWhereFn<C extends Container2<QueryToken>, T extends FinishClause>( genericFactory:ClauseFactory<C, T>, container:C ):WhereClause<T>[ \"where\" ] {\n\treturn ( patternFunction:( builder:PatternBuilder ) => GraphPattern | GraphPattern[ ] ) => {\n\t\tconst iriResolver:IRIResolver2 = new IRIResolver2( container.iriResolver );\n\t\tconst patterns:GraphPattern | GraphPattern[] = patternFunction.call( void 0, new PatternBuilder( iriResolver as any ) );\n\n\t\t// FIXME\n\t\tconst query = cloneElement( container.targetToken.queryClause, { where: new WhereToken() } )\n\t\t\t.addPattern( ...patterns as any );\n\n\t\tconst queryToken:QueryToken = cloneElement( container.targetToken, { queryClause: query } );\n\t\tconst newContainer = cloneElement( container, { targetToken: queryToken } as Partial<C> );\n\n\t\tconst groupClause:GroupClause<T> = GroupClause.create( genericFactory, newContainer, {} );\n\t\treturn genericFactory( newContainer, groupClause );\n\t};\n}\n\n\n/**\n * @todo\n */\nexport const WhereClause = {\n\tcreate<C extends Container2<QueryToken>, T extends FinishClause, O extends object>( genericFactory:ClauseFactory<typeof container, T>, container:C, object:O ):O & WhereClause<T> {\n\t\treturn Object.assign( object, {\n\t\t\twhere: getWhereFn( genericFactory, container ),\n\t\t} );\n\t},\n};\n"]}