{"version":3,"sources":["clauses/decorators/finish.ts"],"names":[],"mappings":";;AAIA,kDAeiC;AACjC,yCAKwB;AAMxB,SAAS,eAAe;IAEvB,IAAM,MAAM,GAAW,IAAI,CAAC,OAAO;SACjC,MAAM,CAAE,UAAA,KAAK,IAAI,OAAA,KAAK,KAAK,cAAK,EAAf,CAAe,CAAE,CAAC;IAErC,IAAM,SAAS,GAAW,CAAE,eAAM,CAAE,CAAC;IACrC,IAAI,UAAkB,CAAC;IAEvB,KAAK,IAAI,KAAK,GAAU,CAAC,EAAE,KAAK,GAAS,MAAM,CAAE,KAAK,CAAE,EAAE,KAAK,IAAI,SAAS,CAAC,OAAO,CAAE,KAAK,CAAE,KAAK,CAAE,CAAC,EAAE,EAAG,KAAK,EAAE,KAAK,GAAG,MAAM,CAAE,KAAK,CAAE,EAAG;QAE1I,IAAI,KAAK,KAAK,eAAM,EAAG;YACtB,IAAM,SAAS,GAAS,MAAM,CAAE,KAAK,GAAG,CAAC,CAAE,CAAC;YAC5C,IAAI,CAAE,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,GAAG,CAAE,SAAS,CAAE,OAAO,CAAE,CAAE,EAAG;gBAC/D,MAAM,CAAC,MAAM,CAAE,KAAK,EAAE,CAAC,CAAE,CAAC;gBAC1B,EAAG,KAAK,CAAC;aACT;SACD;aAGI,IAAI,KAAK,KAAK,aAAI,EAAG;YACzB,UAAU,GAAG,MAAM,CAAC,MAAM,CAAE,KAAK,EAAE,CAAC,CAAE,CAAC;YACvC,EAAG,KAAK,CAAC;SACT;KACD;IAGD,IAAI,UAAU,EAAG;QAEhB,IAAM,UAAU,GAAU,UAAU,CAAC,MAAM,CAAE,UAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS;YAC1E,IAAI,SAAS,GAAS,SAAS,CAAE,KAAK,GAAG,CAAC,CAAE,CAAC;YAC7C,OAAO,GAAG,GAAG,KAAK,CAAC,aAAa,CAAE,oBAAW,CAAC,MAAM,EAAE,SAAS,CAAE,CAAC;QACnE,CAAC,EAAE,EAAE,CAAE,GAAG,IAAI,CAAC;QACf,MAAM,CAAC,OAAO,CAAE,IAAI,sBAAa,CAAE,UAAU,CAAE,CAAE,CAAC;KAClD;IAED,OAAO,MAAM,CAAC,MAAM,CAAE,UAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS;QACnD,IAAI,SAAS,GAAS,SAAS,CAAE,KAAK,GAAG,CAAC,CAAE,CAAC;QAE7C,IAAI,SAAS,KAAK,wBAAe;YAAG,SAAS,GAAG,SAAS,CAAE,KAAK,GAAG,CAAC,CAAE,CAAC;QACvE,OAAO,GAAG,GAAG,KAAK,CAAC,aAAa,CAAE,oBAAW,CAAC,OAAO,EAAE,SAAS,CAAE,CAAC;IACpE,CAAC,EAAE,EAAE,CAAE,CAAC;AACT,CAAC;AAMD,SAAS,cAAc;IACtB,IAAM,KAAK,GAAyF,EAAE,CAAC;IACvG,IAAI,MAAM,GAAuF;QAChG,KAAK,EAAE,IAAI;QACX,WAAW,EAAE,CAAC;QACd,OAAO,EAAE,CAAC;QACV,QAAQ,EAAE,CAAC;QACX,MAAM,EAAE,CAAC;KACT,CAAC;IAEF,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAE,UAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM;QACtD,IAAI,SAAS,GAAS,MAAM,CAAE,KAAK,GAAG,CAAC,CAAE,CAAC;QAC1C,IAAI,WAAW,GAAU,KAAK,CAAC,aAAa,CAAE,oBAAW,CAAC,MAAM,EAAE,SAAS,CAAE,CAAC;QAG9E,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAG;YACzB,MAAM,CAAC,OAAO,IAAI,WAAW,CAAC,MAAM,CAAC;YACrC,IAAI,WAAW,CAAC,QAAQ,CAAE,GAAG,CAAE;gBAAG,MAAM,CAAC,MAAM,EAAG,CAAC;SACnD;aAAM,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAG;YAChC,MAAM,CAAC,QAAQ,IAAI,WAAW,CAAC,MAAM,CAAC;YACtC,IAAI,WAAW,CAAC,QAAQ,CAAE,GAAG,CAAE;gBAAG,MAAM,CAAC,MAAM,EAAG,CAAC;SACnD;QAGD,IAAI,CAAE,yBAAyB,EAAE,sBAAa,EAAE,wBAAe,CAAE,CAAC,OAAO,CAAE,KAAK,CAAE,KAAK,CAAE,CAAC,EAAG;YAG5F,KAAK,CAAC,IAAI,CAAE,MAAM,CAAE,CAAC;YACrB,MAAM,GAAG;gBACR,KAAK,EAAE,KAAK;gBACZ,WAAW,EAAE,MAAM,CAAC,WAAW,GAAG,CAAC;gBACnC,OAAO,EAAE,CAAC;gBACV,QAAQ,EAAE,CAAC;gBACX,MAAM,EAAE,KAAK,KAAK,yBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,sBAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACxE,CAAC;SAEF;aAAM,IAAI,CAAE,yBAAyB,CAAE,CAAC,OAAO,CAAE,KAAK,CAAE,KAAK,CAAE,CAAC,EAAG;YACnE,IAAI,SAAS,IAAI,CAAE,CAAE,SAAS,YAAY,sBAAa,CAAE,EAAG;gBAG3D,IAAI,MAAM,GAAG,MAAM,CAAC;gBACpB,OAAO,CAAE,yBAAyB,EAAE,sBAAa,EAAE,wBAAe,CAAE,CAAC,OAAO,CAAE,MAAM,CAAC,KAAK,CAAE,KAAK,CAAE,CAAC;oBACnG,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;gBACtB,KAAK,CAAC,IAAI,CAAE,MAAM,CAAE,CAAC;gBAGrB,MAAM,GAAG;oBACR,KAAK,EAAE,KAAK;oBACZ,WAAW,EAAE,MAAM,CAAC,WAAW,GAAG,CAAC;oBACnC,OAAO,EAAE,CAAC;oBACV,QAAQ,EAAE,CAAC;oBACX,MAAM,EAAE,CAAC;iBACT,CAAC;aACF;SAED;aAAM,IAAI,CAAE,+BAA+B,EAAE,gCAAuB,EAAE,yBAAgB,CAAE,CAAC,OAAO,CAAE,KAAK,CAAE,KAAK,CAAE,CAAC,EAAG;YAGpH,IAAI,MAAM,GAAG,MAAM,CAAC;YACpB,OAAO,CAAE,yBAAyB,EAAE,sBAAa,EAAE,wBAAe,EAAE,yBAAgB,EAAE,uBAAc,CAAE,CAAC,OAAO,CAAE,MAAM,CAAC,KAAK,CAAE,KAAK,CAAE,CAAC;gBACrI,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;YACtB,KAAK,CAAC,IAAI,CAAE,MAAM,CAAE,CAAC;YAGrB,IAAI,KAAK,KAAK,+BAAsB,EAAG;gBACtC,MAAM,GAAG;oBACR,KAAK,EAAE,KAAK;oBACZ,WAAW,EAAE,MAAM,CAAC,WAAW,GAAG,MAAM,CAAC,OAAO;oBAChD,OAAO,EAAE,MAAM,CAAC,OAAO;oBACvB,QAAQ,EAAE,CAAC;oBACX,MAAM,EAAE,CAAC;iBACT,CAAC;aAGF;iBAAM,IAAI,KAAK,KAAK,gCAAuB,EAAG;gBAC9C,MAAM,GAAG;oBACR,KAAK,EAAE,KAAK;oBACZ,WAAW,EAAE,MAAM,CAAC,WAAW,GAAG,MAAM,CAAC,OAAO,GAAG,MAAM,CAAC,QAAQ;oBAClE,OAAO,EAAE,MAAM,CAAC,OAAO;oBACvB,QAAQ,EAAE,MAAM,CAAC,QAAQ;oBACzB,MAAM,EAAE,CAAC;iBACT,CAAC;aACF;SAGD;aAAM,IAAI,KAAK,KAAK,gCAAuB,EAAG;YAC9C,OAAO,MAAM,CAAC,KAAK,KAAK,yBAAgB;gBAAG,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;YAChE,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;YAClB,MAAM,CAAC,OAAO,GAAG,CAAC,CAAC;YACnB,MAAM,CAAC,QAAQ,GAAG,CAAC,CAAC;SACpB;QAED,IAAI,SAAS,KAAK,0BAAiB,EAAG;YACrC,OAAO,MAAM,CAAC,KAAK,KAAK,yBAAgB;gBAAG,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;YAChE,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;SACrB;aAAM,IAAI,SAAS,KAAK,uBAAc,EAAG;YACzC,OAAO,MAAM,CAAC,KAAK,KAAK,sBAAa;gBAAG,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;YAC7D,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;SACrB;aAAM,IAAI,SAAS,KAAK,yBAAgB,EAAG;YAC3C,OAAO,MAAM,CAAC,KAAK,KAAK,wBAAe;gBAAG,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;YAC/D,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;SACrB;QAED,IAAI,WAAW,CAAC,QAAQ,CAAE,IAAI,CAAE,EAAG;YAClC,WAAW,GAAG,WAAW,GAAG,GAAG,CAAC,MAAM,CAAE,MAAM,CAAC,WAAW,CAAE,CAAC;SAC7D;QAED,OAAO,GAAG,GAAG,WAAW,CAAC;IAC1B,CAAC,EAAE,EAAE,CAAE,CAAC;AACT,CAAC;AAUD,SAAgB,eAAe,CAAoB,SAAiC,EAAE,MAAQ;IAC7F,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;QAC7B,eAAe,EAAE,eAAe,CAAC,IAAI,CAAE,SAAS,CAAE;QAClD,cAAc,EAAE,cAAc,CAAC,IAAI,CAAE,SAAS,CAAE;QAChD,QAAQ,EAAE,cAAc,CAAC,IAAI,CAAE,SAAS,CAAE;KAC1C,CAAE,CAAC;AACL,CAAC;AAND,0CAMC","file":"finish.js","sourcesContent":["import {\n\tContainer,\n\tFinishClause,\n} from \"./..\";\nimport {\n\tBASE,\n\tCLOSE_MULTI_BLOCK,\n\tCLOSE_MULTI_BN,\n\tCLOSE_MULTI_LIST,\n\tEMPTY_SEPARATOR,\n\tGRAPH_PATTERN_SEPARATOR,\n\tOPEN_MULTI_BLOCK,\n\tOPEN_MULTI_BN,\n\tOPEN_MULTI_LIST,\n\tPREFIX,\n\tSAME_PROPERTY_SEPARATOR,\n\tSAME_SUBJECT_SEPARATOR,\n\tSELECT,\n\tWHERE,\n} from \"./../../patterns/tokens\";\nimport {\n\tNewLineSymbol,\n\tStringLiteral,\n\tToken,\n\tTokenFormat,\n} from \"./../../tokens\";\n\n/**\n * Constructs a compact SPARQL query string.\n * @returns The compact string.\n */\nfunction toCompactString( this:Container<FinishClause> ):string {\n\t// Optional tokens\n\tconst tokens:Token[] = this._tokens\n\t\t.filter( token => token !== WHERE );\n\n\tconst maxTokens:Token[] = [ SELECT ];\n\tlet baseTokens:Token[];\n\n\tfor( let index:number = 0, token:Token = tokens[ index ]; token && maxTokens.indexOf( token ) === - 1; ++ index, token = tokens[ index ] ) {\n\t\t// Remove unused prefixes\n\t\tif( token === PREFIX ) {\n\t\t\tconst nextToken:Token = tokens[ index + 1 ];\n\t\t\tif( ! this._iriResolver._prefixes.get( nextToken[ \"value\" ] ) ) {\n\t\t\t\ttokens.splice( index, 6 );\n\t\t\t\t-- index;\n\t\t\t}\n\t\t}\n\n\t\t// Remove bases and store the last one\n\t\telse if( token === BASE ) {\n\t\t\tbaseTokens = tokens.splice( index, 4 );\n\t\t\t-- index;\n\t\t}\n\t}\n\n\t// Add the last base as first element\n\tif( baseTokens ) {\n\t\t// TODO: Workaround on Stardog error parser\n\t\tconst baseString:string = baseTokens.reduce( ( res, token, index, thisArray ) => {\n\t\t\tlet nextToken:Token = thisArray[ index + 1 ];\n\t\t\treturn res + token.getTokenValue( TokenFormat.PRETTY, nextToken );\n\t\t}, \"\" ) + \"\\n\";\n\t\ttokens.unshift( new StringLiteral( baseString ) );\n\t}\n\n\treturn tokens.reduce( ( res, token, index, thisArray ) => {\n\t\tlet nextToken:Token = thisArray[ index + 1 ];\n\n\t\tif( nextToken === EMPTY_SEPARATOR ) nextToken = thisArray[ index + 2 ];\n\t\treturn res + token.getTokenValue( TokenFormat.COMPACT, nextToken );\n\t}, \"\" );\n}\n\n/**\n * Constructs a pretty SPARQL query string.\n * @returns The pretty string.\n */\nfunction toPrettyString( this:Container<FinishClause> ):string {\n\tconst stack:{ token:Token, indentation:number, subject:number, property:number, spaces:number }[] = [];\n\tlet actual:{ token:Token, indentation:number, subject:number, property:number, spaces:number } = {\n\t\ttoken: null,\n\t\tindentation: 0,\n\t\tsubject: 0,\n\t\tproperty: 0,\n\t\tspaces: 0,\n\t};\n\n\treturn this._tokens.reduce( ( res, token, index, tokens ) => {\n\t\tlet nextToken:Token = tokens[ index + 1 ];\n\t\tlet tokenString:string = token.getTokenValue( TokenFormat.PRETTY, nextToken );\n\n\t\t// Keep track of the indentation spaces\n\t\tif( actual.spaces === 0 ) {\n\t\t\tactual.subject += tokenString.length;\n\t\t\tif( tokenString.endsWith( \" \" ) ) actual.spaces ++;\n\t\t} else if( actual.spaces === 1 ) {\n\t\t\tactual.property += tokenString.length;\n\t\t\tif( tokenString.endsWith( \" \" ) ) actual.spaces ++;\n\t\t}\n\n\t\t// Check if a new block of lines\n\t\tif( [ OPEN_MULTI_BLOCK as Token, OPEN_MULTI_BN, OPEN_MULTI_LIST ].indexOf( token ) !== - 1 ) {\n\n\t\t\t// Record a new state for a block of triples\n\t\t\tstack.push( actual );\n\t\t\tactual = {\n\t\t\t\ttoken: token,\n\t\t\t\tindentation: actual.indentation + 4,\n\t\t\t\tsubject: 0,\n\t\t\t\tproperty: 0,\n\t\t\t\tspaces: token === OPEN_MULTI_BLOCK ? 0 : token === OPEN_MULTI_BN ? 1 : 2,\n\t\t\t};\n\n\t\t} else if( [ CLOSE_MULTI_LIST as Token ].indexOf( token ) !== - 1 ) {\n\t\t\tif( nextToken && ! ( nextToken instanceof NewLineSymbol ) ) {\n\n\t\t\t\t// Obtain parent state\n\t\t\t\tlet parent = actual;\n\t\t\t\twhile( [ OPEN_MULTI_BLOCK as Token, OPEN_MULTI_BN, OPEN_MULTI_LIST ].indexOf( parent.token ) === - 1 )\n\t\t\t\t\tparent = stack.pop();\n\t\t\t\tstack.push( parent );\n\n\t\t\t\t// Record a new state for properties of a collection\n\t\t\t\tactual = {\n\t\t\t\t\ttoken: token,\n\t\t\t\t\tindentation: parent.indentation + 4,\n\t\t\t\t\tsubject: 0,\n\t\t\t\t\tproperty: 0,\n\t\t\t\t\tspaces: 1,\n\t\t\t\t};\n\t\t\t}\n\n\t\t} else if( [ SAME_SUBJECT_SEPARATOR as Token, SAME_PROPERTY_SEPARATOR, CLOSE_MULTI_LIST ].indexOf( token ) !== - 1 ) {\n\n\t\t\t// Obtain parent state\n\t\t\tlet parent = actual;\n\t\t\twhile( [ OPEN_MULTI_BLOCK as Token, OPEN_MULTI_BN, OPEN_MULTI_LIST, CLOSE_MULTI_LIST, CLOSE_MULTI_BN ].indexOf( parent.token ) === - 1 )\n\t\t\t\tparent = stack.pop();\n\t\t\tstack.push( parent );\n\n\t\t\t// Record a new state for same subject properties\n\t\t\tif( token === SAME_SUBJECT_SEPARATOR ) {\n\t\t\t\tactual = {\n\t\t\t\t\ttoken: token,\n\t\t\t\t\tindentation: parent.indentation + actual.subject,\n\t\t\t\t\tsubject: actual.subject,\n\t\t\t\t\tproperty: 0,\n\t\t\t\t\tspaces: 1,\n\t\t\t\t};\n\n\t\t\t\t// Record a new state for a list of objects of a property\n\t\t\t} else if( token === SAME_PROPERTY_SEPARATOR ) {\n\t\t\t\tactual = {\n\t\t\t\t\ttoken: token,\n\t\t\t\t\tindentation: parent.indentation + actual.subject + actual.property,\n\t\t\t\t\tsubject: actual.subject,\n\t\t\t\t\tproperty: actual.property,\n\t\t\t\t\tspaces: 2,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Returns still a block state\n\t\t} else if( token === GRAPH_PATTERN_SEPARATOR ) {\n\t\t\twhile( actual.token !== OPEN_MULTI_BLOCK ) actual = stack.pop();\n\t\t\tactual.spaces = 0;\n\t\t\tactual.subject = 0;\n\t\t\tactual.property = 0;\n\t\t}\n\n\t\tif( nextToken === CLOSE_MULTI_BLOCK ) {\n\t\t\twhile( actual.token !== OPEN_MULTI_BLOCK ) actual = stack.pop();\n\t\t\tactual = stack.pop();\n\t\t} else if( nextToken === CLOSE_MULTI_BN ) {\n\t\t\twhile( actual.token !== OPEN_MULTI_BN ) actual = stack.pop();\n\t\t\tactual = stack.pop();\n\t\t} else if( nextToken === CLOSE_MULTI_LIST ) {\n\t\t\twhile( actual.token !== OPEN_MULTI_LIST ) actual = stack.pop();\n\t\t\tactual = stack.pop();\n\t\t}\n\n\t\tif( tokenString.endsWith( \"\\n\" ) ) {\n\t\t\ttokenString = tokenString + \" \".repeat( actual.indentation );\n\t\t}\n\n\t\treturn res + tokenString;\n\t}, \"\" );\n}\n\n/**\n * Decorator that binds the FinishClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object The object to add the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function finishDecorator<W extends object>( container:Container<FinishClause>, object:W ):W & FinishClause {\n\treturn Object.assign( object, {\n\t\ttoCompactString: toCompactString.bind( container ),\n\t\ttoPrettyString: toPrettyString.bind( container ),\n\t\ttoString: toPrettyString.bind( container ),\n\t} );\n}\n"]}