{"version":3,"sources":["clauses/decorators/from.ts"],"names":[],"mappings":";;AAIA,wDAAuD;AACvD,0DAA6D;AAC7D,gDAA0D;AAC1D,wDAAuD;AACvD,mDAGkC;AAalC,eAAwC,IAAiB,EAAE,MAAc,EAAE,GAAU;IACpF,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,IAAI,CAAC,YAAY,CAAE,CAAC;IACrE,MAAM,CAAC,IAAI,OAAX,MAAM,EAAU,WAAW,CAAC,OAAO,CAAE,GAAG,CAAE,EAAG;IAE7C,IAAM,SAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,EAAE,WAAW,CAAE,CAAC;IAC7E,MAAM,CAAC,aAAa,CAAS,SAAS,EAAE,EAAE,CAAE,CAAC;AAC9C,CAAC;AASD,cAA0D,GAAU;IACnE,MAAM,CAAC,KAAK,CAAK,IAAI,EAAE,CAAE,aAAI,CAAE,EAAE,GAAG,CAAE,CAAC;AACxC,CAAC;AASD,mBAA+D,GAAU;IACxE,MAAM,CAAC,KAAK,CAAK,IAAI,EAAE,CAAE,aAAI,EAAE,cAAK,CAAE,EAAE,GAAG,CAAE,CAAC;AAC/C,CAAC;AAUD,uBAAyE,SAAsB,EAAE,MAAQ;IACxG,MAAM,CAAC,wBAAgB,CAAE,EAAE,IAAI,MAAA,EAAE,SAAS,WAAA,EAAE,EAAE,SAAS,EAAE,2BAAc,CAAQ,SAAS,EAAE,MAAM,CAAE,CAAE,CAAC;AACtG,CAAC;AAFD,sCAEC","file":"from.js","sourcesContent":["import {\n\tFinishClause,\n\tFromClause,\n} from \"sparqler/clauses\";\nimport { Container } from \"sparqler/clauses/Container\";\nimport { whereDecorator } from \"sparqler/clauses/decorators\";\nimport { genericDecorator } from \"sparqler/clauses/utils\";\nimport { IRIResolver } from \"sparqler/iri/IRIResolver\";\nimport {\n\tFROM,\n\tNAMED,\n} from \"sparqler/patterns/tokens\";\nimport { Token } from \"sparqler/tokens\";\n\n/**\n * Internal function that actually creates the tokens of the\n * FromClause methods.\n *\n * @param self The container that is bound to the FromClause methods.\n * @param tokens Initial tokens depending which methods is called.\n * @param iri The iri of the resource to be included.\n * @returns Object with the methods to keep constructing to query.\n * @private\n */\nfunction _from<T extends FinishClause>( self:Container<T>, tokens:Token[], iri:string ):FromClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( self._iriResolver );\n\ttokens.push( ...iriResolver.resolve( iri ) );\n\n\tconst container:Container<T> = new Container<T>( self, tokens, iriResolver );\n\treturn fromDecorator<T, {}>( container, {} );\n}\n\n/**\n * Set a default graph to be included as the RDF Dataset where to\n * look for the query solutions.\n *\n * @param iri IRI of the default graph to be included.\n * @returns Object with the methods to keep constructing to query.\n */\nfunction from<T extends FinishClause>( this:Container<T>, iri:string ):FromClause<T> {\n\treturn _from<T>( this, [ FROM ], iri );\n}\n\n/**\n * Set a named graph to be included as the RDF Dataset where to look for\n * the query solutions.\n *\n * @param iri IRI of the named graph to be included.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction fromNamed<T extends FinishClause>( this:Container<T>, iri:string ):FromClause<T> {\n\treturn _from<T>( this, [ FROM, NAMED ], iri );\n}\n\n/**\n * Decorator that binds the FromClause methods to a container and\n * adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function fromDecorator<T extends FinishClause, W extends object>( container:Container<T>, object:W ):W & FromClause<T> {\n\treturn genericDecorator( { from, fromNamed }, container, whereDecorator<T, W>( container, object ) );\n}\n"]}