{"version":3,"sources":["clauses/decorators/from.ts"],"names":[],"mappings":";;AAIA,4CAA2C;AAC3C,uBAAoC;AACpC,uDAAsD;AACtD,kDAGiC;AAajC,eAAwC,IAAiB,EAAE,MAAc,EAAE,GAAU;IACpF,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,IAAI,CAAC,YAAY,CAAE,CAAC;IACrE,MAAM,CAAC,IAAI,OAAX,MAAM,EAAU,WAAW,CAAC,OAAO,CAAE,GAAG,CAAE,EAAG;IAE7C,IAAM,SAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,EAAE,WAAW,CAAE,CAAC;IAC7E,MAAM,CAAC,aAAa,CAAS,SAAS,EAAE,EAAE,CAAE,CAAC;AAC9C,CAAC;AASD,cAA0D,GAAU;IACnE,MAAM,CAAC,KAAK,CAAK,IAAI,EAAE,CAAE,aAAI,CAAE,EAAE,GAAG,CAAE,CAAC;AACxC,CAAC;AASD,mBAA+D,GAAU;IACxE,MAAM,CAAC,KAAK,CAAK,IAAI,EAAE,CAAE,aAAI,EAAE,cAAK,CAAE,EAAE,GAAG,CAAE,CAAC;AAC/C,CAAC;AAUD,uBAAyE,SAAsB,EAAE,MAAQ;IACxG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAE,iBAAc,CAAE,SAAS,EAAE,MAAM,CAAE,EAAE;QAC1D,IAAI,EAAE,IAAI,CAAC,IAAI,CAAE,SAAS,CAAE;QAC5B,SAAS,EAAE,SAAS,CAAC,IAAI,CAAE,SAAS,CAAE;KACtC,CAAE,CAAC;AACL,CAAC;AALD,sCAKC","file":"from.js","sourcesContent":["import {\n\tFinishClause,\n\tFromClause,\n} from \"./..\";\nimport { Container } from \"./../Container\";\nimport { whereDecorator } from \"./\";\nimport { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tFROM,\n\tNAMED,\n} from \"./../../patterns/tokens\";\nimport { Token } from \"./../../tokens\";\n\n/**\n * Internal function that actually creates the tokens of the\n * FromClause methods.\n *\n * @param self The container that is bound to the FromClause methods.\n * @param tokens Initial tokens depending which methods is called.\n * @param iri The iri of the resource to be included.\n * @returns Object with the methods to keep constructing to query.\n * @private\n */\nfunction _from<T extends FinishClause>( self:Container<T>, tokens:Token[], iri:string ):FromClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( self._iriResolver );\n\ttokens.push( ...iriResolver.resolve( iri ) );\n\n\tconst container:Container<T> = new Container<T>( self, tokens, iriResolver );\n\treturn fromDecorator<T, {}>( container, {} );\n}\n\n/**\n * Set a default graph to be included as the RDF Dataset where to\n * look for the query solutions.\n *\n * @param iri IRI of the default graph to be included.\n * @returns Object with the methods to keep constructing to query.\n */\nfunction from<T extends FinishClause>( this:Container<T>, iri:string ):FromClause<T> {\n\treturn _from<T>( this, [ FROM ], iri );\n}\n\n/**\n * Set a named graph to be included as the RDF Dataset where to look for\n * the query solutions.\n *\n * @param iri IRI of the named graph to be included.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction fromNamed<T extends FinishClause>( this:Container<T>, iri:string ):FromClause<T> {\n\treturn _from<T>( this, [ FROM, NAMED ], iri );\n}\n\n/**\n * Decorator that binds the FromClause methods to a container and\n * adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function fromDecorator<T extends FinishClause, W extends object>( container:Container<T>, object:W ):W & FromClause<T> {\n\treturn Object.assign( whereDecorator( container, object ), {\n\t\tfrom: from.bind( container ),\n\t\tfromNamed: fromNamed.bind( container ),\n\t} );\n}\n"],"sourceRoot":"../../../src"}