{"version":3,"sources":["clauses/decorators/having.ts"],"names":[],"mappings":";;AAAA,4CAA2C;AAC3C,uBAAoC;AAOpC,kDAAiD;AACjD,yCAGwB;AAYxB,gBAA8E,YAAmB;IAChG,IAAM,MAAM,GAAW,CAAE,eAAM,EAAE,IAAI,sBAAa,CAAE,YAAY,CAAE,CAAE,CAAC;IAErE,IAAM,SAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,CAAE,CAAC;IAChE,OAAO,IAAI,CAAC,gBAAgB,CAAkB,SAAS,EAAE,iBAAc,CAAS,SAAS,EAAE,EAAE,CAAE,CAAE,CAAC;AACnG,CAAC;AAYD,yBAA6F,SAAsB,EAAE,MAAQ;IAC5H,OAAO,MAAM,CAAC,MAAM,CAAE,iBAAc,CAAQ,SAAS,EAAE,MAAM,CAAE,EAAE;QAChE,MAAM,EAAE,MAAM,CAAC,IAAI,CAAE,SAAS,CAAE;KAChC,CAAE,CAAC;AACL,CAAC;AAJD,0CAIC","file":"having.js","sourcesContent":["import { Container } from \"./../Container\";\nimport { orderDecorator } from \"./\";\nimport { FinishClause } from \"./../interfaces\";\nimport { HavingClause } from \"./../interfaces\";\nimport {\n\tSubFinishClause,\n} from \"./../interfaces\";\nimport { OrderClause } from \"./../interfaces\";\nimport { HAVING } from \"./../../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\n\n/**\n * Set a condition to filter the sequence of solutions the query will\n * retrieve.\n *\n * Notice: The current version of SPARQLER does not evaluate the condition\n * for possible errors\n *\n * @param rawCondition Raw condition to be applied for the solutions filtering.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction having<T extends FinishClause | SubFinishClause>( this:Container<T>, rawCondition:string ):OrderClause<T> & T {\n\tconst tokens:Token[] = [ HAVING, new StringLiteral( rawCondition ) ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens );\n\treturn this._finishDecorator<OrderClause<T>>( container, orderDecorator<T, {}>( container, {} ) );\n}\n\n// having( rawCondition:string ):OrderClause<T> & T;\n\n/**\n * Decorator that binds the HavingClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function havingDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & HavingClause<T> {\n\treturn Object.assign( orderDecorator<T, W>( container, object ), {\n\t\thaving: having.bind( container ),\n\t} );\n}\n"]}