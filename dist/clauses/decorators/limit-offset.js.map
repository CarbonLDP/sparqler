{"version":3,"sources":["clauses/decorators/limit-offset.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,gDAG+B;AAC/B,uCAGsB;AACtB,0CAAyC;AASzC,iCAA2C;AAC3C,mCAA2C;AAM3C,IAAY,aAGX;AAHD,WAAY,aAAa;IACxB,mDAAK,CAAA;IACL,qDAAM,CAAA;AACP,CAAC,EAHW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAGxB;AAKD;IAAmG,wCAAY;IAmB9G,8BAAa,iBAAgC,EAAE,SAAiB,EAAE,aAA2B;QAA7F,YACC,kBAAO,iBAAiB,EAAE,SAAS,CAAE,SAKrC;QAJA,KAAI,CAAC,WAAW,GAAG,aAAa,KAAK,aAAa,CAAC,MAAM,CAAC;QAC1D,KAAI,CAAC,UAAU,GAAG,aAAa,KAAK,aAAa,CAAC,KAAK,CAAC;QAExD,MAAM,CAAC,MAAM,CAAE,KAAI,CAAE,CAAC;;IACvB,CAAC;IACF,2BAAC;AAAD,CA1BA,AA0BC,CA1BkG,qBAAS,GA0B3G;AA1BY,oDAAoB;AAmCjC,eAAwF,KAAY;IACnG,IAAM,MAAM,GAAW,CAAE,cAAK,EAAE,IAAI,sBAAa,CAAE,KAAK,CAAE,CAAE,CAAC;IAG7D,EAAE,CAAA,CAAE,IAAI,CAAC,WAAY,CAAC,CAAC,CAAC;QACvB,IAAM,WAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,CAAE,CAAC;QAChE,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAE,WAAS,EAAE,wBAAe,CAAE,WAAS,EAAE,EAAE,CAAE,CAAE,CAAC;IAC7E,CAAC;IAGD,IAAM,SAAS,GAA2B,IAAI,oBAAoB,CAAK,IAAI,EAAE,MAAM,EAAE,aAAa,CAAC,KAAK,CAAE,CAAC;IAC3G,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAE,SAAS,EAAE,eAAe,CAAE,SAAS,EAAE,EAAE,CAAE,CAAE,CAAC;AAC7E,CAAC;AASD,gBAAyF,MAAa;IACrG,IAAM,MAAM,GAAW,CAAE,eAAM,EAAE,IAAI,sBAAa,CAAE,MAAM,CAAE,CAAE,CAAC;IAG/D,EAAE,CAAA,CAAE,IAAI,CAAC,UAAW,CAAC,CAAC,CAAC;QACtB,IAAM,WAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,CAAE,CAAC;QAChE,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAE,WAAS,EAAE,wBAAe,CAAE,WAAS,EAAE,EAAE,CAAE,CAAE,CAAC;IAC7E,CAAC;IAGD,IAAM,SAAS,GAA2B,IAAI,oBAAoB,CAAK,IAAI,EAAE,MAAM,EAAE,aAAa,CAAC,MAAM,CAAE,CAAC;IAC5G,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAE,SAAS,EAAE,cAAc,CAAE,SAAS,EAAE,EAAE,CAAE,CAAE,CAAC;AAC5E,CAAC;AAWD,wBAA4F,SAAsB,EAAE,MAAQ;IAC3H,MAAM,CAAC,wBAAgB,CAAE,EAAE,KAAK,OAAA,EAAE,EAAE,SAAS,EAAE,wBAAe,CAAE,SAAS,EAAE,MAAM,CAAE,CAAE,CAAC;AACvF,CAAC;AAFD,wCAEC;AAUD,yBAA6F,SAAsB,EAAE,MAAQ;IAC5H,MAAM,CAAC,wBAAgB,CAAE,EAAE,MAAM,QAAA,EAAE,EAAE,SAAS,EAAE,wBAAe,CAAE,SAAS,EAAE,MAAM,CAAE,CAAE,CAAC;AACxF,CAAC;AAFD,0CAEC;AAUD,8BAAkG,SAAsB,EAAE,MAAQ;IACjI,MAAM,CAAC,wBAAgB,CAAE;QACxB,KAAK,EAAE,KAAoF;QAC3F,MAAM,EAAE,MAAqF;KAC7F,EAAE,SAAS,EAAE,wBAAe,CAAE,SAAS,EAAE,MAAM,CAAE,CAAE,CAAC;AACtD,CAAC;AALD,oDAKC","file":"limit-offset.js","sourcesContent":["import {\n\tLIMIT,\n\tOFFSET,\n} from \"../../patterns/tokens\";\nimport {\n\tNumberLiteral,\n\tToken,\n} from \"../../tokens\";\nimport { Container } from \"../Container\";\nimport {\n\tFinishClause,\n\tLimitClause,\n\tLimitOffsetClause,\n\tOffsetClause,\n\tSubFinishClause,\n\tValuesClause,\n} from \"../interfaces\";\nimport { genericDecorator } from \"./utils\";\nimport { valuesDecorator } from \"./values\";\n\n\n/**\n * Enum to specify which method is creating the LimitOffsetContainer.\n */\nexport enum CurrentMethod {\n\tLIMIT,\n\tOFFSET,\n}\n\n/**\n * Container to be used by the limit and offset methods to keep track of which method is called first.\n */\nexport class LimitOffsetContainer<T extends FinishClause | SubFinishClause = FinishClause> extends Container<T> {\n\n\t/**\n\t * Property indicating that limit method has been used first.\n\t */\n\treadonly _limitUsed:boolean;\n\n\t/**\n\t * Property indicating that offset method has been used first.\n\t */\n\treadonly _offsetUsed:boolean;\n\n\t/**\n\t * Creates the container specifying the method that it's creating it.\n\t *\n\t * @param previousContainer The previous container data to be copied.\n\t * @param newTokens The new tokens to be added.\n\t * @param currentMethod The method that is creating the current container.\n\t */\n\tconstructor( previousContainer:Container<any>, newTokens:Token[], currentMethod:CurrentMethod ) {\n\t\tsuper( previousContainer, newTokens );\n\t\tthis._offsetUsed = currentMethod === CurrentMethod.OFFSET;\n\t\tthis._limitUsed = currentMethod === CurrentMethod.LIMIT;\n\n\t\tObject.freeze( this );\n\t}\n}\n\n/**\n * Set the limit of results the query should return.\n *\n * @param limit The number to be applied as limit.\n * @returns A OffsetClause or the FinishClause/SubFinishClause depending\n * if the offset method has been called before or not.\n */\nfunction limit<T extends FinishClause | SubFinishClause>( this:LimitOffsetContainer<T>, limit:number ):( T & ValuesClause<T> ) | ( OffsetClause<T & ValuesClause<T>> & ValuesClause<T> & T ) {\n\tconst tokens:Token[] = [ LIMIT, new NumberLiteral( limit ) ];\n\n\t// Return T & ValuesClause<T>\n\tif( this._offsetUsed ) {\n\t\tconst container:Container<T> = new Container<T>( this, tokens );\n\t\treturn this._finishDecorator( container, valuesDecorator( container, {} ) );\n\t}\n\n\t// Return OffsetClause<T & ValuesClause<T>> & ValuesClause<T> & T\n\tconst container:LimitOffsetContainer<T> = new LimitOffsetContainer<T>( this, tokens, CurrentMethod.LIMIT );\n\treturn this._finishDecorator( container, offsetDecorator( container, {} ) );\n}\n\n/**\n * Set the offset of results the query should return from.\n *\n * @param offset The number to be applied as offset.\n * @returns A LimitClause or the FinishClause/SubFinishClause depending\n * if the limit method has been called before or not.\n */\nfunction offset<T extends FinishClause | SubFinishClause>( this:LimitOffsetContainer<T>, offset:number ):( T & ValuesClause<T> ) | ( LimitClause<T & ValuesClause<T>> & ValuesClause<T> & T ) {\n\tconst tokens:Token[] = [ OFFSET, new NumberLiteral( offset ) ];\n\n\t// Return T & ValuesClause<T>\n\tif( this._limitUsed ) {\n\t\tconst container:Container<T> = new Container<T>( this, tokens );\n\t\treturn this._finishDecorator( container, valuesDecorator( container, {} ) );\n\t}\n\n\t// Return LimitClause<T & ValuesClause<T>> & ValuesClause<T> & T\n\tconst container:LimitOffsetContainer<T> = new LimitOffsetContainer<T>( this, tokens, CurrentMethod.OFFSET );\n\treturn this._finishDecorator( container, limitDecorator( container, {} ) );\n}\n\n\n/**\n * Decorator that binds the LimitClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function limitDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & LimitClause<T & ValuesClause<T>> & ValuesClause<T> {\n\treturn genericDecorator( { limit }, container, valuesDecorator( container, object ) );\n}\n\n/**\n * Decorator that binds the OffsetClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function offsetDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & OffsetClause<T & ValuesClause<T>> & ValuesClause<T> {\n\treturn genericDecorator( { offset }, container, valuesDecorator( container, object ) );\n}\n\n/**\n * Decorator that binds the LimitOffsetClause methods to a container and adds\n * them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function limitOffsetDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & LimitOffsetClause<T> {\n\treturn genericDecorator( {\n\t\tlimit: limit as ( limit:number ) => OffsetClause<T & ValuesClause<T>> & ValuesClause<T> & T,\n\t\toffset: offset as ( offset:number ) => LimitClause<T & ValuesClause<T>> & ValuesClause<T> & T,\n\t}, container, valuesDecorator( container, object ) );\n}\n"]}