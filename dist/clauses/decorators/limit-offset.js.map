{"version":3,"sources":["clauses/decorators/limit-offset.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,4CAG0B;AAQ1B,mDAGkC;AAClC,0CAGyB;AAKzB;IAA2E,kCAAY;IAGtF,wBAAa,iBAAgC,EAAE,SAAiB,EAAE,UAAkB;QAApF,YACC,kBAAO,iBAAiB,EAAE,SAAS,CAAE,SAIrC;QAHA,KAAI,CAAC,WAAW,GAAG,UAAU,CAAC;QAE9B,MAAM,CAAC,MAAM,CAAE,KAAI,CAAE,CAAC;;IACvB,CAAC;IACF,qBAAC;AAAD,CATA,AASC,CAT0E,mBAAS,GASnF;AATY,wCAAc;AAW3B;IAA4E,mCAAY;IAGvF,yBAAa,iBAAgC,EAAE,SAAiB,EAAE,SAAiB;QAAnF,YACC,kBAAO,iBAAiB,EAAE,SAAS,CAAE,SAIrC;QAHA,KAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAE5B,MAAM,CAAC,MAAM,CAAE,KAAI,CAAE,CAAC;;IACvB,CAAC;IACF,sBAAC;AAAD,CATA,AASC,CAT2E,mBAAS,GASpF;AATY,0CAAe;AAa5B,eAAsF,KAAY;IACjG,IAAM,MAAM,GAAW,CAAE,cAAK,EAAE,IAAI,sBAAa,CAAE,KAAK,CAAE,CAAE,CAAC;IAG7D,EAAE,CAAA,CAAE,IAAI,CAAC,WAAY,CAAC,CAAC,CAAC;QACvB,IAAM,WAAS,GAAgB,IAAI,mBAAS,CAAK,IAAI,EAAE,MAAM,CAAE,CAAC;QAChE,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAM,WAAS,EAAE,EAAE,CAAE,CAAC;IACnD,CAAC;IAGD,IAAM,SAAS,GAAsB,IAAI,eAAe,CAAK,IAAI,EAAE,MAAM,EAAE,IAAI,CAAE,CAAC;IAClF,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAmB,SAAS,EAAE,sBAAsB,CAAS,SAAS,EAAE,EAAE,CAAE,CAAE,CAAC;AAC5G,CAAC;AAZD,sBAYC;AAED,gBAAwF,MAAa;IACpG,IAAM,MAAM,GAAW,CAAE,eAAM,EAAE,IAAI,sBAAa,CAAE,MAAM,CAAE,CAAE,CAAC;IAG/D,EAAE,CAAA,CAAE,IAAI,CAAC,UAAW,CAAC,CAAC,CAAC;QACtB,IAAM,WAAS,GAAgB,IAAI,mBAAS,CAAK,IAAI,EAAE,MAAM,CAAE,CAAC;QAChE,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAM,WAAS,EAAE,EAAE,CAAE,CAAC;IACnD,CAAC;IAGD,IAAM,SAAS,GAAqB,IAAI,cAAc,CAAK,IAAI,EAAE,MAAM,EAAE,IAAI,CAAE,CAAC;IAChF,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAkB,SAAS,EAAE,qBAAqB,CAAS,SAAS,EAAE,EAAE,CAAE,CAAE,CAAC;AAC1G,CAAC;AAZD,wBAYC;AAKD,+BAAgG,SAAsB,EAAE,MAAQ;IAC/H,MAAM,CAAC,0BAAgB,CAAE,EAAE,KAAK,OAAA,EAAE,EAAE,SAAS,EAAE,MAAM,CAAE,CAAC;AACzD,CAAC;AAFD,sDAEC;AAED,gCAAiG,SAAsB,EAAE,MAAQ;IAChI,MAAM,CAAC,0BAAgB,CAAE,EAAE,MAAM,QAAA,EAAE,EAAE,SAAS,EAAE,MAAM,CAAE,CAAC;AAC1D,CAAC;AAFD,wDAEC;AAED,8BAA+F,SAAsB,EAAE,MAAQ;IAC9H,MAAM,CAAC,0BAAgB,CAAE;QACxB,KAAK,EAAE,KAAgD;QACvD,MAAM,EAAE,MAAiD;KACzD,EAAE,SAAS,EAAE,MAAM,CAAE,CAAC;AACxB,CAAC;AALD,oDAKC","file":"limit-offset.js","sourcesContent":["import {\n\tContainer,\n\tgenericDecorator,\n} from \"sparqler/clauses\";\nimport {\n\tFinishClause,\n\tLimitClause,\n\tLimitOffsetClause,\n\tOffsetClause,\n} from \"sparqler/clauses/interfaces\";\nimport { GraphPattern } from \"sparqler/patterns\";\nimport {\n\tLIMIT,\n\tOFFSET,\n} from \"sparqler/patterns/tokens\";\nimport {\n\tNumberLiteral,\n\tToken,\n} from \"sparqler/tokens\";\n\n\n// Containers\n\nexport class LimitContainer<T extends FinishClause | GraphPattern> extends Container<T> {\n\treadonly _offsetUsed:boolean;\n\n\tconstructor( previousContainer:Container<any>, newTokens:Token[], offsetUsed:boolean ) {\n\t\tsuper( previousContainer, newTokens );\n\t\tthis._offsetUsed = offsetUsed;\n\n\t\tObject.freeze( this );\n\t}\n}\n\nexport class OffsetContainer<T extends FinishClause | GraphPattern> extends Container<T> {\n\treadonly _limitUsed:boolean;\n\n\tconstructor( previousContainer:Container<any>, newTokens:Token[], limitUsed:boolean ) {\n\t\tsuper( previousContainer, newTokens );\n\t\tthis._limitUsed = limitUsed;\n\n\t\tObject.freeze( this );\n\t}\n}\n\n// Functionality\n\nexport function limit<T extends FinishClause | GraphPattern>( this:LimitContainer<T>, limit:number ):T | OffsetClause<T> & T {\n\tconst tokens:Token[] = [ LIMIT, new NumberLiteral( limit ) ];\n\n\t// Return T\n\tif( this._offsetUsed ) {\n\t\tconst container:Container<T> = new Container<T>( this, tokens );\n\t\treturn this._finishDecorator<{}>( container, {} );\n\t}\n\n\t// Return OffsetClause<T> & T\n\tconst container:OffsetContainer<T> = new OffsetContainer<T>( this, tokens, true );\n\treturn this._finishDecorator<OffsetClause<T>>( container, offsetBuilderDecorator<T, {}>( container, {} ) );\n}\n\nexport function offset<T extends FinishClause | GraphPattern>( this:OffsetContainer<T>, offset:number ):T | OffsetClause<T> & T {\n\tconst tokens:Token[] = [ OFFSET, new NumberLiteral( offset ) ];\n\n\t// Return T\n\tif( this._limitUsed ) {\n\t\tconst container:Container<T> = new Container<T>( this, tokens );\n\t\treturn this._finishDecorator<{}>( container, {} );\n\t}\n\n\t// Return LimitClause<T> & T\n\tconst container:LimitContainer<T> = new LimitContainer<T>( this, tokens, true );\n\treturn this._finishDecorator<LimitClause<T>>( container, limitBuilderDecorator<T, {}>( container, {} ) );\n}\n\n\n// Decorators\n\nexport function limitBuilderDecorator<T extends FinishClause | GraphPattern, W extends object>( container:Container<T>, object:W ):W & LimitClause<T> {\n\treturn genericDecorator( { limit }, container, object );\n}\n\nexport function offsetBuilderDecorator<T extends FinishClause | GraphPattern, W extends object>( container:Container<T>, object:W ):W & OffsetClause<T> {\n\treturn genericDecorator( { offset }, container, object );\n}\n\nexport function limitOffsetDecorator<T extends FinishClause | GraphPattern, W extends object>( container:Container<T>, object:W ):W & LimitOffsetClause<T> {\n\treturn genericDecorator( {\n\t\tlimit: limit as ( limit:number ) => OffsetClause<T> & T,\n\t\toffset: offset as ( offset:number ) => LimitClause<T> & T,\n\t}, container, object );\n}\n"]}