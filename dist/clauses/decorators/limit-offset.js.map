{"version":3,"sources":["clauses/decorators/limit-offset.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,wDAAuD;AAOvD,gDAA0D;AAE1D,mDAGkC;AAClC,0CAGyB;AAMzB,IAAY,aAGX;AAHD,WAAY,aAAa;IACxB,mDAAK,CAAA;IACL,qDAAM,CAAA;AACP,CAAC,EAHW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAGxB;AAKD;IAAgG,wCAAY;IAmB3G,8BAAa,iBAAgC,EAAE,SAAiB,EAAE,aAA2B;QAA7F,YACC,kBAAO,iBAAiB,EAAE,SAAS,CAAE,SAKrC;QAJA,KAAI,CAAC,WAAW,GAAG,aAAa,KAAK,aAAa,CAAC,MAAM,CAAC;QAC1D,KAAI,CAAC,UAAU,GAAG,aAAa,KAAK,aAAa,CAAC,KAAK,CAAC;QAExD,MAAM,CAAC,MAAM,CAAE,KAAI,CAAE,CAAC;;IACvB,CAAC;IACF,2BAAC;AAAD,CA1BA,AA0BC,CA1B+F,qBAAS,GA0BxG;AA1BY,oDAAoB;AAmCjC,eAA4F,KAAY;IACvG,IAAM,MAAM,GAAW,CAAE,cAAK,EAAE,IAAI,sBAAa,CAAE,KAAK,CAAE,CAAE,CAAC;IAG7D,EAAE,CAAA,CAAE,IAAI,CAAC,WAAY,CAAC,CAAC,CAAC;QACvB,IAAM,WAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,CAAE,CAAC;QAChE,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAM,WAAS,EAAE,EAAE,CAAE,CAAC;IACnD,CAAC;IAGD,IAAM,SAAS,GAA2B,IAAI,oBAAoB,CAAK,IAAI,EAAE,MAAM,EAAE,aAAa,CAAC,KAAK,CAAE,CAAC;IAC3G,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAmB,SAAS,EAAE,eAAe,CAAS,SAAS,EAAE,EAAE,CAAE,CAAE,CAAC;AACrG,CAAC;AAZD,sBAYC;AASD,gBAA6F,MAAa;IACzG,IAAM,MAAM,GAAW,CAAE,eAAM,EAAE,IAAI,sBAAa,CAAE,MAAM,CAAE,CAAE,CAAC;IAG/D,EAAE,CAAA,CAAE,IAAI,CAAC,UAAW,CAAC,CAAC,CAAC;QACtB,IAAM,WAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,CAAE,CAAC;QAChE,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAM,WAAS,EAAE,EAAE,CAAE,CAAC;IACnD,CAAC;IAGD,IAAM,SAAS,GAA2B,IAAI,oBAAoB,CAAK,IAAI,EAAE,MAAM,EAAE,aAAa,CAAC,MAAM,CAAE,CAAC;IAC5G,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAkB,SAAS,EAAE,cAAc,CAAS,SAAS,EAAE,EAAE,CAAE,CAAE,CAAC;AACnG,CAAC;AAZD,wBAYC;AAWD,wBAAyF,SAAsB,EAAE,MAAQ;IACxH,MAAM,CAAC,wBAAgB,CAAE,EAAE,KAAK,OAAA,EAAE,EAAE,SAAS,EAAE,MAAM,CAAE,CAAC;AACzD,CAAC;AAFD,wCAEC;AAUD,yBAA0F,SAAsB,EAAE,MAAQ;IACzH,MAAM,CAAC,wBAAgB,CAAE,EAAE,MAAM,QAAA,EAAE,EAAE,SAAS,EAAE,MAAM,CAAE,CAAC;AAC1D,CAAC;AAFD,0CAEC;AAUD,8BAA+F,SAAsB,EAAE,MAAQ;IAC9H,MAAM,CAAC,wBAAgB,CAAE;QACxB,KAAK,EAAE,KAAgD;QACvD,MAAM,EAAE,MAAiD;KACzD,EAAE,SAAS,EAAE,MAAM,CAAE,CAAC;AACxB,CAAC;AALD,oDAKC","file":"limit-offset.js","sourcesContent":["import { Container } from \"sparqler/clauses/Container\";\nimport {\n\tFinishClause,\n\tLimitClause,\n\tLimitOffsetClause,\n\tOffsetClause,\n} from \"sparqler/clauses/interfaces\";\nimport { genericDecorator } from \"sparqler/clauses/utils\";\nimport { GraphPattern } from \"sparqler/patterns/interfaces\";\nimport {\n\tLIMIT,\n\tOFFSET,\n} from \"sparqler/patterns/tokens\";\nimport {\n\tNumberLiteral,\n\tToken,\n} from \"sparqler/tokens\";\n\n\n/**\n * Enum to specify which method is creating the LimitOffsetContainer.\n */\nexport enum CurrentMethod {\n\tLIMIT,\n\tOFFSET,\n}\n\n/**\n * Container to be used by the limit and offset methods to keep track of which method is called first.\n */\nexport class LimitOffsetContainer<T extends FinishClause | GraphPattern = FinishClause> extends Container<T> {\n\n\t/**\n\t * Property indicating that limit method has been used first.\n\t */\n\treadonly _limitUsed:boolean;\n\n\t/**\n\t * Property indicating that offset method has been used first.\n\t */\n\treadonly _offsetUsed:boolean;\n\n\t/**\n\t * Creates the container specifying the method that it's creating it.\n\t *\n\t * @param previousContainer The previous container data to be copied.\n\t * @param newTokens The new tokens to be added.\n\t * @param currentMethod The method that is creating the current container.\n\t */\n\tconstructor( previousContainer:Container<any>, newTokens:Token[], currentMethod:CurrentMethod ) {\n\t\tsuper( previousContainer, newTokens );\n\t\tthis._offsetUsed = currentMethod === CurrentMethod.OFFSET;\n\t\tthis._limitUsed = currentMethod === CurrentMethod.LIMIT;\n\n\t\tObject.freeze( this );\n\t}\n}\n\n/**\n * Set the limit of results the query should return.\n *\n * @param limit The number to be applied as limit.\n * @returns A OffsetClause or the FinishClause/GraphPattern depending\n * if the offset method has been called before or not.\n */\nexport function limit<T extends FinishClause | GraphPattern>( this:LimitOffsetContainer<T>, limit:number ):T | OffsetClause<T> & T {\n\tconst tokens:Token[] = [ LIMIT, new NumberLiteral( limit ) ];\n\n\t// Return T\n\tif( this._offsetUsed ) {\n\t\tconst container:Container<T> = new Container<T>( this, tokens );\n\t\treturn this._finishDecorator<{}>( container, {} );\n\t}\n\n\t// Return OffsetClause<T> & T\n\tconst container:LimitOffsetContainer<T> = new LimitOffsetContainer<T>( this, tokens, CurrentMethod.LIMIT );\n\treturn this._finishDecorator<OffsetClause<T>>( container, offsetDecorator<T, {}>( container, {} ) );\n}\n\n/**\n * Set the offset of results the query should return from.\n *\n * @param offset The number to be applied as offset.\n * @returns A LimitClause or the FinishClause/GraphPattern depending\n * if the limit method has been called before or not.\n */\nexport function offset<T extends FinishClause | GraphPattern>( this:LimitOffsetContainer<T>, offset:number ):T | LimitClause<T> & T {\n\tconst tokens:Token[] = [ OFFSET, new NumberLiteral( offset ) ];\n\n\t// Return T\n\tif( this._limitUsed ) {\n\t\tconst container:Container<T> = new Container<T>( this, tokens );\n\t\treturn this._finishDecorator<{}>( container, {} );\n\t}\n\n\t// Return LimitClause<T> & T\n\tconst container:LimitOffsetContainer<T> = new LimitOffsetContainer<T>( this, tokens, CurrentMethod.OFFSET );\n\treturn this._finishDecorator<LimitClause<T>>( container, limitDecorator<T, {}>( container, {} ) );\n}\n\n\n/**\n * Decorator that binds the LimitClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function limitDecorator<T extends FinishClause | GraphPattern, W extends object>( container:Container<T>, object:W ):W & LimitClause<T> {\n\treturn genericDecorator( { limit }, container, object );\n}\n\n/**\n * Decorator that binds the OffsetClause methods to a container and adds them\n * to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function offsetDecorator<T extends FinishClause | GraphPattern, W extends object>( container:Container<T>, object:W ):W & OffsetClause<T> {\n\treturn genericDecorator( { offset }, container, object );\n}\n\n/**\n * Decorator that binds the LimitOffsetClause methods to a container and adds\n * them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function limitOffsetDecorator<T extends FinishClause | GraphPattern, W extends object>( container:Container<T>, object:W ):W & LimitOffsetClause<T> {\n\treturn genericDecorator( {\n\t\tlimit: limit as ( limit:number ) => OffsetClause<T> & T,\n\t\toffset: offset as ( offset:number ) => LimitClause<T> & T,\n\t}, container, object );\n}\n"]}