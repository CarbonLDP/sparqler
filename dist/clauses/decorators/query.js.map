{"version":3,"sources":["clauses/decorators/query.ts"],"names":[],"mappings":";;AAAA,4CAK0B;AAC1B,0DAA8D;AAC9D,wDAAuD;AACvD,mDAMkC;AAClC,0CAGyB;AAEzB,cAA0D,GAAU;IACnE,IAAM,MAAM,GAAW,CAAE,aAAI,EAAE,iBAAQ,EAAE,IAAI,sBAAa,CAAE,GAAG,CAAE,EAAE,kBAAS,CAAE,CAAC;IAE/E,IAAM,SAAS,GAAgB,IAAI,mBAAS,CAAK,IAAI,EAAE,MAAM,CAAE,CAAC;IAChE,MAAM,CAAC,cAAc,CAAS,SAAS,EAAE,EAAE,CAAE,CAAC;AAC/C,CAAC;AAED,eAA2D,GAAU;IACpE,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,IAAI,CAAC,YAAY,EAAE,GAAG,CAAE,CAAC;IAE1E,IAAM,SAAS,GAAgB,IAAI,mBAAS,CAAK,IAAI,EAAE,IAAI,EAAE,WAAW,CAAE,CAAC;IAC3E,MAAM,CAAC,cAAc,CAAS,SAAS,EAAE,EAAE,CAAE,CAAC;AAC/C,CAAC;AAED,gBAA4D,IAAW,EAAE,GAAU;IAClF,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,IAAI,CAAC,YAAY,CAAE,CAAC;IACrE,WAAW,CAAC,SAAS,CAAC,GAAG,CAAE,IAAI,EAAE,KAAK,CAAE,CAAC;IAEzC,IAAM,MAAM,GAAW,CAAE,eAAM,EAAE,IAAI,sBAAa,CAAE,IAAI,CAAE,EAAE,sBAAa,EAAE,iBAAQ,EAAE,IAAI,sBAAa,CAAE,GAAG,CAAE,EAAE,kBAAS,CAAE,CAAC;IAE3H,IAAM,SAAS,GAAgB,IAAI,mBAAS,CAAK,IAAI,EAAE,MAAM,EAAE,WAAW,CAAE,CAAC;IAC7E,MAAM,CAAC,cAAc,CAAS,SAAS,EAAE,EAAE,CAAE,CAAC;AAC/C,CAAC;AAED,wBAA0E,SAAsB,EAAE,MAAQ;IACzG,MAAM,CAAC,0BAAgB,CAAE,EAAE,IAAI,MAAA,EAAE,KAAK,OAAA,EAAE,MAAM,QAAA,EAAE,EAAE,SAAS,EAAE,4BAAe,CAAQ,SAAS,EAAE,MAAM,CAAE,CAAE,CAAC;AAC3G,CAAC;AAFD,wCAEC","file":"query.js","sourcesContent":["import {\n\tContainer,\n\tFinishClause,\n\tgenericDecorator,\n\tQueryClause,\n} from \"sparqler/clauses\";\nimport { selectDecorator } from \"sparqler/clauses/decorators\";\nimport { IRIResolver } from \"sparqler/iri/IRIResolver\";\nimport {\n\tBASE,\n\tCLOSE_IRI,\n\tOPEN_IRI,\n\tPREFIX,\n\tPREFIX_SYMBOL,\n} from \"sparqler/patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"sparqler/tokens\";\n\nfunction base<T extends FinishClause>( this:Container<T>, iri:string ):QueryClause<T> {\n\tconst tokens:Token[] = [ BASE, OPEN_IRI, new StringLiteral( iri ), CLOSE_IRI ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens );\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\nfunction vocab<T extends FinishClause>( this:Container<T>, iri:string ):QueryClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this._iriResolver, iri );\n\n\tconst container:Container<T> = new Container<T>( this, null, iriResolver );\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\nfunction prefix<T extends FinishClause>( this:Container<T>, name:string, iri:string ):QueryClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this._iriResolver );\n\tiriResolver._prefixes.set( name, false );\n\n\tconst tokens:Token[] = [ PREFIX, new StringLiteral( name ), PREFIX_SYMBOL, OPEN_IRI, new StringLiteral( iri ), CLOSE_IRI ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens, iriResolver );\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\nexport function queryDecorator<T extends FinishClause, W extends object>( container:Container<T>, object:W ):W & QueryClause<T> {\n\treturn genericDecorator( { base, vocab, prefix }, container, selectDecorator<T, W>( container, object ) );\n}\n"]}