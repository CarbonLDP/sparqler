{"version":3,"sources":["clauses/decorators/query.ts"],"names":[],"mappings":";;AAAA,4CAA2C;AAC3C,uBAAqC;AAKrC,uDAAsD;AACtD,kDAMiC;AACjC,yCAGwB;AAWxB,cAA0D,GAAU;IACnE,IAAM,MAAM,GAAW,CAAE,aAAI,EAAE,iBAAQ,EAAE,IAAI,sBAAa,CAAE,GAAG,CAAE,EAAE,kBAAS,CAAE,CAAC;IAE/E,IAAM,SAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,CAAE,CAAC;IAChE,OAAO,cAAc,CAAS,SAAS,EAAE,EAAE,CAAE,CAAC;AAC/C,CAAC;AASD,eAA2D,GAAU;IACpE,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,IAAI,CAAC,YAAY,EAAE,GAAG,CAAE,CAAC;IAE1E,IAAM,SAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,IAAI,EAAE,WAAW,CAAE,CAAC;IAC3E,OAAO,cAAc,CAAS,SAAS,EAAE,EAAE,CAAE,CAAC;AAC/C,CAAC;AAYD,gBAA4D,IAAW,EAAE,GAAU;IAClF,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,IAAI,CAAC,YAAY,CAAE,CAAC;IAErE,IAAM,aAAa,GAAG,WAAW,CAAC,SAAS,CAAC,GAAG,CAAE,IAAI,CAAE,CAAC,CAAC;QACxD,IAAI,CAAC,OAAO,CAAC,SAAS,CAAE,UAAA,KAAK,IAAI,OAAA,KAAK,YAAY,sBAAa,IAAI,KAAK,CAAE,OAAO,CAAE,KAAK,IAAI,EAA3D,CAA2D,CAAE,CAAC,CAAC;QAChG,CAAE,CAAC,CAAC;IAEL,WAAW,CAAC,SAAS,CAAC,GAAG,CAAE,IAAI,EAAE,KAAK,CAAE,CAAC;IAEzC,IAAM,MAAM,GAAW,CAAE,eAAM,EAAE,IAAI,sBAAa,CAAE,IAAI,CAAE,EAAE,sBAAa,EAAE,iBAAQ,EAAE,IAAI,sBAAa,CAAE,GAAG,CAAE,EAAE,kBAAS,CAAE,CAAC;IAE3H,IAAM,SAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,EAAE,WAAW,CAAE,CAAC;IAE7E,IAAI,aAAa,KAAK,CAAE,CAAC,EAAG;QAC3B,SAAS,CAAC,OAAO,CAAC,MAAM,CAAE,aAAa,GAAG,CAAC,EAAE,CAAC,CAAE,CAAC;KACjD;IAED,OAAO,cAAc,CAAS,SAAS,EAAE,EAAE,CAAE,CAAC;AAC/C,CAAC;AAUD,wBAA0E,SAAsB,EAAE,MAAQ;IACzG,OAAO,MAAM,CAAC,MAAM,CAAE,kBAAe,CAAE,SAAS,EAAE,MAAM,CAAE,EAAE;QAC3D,IAAI,EAAE,IAAI,CAAC,IAAI,CAAE,SAAS,CAAE;QAC5B,KAAK,EAAE,KAAK,CAAC,IAAI,CAAE,SAAS,CAAE;QAC9B,MAAM,EAAE,MAAM,CAAC,IAAI,CAAE,SAAS,CAAE;KAChC,CAAE,CAAC;AACL,CAAC;AAND,wCAMC","file":"query.js","sourcesContent":["import { Container } from \"./../Container\";\nimport { selectDecorator } from \"./\";\nimport {\n\tFinishClause,\n\t} from \"./../FinishClause\";\nimport { QueryClause } from \"./../QueryClause\";\nimport { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tBASE,\n\tCLOSE_IRI,\n\tOPEN_IRI,\n\tPREFIX,\n\tPREFIX_SYMBOL,\n} from \"./../../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\n\n/**\n * Add a base IRI the query uses to resolve any relative IRIs.\n *\n * If a default vocabulary is set with the {@link QueryClause.vocab}\n * method, the base is ignored for relative predicates.\n *\n * @param iri IRI to be used as the query BASE.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction base<T extends FinishClause>( this:Container<T>, iri:string ):QueryClause<T> {\n\tconst tokens:Token[] = [ BASE, OPEN_IRI, new StringLiteral( iri ), CLOSE_IRI ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens );\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\n/**\n * Add a default vocabulary to be used to resolve relative IRIs when\n * used as a predicate in a triple pattern.\n *\n * @param iri IRI to append to prepend to any relative predicate.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction vocab<T extends FinishClause>( this:Container<T>, iri:string ):QueryClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this._iriResolver, iri );\n\n\tconst container:Container<T> = new Container<T>( this, null, iriResolver );\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\n/**\n * Add a prefix to the query.\n *\n * If the prefix is not used in any part of the query it is not added\n * in the compact query string.\n *\n * @param name Name the prefix will be identified for.\n * @param iri The IRI of the current PREFIX.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction prefix<T extends FinishClause>( this:Container<T>, name:string, iri:string ):QueryClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this._iriResolver );\n\n\tconst previousIndex = iriResolver._prefixes.has( name ) ?\n\t\tthis._tokens.findIndex( token => token instanceof StringLiteral && token[ \"value\" ] === name ) :\n\t\t- 1;\n\n\tiriResolver._prefixes.set( name, false );\n\n\tconst tokens:Token[] = [ PREFIX, new StringLiteral( name ), PREFIX_SYMBOL, OPEN_IRI, new StringLiteral( iri ), CLOSE_IRI ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens, iriResolver );\n\n\tif( previousIndex !== - 1 ) {\n\t\tcontainer._tokens.splice( previousIndex - 1, 6 );\n\t}\n\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\n/**\n * Decorator that bind {@link QueryClause} methods to container and\n * adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function queryDecorator<T extends FinishClause, W extends object>( container:Container<T>, object:W ):W & QueryClause<T> {\n\treturn Object.assign( selectDecorator( container, object ), {\n\t\tbase: base.bind( container ),\n\t\tvocab: vocab.bind( container ),\n\t\tprefix: prefix.bind( container ),\n\t} );\n}\n"]}