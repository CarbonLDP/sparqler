{"version":3,"sources":["clauses/decorators/query.ts"],"names":[],"mappings":";;AAAA,qDAAoD;AACpD,gDAM+B;AAC/B,uCAGsB;AACtB,0CAAyC;AAKzC,kCAA4C;AAC5C,mCAA2C;AAW3C,cAA0D,GAAU;IACnE,IAAM,MAAM,GAAW,CAAE,aAAI,EAAE,iBAAQ,EAAE,IAAI,sBAAa,CAAE,GAAG,CAAE,EAAE,kBAAS,CAAE,CAAC;IAE/E,IAAM,SAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,CAAE,CAAC;IAChE,MAAM,CAAC,cAAc,CAAS,SAAS,EAAE,EAAE,CAAE,CAAC;AAC/C,CAAC;AASD,eAA2D,GAAU;IACpE,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,IAAI,CAAC,YAAY,EAAE,GAAG,CAAE,CAAC;IAE1E,IAAM,SAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,IAAI,EAAE,WAAW,CAAE,CAAC;IAC3E,MAAM,CAAC,cAAc,CAAS,SAAS,EAAE,EAAE,CAAE,CAAC;AAC/C,CAAC;AAYD,gBAA4D,IAAW,EAAE,GAAU;IAClF,IAAM,WAAW,GAAe,IAAI,yBAAW,CAAE,IAAI,CAAC,YAAY,CAAE,CAAC;IACrE,WAAW,CAAC,SAAS,CAAC,GAAG,CAAE,IAAI,EAAE,KAAK,CAAE,CAAC;IAEzC,IAAM,MAAM,GAAW,CAAE,eAAM,EAAE,IAAI,sBAAa,CAAE,IAAI,CAAE,EAAE,sBAAa,EAAE,iBAAQ,EAAE,IAAI,sBAAa,CAAE,GAAG,CAAE,EAAE,kBAAS,CAAE,CAAC;IAE3H,IAAM,SAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,EAAE,WAAW,CAAE,CAAC;IAC7E,MAAM,CAAC,cAAc,CAAS,SAAS,EAAE,EAAE,CAAE,CAAC;AAC/C,CAAC;AAUD,wBAA0E,SAAsB,EAAE,MAAQ;IACzG,MAAM,CAAC,wBAAgB,CAAE,EAAE,IAAI,MAAA,EAAE,KAAK,OAAA,EAAE,MAAM,QAAA,EAAE,EAAE,SAAS,EAAE,wBAAe,CAAQ,SAAS,EAAE,MAAM,CAAE,CAAE,CAAC;AAC3G,CAAC;AAFD,wCAEC","file":"query.js","sourcesContent":["import { IRIResolver } from \"../../iri/IRIResolver\";\nimport {\n\tBASE,\n\tCLOSE_IRI,\n\tOPEN_IRI,\n\tPREFIX,\n\tPREFIX_SYMBOL,\n} from \"../../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"../../tokens\";\nimport { Container } from \"../Container\";\nimport {\n\tFinishClause,\n\tQueryClause,\n} from \"../interfaces\";\nimport { genericDecorator } from \"../utils\";\nimport { selectDecorator } from \"./select\";\n\n/**\n * Add a base IRI the query uses to resolve any relative IRIs.\n *\n * If a default vocabulary is set with the {@link QueryClause.vocab}\n * method, the base is ignored for relative predicates.\n *\n * @param iri IRI to be used as the query BASE.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction base<T extends FinishClause>( this:Container<T>, iri:string ):QueryClause<T> {\n\tconst tokens:Token[] = [ BASE, OPEN_IRI, new StringLiteral( iri ), CLOSE_IRI ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens );\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\n/**\n * Add a default vocabulary to be used to resolve relative IRIs when\n * used as a predicate in a triple pattern.\n *\n * @param iri IRI to append to prepend to any relative predicate.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction vocab<T extends FinishClause>( this:Container<T>, iri:string ):QueryClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this._iriResolver, iri );\n\n\tconst container:Container<T> = new Container<T>( this, null, iriResolver );\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\n/**\n * Add a prefix to the query.\n *\n * If the prefix is not used in any part of the query it is not added\n * in the compact query string.\n *\n * @param name Name the prefix will be identified for.\n * @param iri The IRI of the current PREFIX.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction prefix<T extends FinishClause>( this:Container<T>, name:string, iri:string ):QueryClause<T> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this._iriResolver );\n\tiriResolver._prefixes.set( name, false );\n\n\tconst tokens:Token[] = [ PREFIX, new StringLiteral( name ), PREFIX_SYMBOL, OPEN_IRI, new StringLiteral( iri ), CLOSE_IRI ];\n\n\tconst container:Container<T> = new Container<T>( this, tokens, iriResolver );\n\treturn queryDecorator<T, {}>( container, {} );\n}\n\n/**\n * Decorator that binds the {@link QueryClause} methods to a container\n * and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function queryDecorator<T extends FinishClause, W extends object>( container:Container<T>, object:W ):W & QueryClause<T> {\n\treturn genericDecorator( { base, vocab, prefix }, container, selectDecorator<T, W>( container, object ) );\n}\n"]}