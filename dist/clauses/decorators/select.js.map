{"version":3,"sources":["clauses/decorators/select.ts"],"names":[],"mappings":";;AAAA,4CAA4C;AAC5C,uBAIY;AASZ,kDAMiC;AACjC,yCAGwB;AAgBxB,SAAS,OAAO,CAA0B,IAAmC,EAAE,MAAc,EAAE,SAAmB;IACjH,IAAI,SAAS,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC;QAAG,MAAM,IAAI,KAAK,CAAE,wCAAwC,CAAE,CAAC;IAEtG,IAAI,SAAS;QAAG,SAAS,CAAC,OAAO,CAAE,UAAA,QAAQ,IAAI,OAAA,MAAM,CAAC,IAAI,CAAE,mBAAU,EAAE,IAAI,sBAAa,CAAE,QAAQ,CAAE,CAAE,EAAxD,CAAwD,CAAE,CAAC;IAE1G,IAAM,SAAS,GAAkC,IAAI,qBAAS,CAAuB,IAAI,EAAE,MAAM,CAAE,CAAC;IAEpG,IAAI,IAAI,CAAC,gBAAgB,KAAK,qBAAkB;QAC/C,OAAO,oBAAiB,CAAuB,SAAuC,EAAE,EAAE,CAAE,CAAC;IAC9F,OAAO,gBAAa,CAAS,SAAyB,EAAE,EAAE,CAAE,CAAC;AAC9D,CAAC;AAQD,SAAS,MAAM;IAA6C,mBAAqB;SAArB,UAAqB,EAArB,qBAAqB,EAArB,IAAqB;QAArB,8BAAqB;;IAChF,OAAO,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,CAAE,EAAE,SAAS,CAAmB,CAAC;AACnE,CAAC;AASD,SAAS,cAAc;IAA6C,mBAAqB;SAArB,UAAqB,EAArB,qBAAqB,EAArB,IAAqB;QAArB,8BAAqB;;IACxF,OAAO,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,EAAE,iBAAQ,CAAE,EAAE,SAAS,CAAmB,CAAC;AAC7E,CAAC;AAUD,SAAS,aAAa;IAA6C,mBAAqB;SAArB,UAAqB,EAArB,qBAAqB,EAArB,IAAqB;QAArB,8BAAqB;;IACvF,OAAO,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,EAAE,gBAAO,CAAE,EAAE,SAAS,CAAmB,CAAC;AAC5E,CAAC;AAQD,SAAS,SAAS;IACjB,OAAO,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,EAAE,YAAG,CAAE,CAAmB,CAAC;AAC7D,CAAC;AASD,SAAS,iBAAiB;IACzB,OAAO,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,EAAE,iBAAQ,EAAE,YAAG,CAAE,CAAmB,CAAC;AACvE,CAAC;AASD,SAAS,gBAAgB;IACxB,OAAO,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,EAAE,gBAAO,EAAE,YAAG,CAAE,CAAmB,CAAC;AACtE,CAAC;AAoBD,SAAgB,eAAe,CAA4C,SAAwC,EAAE,MAAQ;IAC5H,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;QAC7B,MAAM,EAAE,MAAM,CAAC,IAAI,CAAE,SAAS,CAAE;QAChC,cAAc,EAAE,cAAc,CAAC,IAAI,CAAE,SAAS,CAAE;QAChD,aAAa,EAAE,aAAa,CAAC,IAAI,CAAE,SAAS,CAAE;QAC9C,SAAS,EAAE,SAAS,CAAC,IAAI,CAAE,SAAS,CAAE;QACtC,iBAAiB,EAAE,iBAAiB,CAAC,IAAI,CAAE,SAAS,CAAE;QACtD,gBAAgB,EAAE,gBAAgB,CAAC,IAAI,CAAE,SAAS,CAAE;KACpD,CAAE,CAAC;AACL,CAAC;AATD,0CASC","file":"select.js","sourcesContent":["import { Container, } from \"./../Container\";\nimport {\n\tfromDecorator,\n\tsubFinishDecorator,\n\tsubWhereDecorator,\n} from \"./\";\nimport { FinishClause } from \"./../FinishClause\";\nimport { FromClause } from \"./../interfaces\";\nimport {\n\tSubFinishClause,\n\tSubSelectClause,\n\tSubWhereClause,\n} from \"./../interfaces\";\nimport { SelectClause } from \"./../interfaces\";\nimport {\n\tALL,\n\tDISTINCT,\n\tREDUCED,\n\tSELECT,\n\tVAR_SYMBOL,\n} from \"./../../patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"./../../tokens\";\n\n/**\n * Internal function that actually creates the tokens of the\n * SelectClause and SubSelectClause methods.\n *\n * @param self The container that is bound to the FromClause methods.\n * @param tokens Initial tokens depending which method the function\n * is called from.\n * @param variables Optional variables to be converted in tokens.\n * @returns Object with the methods to keep constructing the query.\n * Depending of the self container it will return a `FromClause`, as\n * `SelectClause` indicates; or a `WhereClause<SubFinishClause>`, as\n * `SubSelectClause` also indicates.\n * @private\n */\nfunction _select<T extends FinishClause>( self:Container<T | SubFinishClause>, tokens:Token[], variables?:string[] ):SubWhereClause | FromClause<T> {\n\tif( variables && variables.length === 0 ) throw new Error( \"Need to provide al least one variable.\" );\n\n\tif( variables ) variables.forEach( variable => tokens.push( VAR_SYMBOL, new StringLiteral( variable ) ) );\n\n\tconst container:Container<T | SubFinishClause> = new Container<T | SubFinishClause>( self, tokens );\n\n\tif( self._finishDecorator === subFinishDecorator )\n\t\treturn subWhereDecorator<SubFinishClause, {}>( container as Container<SubFinishClause>, {} );\n\treturn fromDecorator<T, {}>( container as Container<T>, {} );\n}\n\n/**\n * Set a list of variables to be retrieved by the query.\n *\n * @param variables The list of variables.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction select<T extends FinishClause>( this:Container<T>, ...variables:string[] ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT ], variables ) as FromClause<T>;\n}\n\n/**\n * Set a list of variables to be retrieved by the query ensuring no\n * repetitions in the set of solutions.\n *\n * @param variables The list of variables.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectDistinct<T extends FinishClause>( this:Container<T>, ...variables:string[] ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, DISTINCT ], variables ) as FromClause<T>;\n}\n\n/**\n * Set a list of variables to be retrieved by the query permitting\n * eliminations of non-distinct solutions, but not ensuring a set of\n * unique ones.\n *\n * @param variables The list of variables.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectReduced<T extends FinishClause>( this:Container<T>, ...variables:string[] ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, REDUCED ], variables ) as FromClause<T>;\n}\n\n/**\n * Set that the query must return all the solutions for the variables\n * used in the where pattern matching.\n *\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectAll<T extends FinishClause>( this:Container<T> ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, ALL ] ) as FromClause<T>;\n}\n\n/**\n * Set that the query must return all the solutions for the variables\n * used in the where pattern matching, ensuring there is not\n * duplicated solutions.\n *\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectAllDistinct<T extends FinishClause>( this:Container<T> ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, DISTINCT, ALL ] ) as FromClause<T>;\n}\n\n/**\n * Set that the query must return all the solutions for the variables\n * used in the where pattern matching, permitting eliminations of\n * non-distinct solutions, but not ensuring a set of unique ones.\n *\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectAllReduced<T extends FinishClause>( this:Container<T> ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, REDUCED, ALL ] ) as FromClause<T>;\n}\n\n/**\n * Decorator that binds the {@link SelectClause} methods to a\n * container and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function selectDecorator<T extends FinishClause, W extends object>( container:Container<T>, object:W ):W & SelectClause<T>;\n/**\n * Decorator that binds the {@link SubSelectClause} methods to a subSelect\n * container and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function selectDecorator<W extends object>( container:Container<SubFinishClause>, object:W ):W & SubSelectClause;\nexport function selectDecorator<T extends FinishClause, W extends object>( container:Container<T | SubFinishClause>, object:W ):W & (SelectClause<T> | SubSelectClause) {\n\treturn Object.assign( object, {\n\t\tselect: select.bind( container ),\n\t\tselectDistinct: selectDistinct.bind( container ),\n\t\tselectReduced: selectReduced.bind( container ),\n\t\tselectAll: selectAll.bind( container ),\n\t\tselectAllDistinct: selectAllDistinct.bind( container ),\n\t\tselectAllReduced: selectAllReduced.bind( container ),\n\t} );\n}\n"]}