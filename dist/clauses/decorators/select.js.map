{"version":3,"sources":["clauses/decorators/select.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,wDAGoC;AACpC,0DAIqC;AAQrC,gDAA0D;AAG1D,mDAMkC;AAClC,0CAGyB;AAOzB;IAAwC,sCAAuB;IAI9D,4BAAa,WAAuB;QAApC,YACC,kBAAO,IAAI,EAAE,IAAI,EAAE,WAAW,CAAE,SAIhC;QAHA,KAAI,CAAC,gBAAgB,GAAG,kCAAqB,CAAC;QAE9C,MAAM,CAAC,MAAM,CAAE,KAAI,CAAE,CAAC;;IACvB,CAAC;IACF,yBAAC;AAAD,CAVA,AAUC,CAVuC,qBAAS,GAUhD;AAVY,gDAAkB;AA0B/B,iBAA0C,IAAqD,EAAE,MAAc,EAAE,SAAmB;IACnI,EAAE,CAAA,CAAE,SAAS,IAAI,SAAS,CAAC,MAAM,KAAK,CAAE,CAAC;QAAC,MAAM,IAAI,KAAK,CAAE,wCAAwC,CAAE,CAAC;IAEtG,EAAE,CAAA,CAAE,SAAU,CAAC;QAAC,SAAS,CAAC,OAAO,CAAE,UAAA,QAAQ,IAAI,OAAA,MAAM,CAAC,IAAI,CAAE,mBAAU,EAAE,IAAI,sBAAa,CAAE,QAAQ,CAAE,CAAE,EAAxD,CAAwD,CAAE,CAAC;IAE1G,IAAM,SAAS,GAA+B,IAAI,qBAAS,CAAoB,IAAI,EAAE,MAAM,CAAE,CAAC;IAE9F,EAAE,CAAA,CAAE,IAAI,CAAC,gBAAgB,KAAK,kCAAsB,CAAC;QACpD,MAAM,CAAC,2BAAc,CAAoB,SAAoC,EAAE,EAAE,CAAE,CAAC;IACrF,MAAM,CAAC,0BAAa,CAAS,SAAyB,EAAE,EAAE,CAAE,CAAC;AAC9D,CAAC;AAQD;IAA4D,mBAAqB;SAArB,UAAqB,EAArB,qBAAqB,EAArB,IAAqB;QAArB,8BAAqB;;IAChF,MAAM,CAAC,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,CAAE,EAAE,SAAS,CAAmB,CAAC;AACnE,CAAC;AASD;IAAoE,mBAAqB;SAArB,UAAqB,EAArB,qBAAqB,EAArB,IAAqB;QAArB,8BAAqB;;IACxF,MAAM,CAAC,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,EAAE,iBAAQ,CAAE,EAAE,SAAS,CAAmB,CAAC;AAC7E,CAAC;AAUD;IAAmE,mBAAqB;SAArB,UAAqB,EAArB,qBAAqB,EAArB,IAAqB;QAArB,8BAAqB;;IACvF,MAAM,CAAC,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,EAAE,gBAAO,CAAE,EAAE,SAAS,CAAmB,CAAC;AAC5E,CAAC;AAQD;IACC,MAAM,CAAC,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,EAAE,YAAG,CAAE,CAAmB,CAAC;AAC7D,CAAC;AASD;IACC,MAAM,CAAC,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,EAAE,iBAAQ,EAAE,YAAG,CAAE,CAAmB,CAAC;AACvE,CAAC;AASD;IACC,MAAM,CAAC,OAAO,CAAK,IAAI,EAAE,CAAE,eAAM,EAAE,gBAAO,EAAE,YAAG,CAAE,CAAmB,CAAC;AACtE,CAAC;AAoBD,yBAA2E,SAA2C,EAAE,MAAQ;IAC/H,MAAM,CAAC,wBAAgB,CAAE;QACxB,MAAM,QAAA;QACN,cAAc,gBAAA;QACd,aAAa,eAAA;QACb,SAAS,WAAA;QACT,iBAAiB,mBAAA;QACjB,gBAAgB,kBAAA;KAChB,EAAE,SAAS,EAAE,MAAM,CAAE,CAAC;AACxB,CAAC;AATD,0CASC","file":"select.js","sourcesContent":["import {\n\tContainer,\n\tFinishDecorator,\n} from \"sparqler/clauses/Container\";\nimport {\n\tfromDecorator,\n\tgraphPatternDecorator,\n\twhereDecorator,\n} from \"sparqler/clauses/decorators\";\nimport {\n\tFinishClause,\n\tFromClause,\n\tSelectClause,\n\tSubSelect,\n\tWhereClause,\n} from \"sparqler/clauses/interfaces\";\nimport { genericDecorator } from \"sparqler/clauses/utils\";\nimport { IRIResolver } from \"sparqler/iri\";\nimport { GraphPattern } from \"sparqler/patterns\";\nimport {\n\tALL,\n\tDISTINCT,\n\tREDUCED,\n\tSELECT,\n\tVAR_SYMBOL,\n} from \"sparqler/patterns/tokens\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"sparqler/tokens\";\n\n/**\n * Container to be used by the subSelect pattern where it extends\n * the {@link Container} class specifying the finish decorator as\n * {@link graphPatternDecorator}.\n */\nexport class SubSelectContainer extends Container<GraphPattern> {\n\n\treadonly _finishDecorator:FinishDecorator<GraphPattern>;\n\n\tconstructor( iriResolver:IRIResolver ) {\n\t\tsuper( null, null, iriResolver );\n\t\tthis._finishDecorator = graphPatternDecorator;\n\n\t\tObject.freeze( this );\n\t}\n}\n\n/**\n * Internal function that actually creates the tokens of the\n * SelectClause and SubSelect methods.\n *\n * @param self The container that is bound to the FromClause methods.\n * @param tokens Initial tokens depending which method the function\n * is called from.\n * @param variables Optional variables to be converted in tokens.\n * @returns Object with the methods to keep constructing the query.\n * Depending of the self container it will return a `FromClause`, as\n * `SelectClause` indicates; or a `WhereClause<GraphPattern>`, as\n * `SubSelect` also indicates.\n * @private\n */\nfunction _select<T extends FinishClause>( self:Container<T | GraphPattern> | SubSelectContainer, tokens:Token[], variables?:string[] ):WhereClause<GraphPattern> | FromClause<T> {\n\tif( variables && variables.length === 0 ) throw new Error( \"Need to provide al least one variable.\" );\n\n\tif( variables ) variables.forEach( variable => tokens.push( VAR_SYMBOL, new StringLiteral( variable ) ) );\n\n\tconst container:Container<T | GraphPattern> = new Container<T | GraphPattern>( self, tokens );\n\n\tif( self._finishDecorator === graphPatternDecorator )\n\t\treturn whereDecorator<GraphPattern, {}>( container as Container<GraphPattern>, {} );\n\treturn fromDecorator<T, {}>( container as Container<T>, {} );\n}\n\n/**\n * Set a list of variables to be retrieved by the query.\n *\n * @param variables The list of variables.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction select<T extends FinishClause>( this:Container<T>, ...variables:string[] ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT ], variables ) as FromClause<T>;\n}\n\n/**\n * Set a list of variables to be retrieved by the query ensuring no\n * repetitions in the set of solutions.\n *\n * @param variables The list of variables.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectDistinct<T extends FinishClause>( this:Container<T>, ...variables:string[] ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, DISTINCT ], variables ) as FromClause<T>;\n}\n\n/**\n * Set a list of variables to be retrieved by the query permitting\n * eliminations of non-distinct solutions, but not ensuring a set of\n * unique ones.\n *\n * @param variables The list of variables.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectReduced<T extends FinishClause>( this:Container<T>, ...variables:string[] ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, REDUCED ], variables ) as FromClause<T>;\n}\n\n/**\n * Set that the query must return all the solutions for the variables\n * used in the where pattern matching.\n *\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectAll<T extends FinishClause>( this:Container<T> ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, ALL ] ) as FromClause<T>;\n}\n\n/**\n * Set that the query must return all the solutions for the variables\n * used in the where pattern matching, ensuring there is not\n * duplicated solutions.\n *\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectAllDistinct<T extends FinishClause>( this:Container<T> ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, DISTINCT, ALL ] ) as FromClause<T>;\n}\n\n/**\n * Set that the query must return all the solutions for the variables\n * used in the where pattern matching, permitting eliminations of\n * non-distinct solutions, but not ensuring a set of unique ones.\n *\n * @returns Object with the methods to keep constructing the query.\n */\nfunction selectAllReduced<T extends FinishClause>( this:Container<T> ):FromClause<T> {\n\treturn _select<T>( this, [ SELECT, REDUCED, ALL ] ) as FromClause<T>;\n}\n\n/**\n * Decorator that binds the {@link SelectClause} methods to a\n * container and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function selectDecorator<T extends FinishClause, W extends object>( container:Container<T>, object:W ):W & SelectClause<T>;\n/**\n * Decorator that binds the {@link SubSelect} methods to a subSelect\n * container and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function selectDecorator<W extends object>( container:SubSelectContainer, object:W ):W & SubSelect;\nexport function selectDecorator<T extends FinishClause, W extends object>( container:Container<T> | SubSelectContainer, object:W ):W & (SelectClause<T> | SubSelect) {\n\treturn genericDecorator( {\n\t\tselect,\n\t\tselectDistinct,\n\t\tselectReduced,\n\t\tselectAll,\n\t\tselectAllDistinct,\n\t\tselectAllReduced,\n\t}, container, object );\n}\n"]}