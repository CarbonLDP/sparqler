{"version":3,"sources":["clauses/decorators/values.ts"],"names":[],"mappings":";;AAAA,4CAG0B;AAC1B,wDAAuD;AAKvD,wDAAuD;AACvD,8CAI2B;AAC3B,mDASkC;AAKlC,0CAGyB;AACzB,8DAAyD;AA4CzD,gBAA8E,mBAAqC,EAAE,eAAe;IACnI,IAAM,QAAQ,GAAW,CAAE,KAAK,CAAC,OAAO,CAAE,mBAAmB,CAAE,CAAC;IAChE,IAAM,SAAS,GAAY,QAAQ,GAAG,CAAE,mBAA6B,CAAE,GAAG,mBAA+B,CAAC;IAC1G,IAAM,MAAM,GAAW,CAAE,eAAM,CAAE,CAAC;IAElC,EAAE,CAAA,CAAE,QAAS,CAAC,CAAC,CAAC;QACf,MAAM,CAAC,IAAI,CAAE,mBAAU,EAAE,IAAI,sBAAa,CAAE,SAAS,CAAE,CAAC,CAAE,CAAE,EAAE,0BAAiB,CAAE,CAAC;IACnF,CAAC;IAAC,IAAI,CAAC,CAAC;QACP,MAAM,CAAC,IAAI,CAAE,yBAAgB,CAAE,CAAC;QAChC,SAAS,CAAC,OAAO,CAAE,UAAA,QAAQ,IAAI,OAAA,MAAM,CAAC,IAAI,CAAE,mBAAU,EAAE,IAAI,sBAAa,CAAE,QAAQ,CAAE,CAAE,EAAxD,CAAwD,CAAE,CAAC;QAC1F,MAAM,CAAC,IAAI,CAAE,0BAAiB,EAAE,yBAAgB,CAAE,CAAC;IACpD,CAAC;IAED,IAAI,WAAW,GAAe,KAAK,CAAC,CAAC;IACrC,IAAM,SAAS,GACd,OAAO,eAAe,KAAK,UAAU;QACpC,eAAe,CAAE,IAAI,yBAAc,CAAE,WAAW,GAAG,IAAI,yBAAW,CAAE,IAAI,CAAC,YAAY,CAAE,CAAE,CAAE;QAC3F,eAAe,CAAC;IAElB,IAAM,MAAM,GAAqB,QAAQ;QACxC,KAAK,CAAC,OAAO,CAAE,SAAS,CAAE,GAAI,SAA6B,CAAC,GAAG,CAAE,UAAA,KAAK,IAAI,OAAA,CAAE,KAAK,CAAE,EAAT,CAAS,CAAE,GAAG,CAAE,CAAE,SAAS,CAAE,CAAE;QACzG,KAAK,CAAC,OAAO,CAAE,SAAS,CAAE,CAAC,CAAE,CAAE,GAAG,SAA8B,GAAG,CAAE,SAAS,CAAuB,CAAC;IAEvG,MAAM,CAAC,OAAO,CAAE,UAAE,SAAS;QAC1B,EAAE,CAAA,CAAE,QAAS,CAAC,CAAC,CAAC;YACf,MAAM,CAAC,IAAI,OAAX,MAAM,EAAU,yBAAS,CAAE,SAAS,CAAE,CAAC,CAAE,CAAE,EAAG;QAC/C,CAAC;QAAC,IAAI,CAAC,CAAC;YACP,MAAM,CAAC,IAAI,CAAE,yBAAgB,CAAE,CAAC;YAChC,SAAS,CAAC,OAAO,CAAE,UAAA,KAAK,IAAI,OAAA,MAAM,CAAC,IAAI,OAAX,MAAM,EAAU,yBAAS,CAAE,KAAK,CAAE,GAAlC,CAAoC,CAAE,CAAC;YACnE,MAAM,CAAC,IAAI,CAAE,0BAAiB,CAAE,CAAC;QAClC,CAAC;IACF,CAAC,CAAE,CAAC;IAEJ,MAAM,CAAC,IAAI,CAAE,QAAQ,GAAG,2BAAkB,GAAG,0BAAiB,CAAE,CAAC;IAEjE,IAAM,SAAS,GAAgB,IAAI,qBAAS,CAAK,IAAI,EAAE,MAAM,EAAE,WAAW,CAAE,CAAC;IAC7E,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAE,SAAS,EAAE,EAAE,CAAE,CAAC;AAC/C,CAAC;AAUD,yBAA6F,SAAsB,EAAE,MAAQ;IAC5H,MAAM,CAAC,0BAAgB,CAAE,EAAE,MAAM,QAAA,EAAE,EAAE,SAAS,EAAE,MAAM,CAAE,CAAC;AAC1D,CAAC;AAFD,0CAEC","file":"values.js","sourcesContent":["import {\n\tgenericDecorator,\n\tValuesClause,\n} from \"sparqler/clauses\";\nimport { Container } from \"sparqler/clauses/Container\";\nimport {\n\tFinishClause,\n\tSubFinishClause,\n} from \"sparqler/clauses/interfaces\";\nimport { IRIResolver } from \"sparqler/iri/IRIResolver\";\nimport {\n\tPatternBuilder,\n\tSupportedNativeTypes,\n\tUndefined,\n} from \"sparqler/patterns\";\nimport {\n\tCLOSE_MULTI_BLOCK,\n\tCLOSE_SINGLE_BLOCK,\n\tCLOSE_SINGLE_LIST,\n\tOPEN_MULTI_BLOCK,\n\tOPEN_SINGLE_BLOCK,\n\tOPEN_SINGLE_LIST,\n\tVALUES,\n\tVAR_SYMBOL,\n} from \"sparqler/patterns/tokens\";\nimport {\n\tLiteral,\n\tResource,\n} from \"sparqler/patterns/triples\";\nimport {\n\tStringLiteral,\n\tToken,\n} from \"sparqler/tokens\";\nimport { serialize } from \"sparqler/utils/ObjectPattern\";\n\ntype PossibleTypes = SupportedNativeTypes | Resource | Literal | Undefined;\n\n/**\n * Set the values of a variable to be combined into the results query.\n *\n * @param variable Variable to add values.\n * @param values The values to be combined.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variable:string, values:SupportedNativeTypes | SupportedNativeTypes[] ):T;\n/**\n * Set the values of a variable to be combined into the results query.\n *\n * The values are constructed with a function that receives a\n * pattern builder.\n *\n * @param variable Variable to add values.\n * @param valuesBuilder Functions that returns the values to be added.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variable:string, valuesBuilder:( builder:PatternBuilder ) => ( SupportedNativeTypes | Resource | Literal | Undefined ) | ( SupportedNativeTypes | Resource | Literal | Undefined )[] ):T;\n/**\n * Set the values of multiple variables to be combined into the results\n * query.\n *\n * @param variables Variables to add values.\n * @param values The values to be combined.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variables:string[], values:SupportedNativeTypes[] | SupportedNativeTypes[][] ):T;\n/**\n * Set the values of multiple variables to be combined into the results\n * query.\n *\n * The values are constructed with a function that receives a\n * pattern builder.\n *\n * @param variables Variables to add values.\n * @param valuesBuilder Functions that returns the values to be added.\n * @returns Object with the methods to keep constructing the query.\n */\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variables:string[], valuesBuilder:( builder:PatternBuilder ) => ( SupportedNativeTypes | Resource | Literal | Undefined )[] | ( SupportedNativeTypes | Resource | Literal | Undefined )[][] ):T;\nfunction values<T extends FinishClause | SubFinishClause>( this:Container<T>, variableOrVariables:string | string[], valuesOrBuilder ):T {\n\tconst isSingle:boolean = ! Array.isArray( variableOrVariables );\n\tconst variables:string[] = isSingle ? [ variableOrVariables as string ] : variableOrVariables as string[];\n\tconst tokens:Token[] = [ VALUES ];\n\n\tif( isSingle ) {\n\t\ttokens.push( VAR_SYMBOL, new StringLiteral( variables[ 0 ] ), OPEN_SINGLE_BLOCK );\n\t} else {\n\t\ttokens.push( OPEN_SINGLE_LIST );\n\t\tvariables.forEach( variable => tokens.push( VAR_SYMBOL, new StringLiteral( variable ) ) );\n\t\ttokens.push( CLOSE_SINGLE_LIST, OPEN_MULTI_BLOCK );\n\t}\n\n\tlet iriResolver:IRIResolver = void 0;\n\tconst rawValues:PossibleTypes | PossibleTypes[] | PossibleTypes[][] =\n\t\ttypeof valuesOrBuilder === \"function\" ?\n\t\t\tvaluesOrBuilder( new PatternBuilder( iriResolver = new IRIResolver( this._iriResolver ) ) ) :\n\t\t\tvaluesOrBuilder;\n\n\tconst values:PossibleTypes[][] = isSingle ?\n\t\tArray.isArray( rawValues ) ? (rawValues as PossibleTypes[]).map( value => [ value ] ) : [ [ rawValues ] ] :\n\t\tArray.isArray( rawValues[ 0 ] ) ? rawValues as PossibleTypes[][] : [ rawValues ] as PossibleTypes[][];\n\n\tvalues.forEach( ( valuesRow ) => {\n\t\tif( isSingle ) {\n\t\t\ttokens.push( ...serialize( valuesRow[ 0 ] ) );\n\t\t} else {\n\t\t\ttokens.push( OPEN_SINGLE_LIST );\n\t\t\tvaluesRow.forEach( value => tokens.push( ...serialize( value ) ) );\n\t\t\ttokens.push( CLOSE_SINGLE_LIST );\n\t\t}\n\t} );\n\n\ttokens.push( isSingle ? CLOSE_SINGLE_BLOCK : CLOSE_MULTI_BLOCK );\n\n\tconst container:Container<T> = new Container<T>( this, tokens, iriResolver );\n\treturn this._finishDecorator( container, {} );\n}\n\n/**\n * Decorator that binds the {@link ValuesClause} methods to a\n * container and adds them to the provided object.\n *\n * @param container The container where to bind the respective methods.\n * @param object Object to be decorated with the bound methods.\n * @returns The same object provided that has been decorated.\n */\nexport function valuesDecorator<T extends FinishClause | SubFinishClause, W extends object>( container:Container<T>, object:W ):W & ValuesClause<T> {\n\treturn genericDecorator( { values }, container, object );\n}"]}