{"version":3,"sources":["data/IRIResolver.ts"],"names":[],"mappings":";;AAAA,sCAAsD;AAEtD,qDAAoD;AAEpD,iEAAgE;AAYhE;IAmBC,qBAAa,IAAiB,EAAE,KAAa;;QAC5C,IAAI,CAAC,QAAQ,GAAG,IAAI;YACnB,CAAC,CAAC,IAAI,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAE;YACpC,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC;QAEb,IAAI,CAAC,KAAK,GAAG,KAAK;YACjB,CAAC,CAAC,KAAK;YACP,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC;QAEtB,IAAI,eAAe,WAAW;YAAG,MAAM,CAAC,MAAM,CAAE,IAAI,CAAE,CAAC;IACxD,CAAC;IAWD,6BAAO,GAAP,UAAS,WAAkB,EAAE,KAAc;QAC1C,IAAI,kBAAU,CAAE,WAAW,CAAE;YAC5B,OAAO,IAAI,CAAC,eAAe,CAAE,WAAW,CAAE,CAAC;QAE5C,OAAO,IAAI,CAAC,aAAa,CAAE,WAAW,EAAE,KAAK,CAAE,CAAC;IACjD,CAAC;IAEO,mCAAa,GAArB,UAAuB,WAAkB,EAAE,KAAqB;QAArB,sBAAA,EAAA,aAAqB;QAC/D,IAAI,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,kBAAU,CAAE,WAAW,CAAE;YACnD,WAAW,GAAG,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC;QAExC,OAAO,IAAI,yBAAW,CAAE,WAAW,CAAE,CAAC;IACvC,CAAC;IAEO,qCAAe,GAAvB,UAAyB,YAAmB;QAC3C,IAAI,KAAK,GAAqB,IAAI,qCAAiB,CAAE,YAAY,CAAE,CAAC;QAEpE,IAAM,IAAI,GAAuB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,KAAK,CAAC,SAAS,CAAE,CAAC;QACtE,IAAI,IAAI,KAAK,KAAK,CAAC;YAAG,MAAM,IAAI,KAAK,CAAE,kBAAgB,KAAK,CAAC,SAAS,8BAA2B,CAAE,CAAC;QAEpG,IAAI,CAAE,IAAI;YAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,KAAK,CAAC,SAAS,EAAE,IAAI,CAAE,CAAC;QACxD,OAAO,KAAK,CAAC;IACd,CAAC;IACF,kBAAC;AAAD,CA/DA,AA+DC,IAAA;AA/DY,kCAAW","file":"IRIResolver.js","sourcesContent":["import { isPrefixed, isRelative } from \"../iri/utils\";\n\nimport { IRIRefToken } from \"../tokens/IRIRefToken\";\nimport { IRIToken } from \"../tokens/IRIToken\";\nimport { PrefixedNameToken } from \"../tokens/PrefixedNameToken\";\n\n\n/**\n * Map type of the stored prefixes used by {@link IRIResolver}.\n */\nexport type PrefixMap = Map<string, boolean>;\n\n\n/**\n * Class to manage the resolution of IRIs in tokens\n */\nexport class IRIResolver {\n\n\t/**\n\t * Map to store prefixes and information of its usage\n\t */\n\treadonly prefixes:PrefixMap;\n\n\t/**\n\t * IRI to resolve relative RDF properties\n\t */\n\treadonly vocab?:string;\n\n\t/**\n\t * Creates a new empty instance of IRIResolver if no parameter is provided, but\n\t * if a base IRIResolver is specified, its information will be copied to the new instance.\n\t *\n\t * @param base IRIResolver to copy its data from.\n\t * @param vocab Absolute IRI to change the default vocab value.\n\t */\n\tconstructor( base?:IRIResolver, vocab?:string ) {\n\t\tthis.prefixes = base\n\t\t\t? new Map( base.prefixes.entries() )\n\t\t\t: new Map();\n\n\t\tthis.vocab = vocab\n\t\t\t? vocab\n\t\t\t: base && base.vocab;\n\n\t\tif( new.target === IRIResolver ) Object.freeze( this );\n\t}\n\n\t/**\n\t * Resolves (if necessary) and creates the respective tokens if the IRI provided.\n\t *\n\t * If vocab parameter is to `true`, the stored vocab IRI is used to resolve relative IRIs.\n\t *\n\t * @param relativeIRI The relative IRI to be resolved and tokenized.\n\t * @param vocab Optional parameter to specified if the relative IRIs will be resolved with the stored vocab IRI.\n\t * @returns An array of tokens representing the provided IRI to be used in the SPARQL query.\n\t */\n\tresolve( relativeIRI:string, vocab?:boolean ):IRIToken {\n\t\tif( isPrefixed( relativeIRI ) )\n\t\t\treturn this.resolvePrefixed( relativeIRI );\n\n\t\treturn this.resolveIRIRef( relativeIRI, vocab );\n\t}\n\n\tprivate resolveIRIRef( relativeIRI:string, vocab:boolean = false ):IRIRefToken {\n\t\tif( vocab && this.vocab && isRelative( relativeIRI ) )\n\t\t\trelativeIRI = this.vocab + relativeIRI;\n\n\t\treturn new IRIRefToken( relativeIRI );\n\t}\n\n\tprivate resolvePrefixed( prefixedName:string ):PrefixedNameToken {\n\t\tlet token:PrefixedNameToken = new PrefixedNameToken( prefixedName );\n\n\t\tconst used:boolean | undefined = this.prefixes.get( token.namespace );\n\t\tif( used === void 0 ) throw new Error( `The prefix \"${ token.namespace }\" has not been declared.` );\n\n\t\tif( ! used ) this.prefixes.set( token.namespace, true );\n\t\treturn token;\n\t}\n}\n"]}