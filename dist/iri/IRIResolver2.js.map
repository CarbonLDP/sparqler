{"version":3,"sources":["iri/IRIResolver2.ts"],"names":[],"mappings":";;AAAA,iCAAkD;AAClD,sCAA2D;AAU3D;IAmBC,sBAAa,IAAkB,EAAE,KAAa;;QAC7C,IAAI,CAAC,SAAS,GAAG,IAAI;YACpB,CAAC,CAAC,IAAI,GAAG,CAAE,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,CAAE;YACrC,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC;QAEb,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QAE1D,IAAI,eAAe,YAAY;YAAG,MAAM,CAAC,MAAM,CAAE,IAAI,CAAE,CAAC;IACzD,CAAC;IAWD,8BAAO,GAAP,UAAS,WAAkB,EAAE,KAAc;QAC1C,IAAI,kBAAU,CAAE,WAAW,CAAE;YAC5B,OAAO,IAAI,CAAC,eAAe,CAAE,WAAW,CAAE,CAAC;QAE5C,OAAO,IAAI,CAAC,UAAU,CAAE,WAAW,EAAE,KAAK,CAAE,CAAC;IAC9C,CAAC;IAED,iCAAU,GAAV,UAAY,WAAkB,EAAE,KAAqB;QAArB,sBAAA,EAAA,aAAqB;QACpD,IAAI,KAAK,IAAI,IAAI,CAAC,MAAM,IAAI,kBAAU,CAAE,WAAW,CAAE;YACpD,WAAW,GAAG,IAAI,CAAC,MAAM,GAAG,WAAW,CAAC;QAEzC,OAAO,IAAI,iBAAQ,CAAE,WAAW,CAAE,CAAC;IACpC,CAAC;IAED,sCAAe,GAAf,UAAiB,YAAmB;QACnC,IAAI,KAAK,GAAqB,IAAI,0BAAiB,CAAE,YAAY,CAAE,CAAC;QAEpE,IAAM,IAAI,GAAuB,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,KAAK,CAAC,SAAS,CAAE,CAAC;QACvE,IAAI,IAAI,KAAK,KAAK,CAAC;YAAG,MAAM,IAAI,KAAK,CAAE,kBAAgB,KAAK,CAAC,SAAS,8BAA2B,CAAE,CAAC;QAEpG,IAAI,CAAE,IAAI;YAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,KAAK,CAAC,SAAS,EAAE,IAAI,CAAE,CAAC;QACzD,OAAO,KAAK,CAAC;IACd,CAAC;IACF,mBAAC;AAAD,CA7DA,AA6DC,IAAA;AA7DY,oCAAY","file":"IRIResolver2.js","sourcesContent":["import { isPrefixed, isRelative, } from \"./utils\";\nimport { IRIToken, PrefixedNameToken, } from \"./../tokens\";\n\n/**\n * Map type of the stored prefixes used by {@link IRIResolver}.\n */\nexport type PrefixMap = Map<string, boolean>;\n\n/**\n * Class to manage the resolution of IRIs in tokens\n */\nexport class IRIResolver2 {\n\n\t/**\n\t * Map to store prefixes and information of its usage\n\t */\n\treadonly _prefixes:PrefixMap;\n\n\t/**\n\t * IRI to resolve relative RDF properties\n\t */\n\treadonly _vocab?:string;\n\n\t/**\n\t * Creates a new empty instance of IRIResolver if no parameter is provided, but\n\t * if a base IRIResolver is specified, its information will be copied to the new instance.\n\t *\n\t * @param base IRIResolver to copy its data from.\n\t * @param vocab Absolute IRI to change the default vocab value.\n\t */\n\tconstructor( base?:IRIResolver2, vocab?:string ) {\n\t\tthis._prefixes = base\n\t\t\t? new Map( base._prefixes.entries() )\n\t\t\t: new Map();\n\n\t\tthis._vocab = vocab ? vocab : base ? base._vocab : void 0;\n\n\t\tif( new.target === IRIResolver2 ) Object.freeze( this );\n\t}\n\n\t/**\n\t * Resolves (if necessary) and creates the respective tokens if the IRI provided.\n\t *\n\t * If vocab parameter is to `true`, the stored vocab IRI is used to resolve relative IRIs.\n\t *\n\t * @param relativeIRI The relative IRI to be resolved and tokenized.\n\t * @param vocab Optional parameter to specified if the relative IRIs will be resolved with the stored vocab IRI.\n\t * @returns An array of tokens representing the provided IRI to be used in the SPARQL query.\n\t */\n\tresolve( relativeIRI:string, vocab?:boolean ):IRIToken | PrefixedNameToken {\n\t\tif( isPrefixed( relativeIRI ) )\n\t\t\treturn this.resolvePrefixed( relativeIRI );\n\n\t\treturn this.resolveIRI( relativeIRI, vocab );\n\t}\n\n\tresolveIRI( relativeIRI:string, vocab:boolean = false ):IRIToken {\n\t\tif( vocab && this._vocab && isRelative( relativeIRI ) )\n\t\t\trelativeIRI = this._vocab + relativeIRI;\n\n\t\treturn new IRIToken( relativeIRI );\n\t}\n\n\tresolvePrefixed( prefixedName:string ):PrefixedNameToken {\n\t\tlet token:PrefixedNameToken = new PrefixedNameToken( prefixedName );\n\n\t\tconst used:boolean | undefined = this._prefixes.get( token.namespace );\n\t\tif( used === void 0 ) throw new Error( `The prefix \"${ token.namespace }\" has not been declared.` );\n\n\t\tif( ! used ) this._prefixes.set( token.namespace, true );\n\t\treturn token;\n\t}\n}\n"]}