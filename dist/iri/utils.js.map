{"version":3,"sources":["iri/utils.ts"],"names":[],"mappings":";;AACA,yDAAwD;AACxD,6CAG4B;AAE5B,oBAA4B,GAAU;IACrC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAE,GAAG,CAAE,KAAK,CAAE,CAAC,CAAC;AACnC,CAAC;AAFD,gCAEC;AAED,qBAA6B,GAAU;IACtC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAE,KAAK,CAAE,KAAK,CAAE,CAAC,CAAC;AACrC,CAAC;AAFD,kCAEC;AAED,oBAA4B,GAAU;IACrC,MAAM,CAAC,CAAE,UAAU,CAAE,GAAG,CAAE,CAAC;AAC5B,CAAC;AAFD,gCAEC;AAED,eAAuB,GAAU;IAChC,MAAM,CAAC,WAAW,CAAE,GAAG,CAAE,IAAI,CAAE,UAAU,CAAE,GAAG,CAAE,CAAC;AAClD,CAAC;AAFD,sBAEC;AAED,IAAM,cAAc,GAAU,mDAAmD,CAAC;AAElF,sBAA8B,KAAY;IACzC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAE,KAAK,CAAE,CAAC;AACrC,CAAC;AAFD,oCAEC;AAED,IAAI,WAAW,GAAU,mDAAmD,CAAC;AAC7E,IAAI,oBAAoB,GAAU,6BAA6B,CAAC;AAEhE,oBAA4B,GAAU;IACrC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAE,GAAG,CAAE,IAAI,CAAE,WAAW,CAAE,GAAG,CAAE,CAAC;AACpD,CAAC;AAFD,gCAEC;AAED,0BAAkC,GAAU;IAC3C,IAAI,KAAK,GAAmB,WAAW,CAAC,IAAI,CAAE,GAAG,CAAE,CAAC;IACpD,EAAE,CAAA,CAAE,KAAK,KAAK,IAAI,IAAI,WAAW,CAAE,GAAG,CAAG,CAAC;QAAC,MAAM,CAAC,IAAI,CAAC;IAEvD,IAAI,MAAM,GAAU,KAAK,CAAE,CAAC,CAAE,IAAI,EAAE,CAAC;IACrC,IAAI,KAAK,GAAU,GAAG,CAAC,MAAM,CAAE,MAAM,CAAC,MAAM,GAAG,CAAC,CAAE,CAAC,OAAO,CAAE,oBAAoB,EAAE,MAAM,CAAE,CAAC;IAE3F,MAAM,CAAC;QACN,MAAM;QACN,KAAK;KACL,CAAC;AACH,CAAC;AAXD,4CAWC;AAQD,iBAAyB,GAAU,EAAE,KAAa;IACjD,IAAI,MAAM,GAAW,CAAE,IAAI,6BAAa,CAAE,GAAG,CAAE,CAAE,CAAC;IAElD,EAAE,CAAA,CAAE,KAAK,CAAE,GAAG,CAAG,CAAC,CAAC,CAAC;QACnB,EAAE,CAAA,CAAE,UAAU,CAAE,GAAG,CAAE,IAAI,KAAM,CAAC;YAC/B,GAAG,GAAG,KAAK,GAAG,GAAG,CAAC;QACnB,MAAM,GAAG,CAAE,iBAAQ,EAAE,IAAI,6BAAa,CAAE,GAAG,CAAE,EAAE,kBAAS,CAAE,CAAC;IAC5D,CAAC;IAED,MAAM,CAAC,MAAM,CAAC;AACf,CAAC;AAVD,0BAUC","file":"utils.js","sourcesContent":["import { Token } from \"../tokens/Token\";\nimport { StringLiteral } from \"../tokens/StringLiteral\";\nimport {\n\tOPEN_IRI,\n\tCLOSE_IRI,\n} from \"../patterns/tokens\";\n\nexport function isAbsolute( iri:string ):boolean {\n\treturn iri.indexOf( \":\" ) !== - 1;\n}\n\nexport function hasProtocol( iri:string ):boolean {\n\treturn iri.indexOf( \"://\" ) !== - 1;\n}\n\nexport function isRelative( iri:string ):boolean {\n\treturn ! isAbsolute( iri );\n}\n\nexport function isIRI( iri:string ):boolean {\n\treturn hasProtocol( iri ) || ! isAbsolute( iri );\n}\n\nconst BN_LABEL_REGEX:RegExp = /^_:[A-Za-z0-9_]([A-Za-z0-9_\\-.]*[A-Za-z0-9_\\-])?$/;\n\nexport function isBNodeLabel( label:string ):boolean {\n\treturn BN_LABEL_REGEX.test( label );\n}\n\nlet prefixRegex:RegExp = /([A-Za-z](([A-Za-z_\\-0-9]|\\.)*[A-Za-z_\\-0-9])?)?:/;\nlet prefixNormalizeRegex:RegExp = /([_~.\\-!$&'|()*+,;=/?#@%])/g;\n\nexport function isPrefixed( iri:string ):boolean {\n\treturn iri.includes( \":\" ) && ! hasProtocol( iri );\n}\n\nexport function getPrefixedParts( iri:string ):[ string, string ] {\n\tlet parts:RegExpExecArray = prefixRegex.exec( iri );\n\tif( parts === null || hasProtocol( iri ) ) return null;\n\n\tlet prefix:string = parts[ 1 ] || \"\";\n\tlet local:string = iri.substr( prefix.length + 1 ).replace( prefixNormalizeRegex, \"\\\\$1\" );\n\n\treturn [\n\t\tprefix,\n\t\tlocal,\n\t];\n}\n\n/**\n * Check if the provided is an IRI to surround it with '<>'.\n * @param iri String to check.\n * @param vocab Optional parameter that indicates the vocab to resolve relative IRIs.\n * @returns {string}\n */\nexport function resolve( iri:string, vocab?:string ):Token[] {\n\tlet tokens:Token[] = [ new StringLiteral( iri ) ];\n\n\tif( isIRI( iri ) ) {\n\t\tif( isRelative( iri ) && vocab )\n\t\t\tiri = vocab + iri;\n\t\ttokens = [ OPEN_IRI, new StringLiteral( iri ), CLOSE_IRI ];\n\t}\n\n\treturn tokens;\n}\n"]}