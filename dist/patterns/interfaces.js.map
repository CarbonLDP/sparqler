{"version":3,"sources":["patterns/interfaces.ts"],"names":[],"mappings":"","file":"interfaces.js","sourcesContent":["import { SubSelectClause } from \"./../clauses\";\nimport { Undefined } from \"./\";\nimport { NotTriplesPattern } from \"./notTriples\";\nimport {\n\tBlankNode,\n\tBooleanLiteral,\n\tCollection,\n\tLiteral,\n\tNumericLiteral,\n\tRDFLiteral,\n\tResource,\n\tVariable,\n} from \"./triples\";\nimport { Token } from \"./../tokens\";\n\nexport interface ElementPattern {\n\tgetSelfTokens():Token[];\n}\n\nexport interface GraphPattern {\n\tgetPattern():Token[];\n}\n\nexport interface NotTriplesPatternBuilder {\n\tgraph( iri:string, pattern:GraphPattern ):NotTriplesPattern;\n\tgraph( iri:string, patterns:GraphPattern[] ):NotTriplesPattern;\n\n\tgraph( variable:Variable, pattern:GraphPattern ):NotTriplesPattern;\n\tgraph( variable:Variable, patterns:GraphPattern[] ):NotTriplesPattern;\n\n\toptional( pattern:GraphPattern ):NotTriplesPattern;\n\toptional( patterns:GraphPattern[] ):NotTriplesPattern;\n\n\tunion( pattern1:GraphPattern, pattern2:GraphPattern ):NotTriplesPattern;\n\tunion( pattern1:GraphPattern, patterns2:GraphPattern[] ):NotTriplesPattern;\n\tunion( patterns1:GraphPattern[], pattern2:GraphPattern ):NotTriplesPattern;\n\tunion( patterns1:GraphPattern[], patterns2:GraphPattern[] ):NotTriplesPattern;\n\n\tminus( pattern:GraphPattern ):NotTriplesPattern;\n\tminus( firstPattern:GraphPattern, ...restPatterns:GraphPattern[] ):NotTriplesPattern;\n\n\tundefined:Undefined;\n\tvalues( variable:Variable ):SingleValuesPattern\n\tvalues( ...variables:Variable[] ):MultipleValuesPattern;\n\n\tservice( resource:string | Resource | Variable, patterns:GraphPattern | GraphPattern[] ):NotTriplesPattern;\n\tserviceSilent( resource:string | Resource | Variable, patterns:GraphPattern | GraphPattern[] ):NotTriplesPattern;\n\n\t// TODO: Add expression support for this patterns\n\tbind( rawExpression:string, variable:string | Variable ):NotTriplesPattern;\n\tfilter( rawConstraint:string ):NotTriplesPattern;\n}\n\nexport interface SingleValuesPattern extends NotTriplesPattern {\n\thas( value:SupportedNativeTypes ):SingleValuesPatternMore;\n\thas( value:Resource ):SingleValuesPatternMore;\n\thas( value:Literal ):SingleValuesPatternMore;\n\thas( value:Undefined ):SingleValuesPatternMore;\n}\nexport interface SingleValuesPatternMore extends NotTriplesPattern {\n\tand( value:SupportedNativeTypes ):SingleValuesPatternMore;\n\tand( value:Resource ):SingleValuesPatternMore;\n\tand( value:Literal ):SingleValuesPatternMore;\n\tand( value:Undefined ):SingleValuesPatternMore;\n}\n\nexport interface MultipleValuesPattern extends NotTriplesPattern {\n\thas( ...values:( SupportedNativeTypes | Resource | Literal | Undefined )[] ):MultipleValuesPatternMore;\n}\nexport interface MultipleValuesPatternMore extends NotTriplesPattern {\n\tand( ...values:( SupportedNativeTypes | Resource | Literal | Undefined )[] ):MultipleValuesPatternMore;\n}\n\nexport type SupportedNativeTypes = boolean | number | string | Date;\n\nexport interface TriplesPatternBuilder {\n\tresource( iri:string ):Resource;\n\n\tvar( name:string ):Variable;\n\n\tliteral( value:string ):RDFLiteral;\n\tliteral( value:number ):NumericLiteral;\n\tliteral( value:boolean ):BooleanLiteral;\n\n\tcollection( ...values:( SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern )[] ):Collection;\n\n\t/**\n\t * With this form, there is no current way to form the pattern:\n\t *  [ ?var1 \"ex:some-1\" \"Object\" ] \"ex:some-2\" ?object.\n\t *\n\t * Should add method for this cases??\n\t *    blankNode().has( \"ex:prop-1\", \"someone\" )\n\t *      .asTripleSubject()\n\t *      .has( \"ex:prop-2\", \"another-one\" )\n\t *  */\n\tblankNode():BlankNode;\n}\n\n// TODO: Create and accept PATHs as property\nexport interface TriplesSameSubject<T> {\n\thas( property:string | Variable | Resource, object:SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern ):TriplesSameSubjectMore<T> & T;\n\thas( property:string | Variable | Resource, objects:(SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern)[] ):TriplesSameSubjectMore<T> & T;\n}\n\n// TODO: Create and accept PATHs as property\nexport interface TriplesSameSubjectMore<T> {\n\tand( property:string | Variable | Resource, object:SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern ):TriplesSameSubjectMore<T> & T;\n\tand( property:string | Variable | Resource, objects:(SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern)[] ):TriplesSameSubjectMore<T> & T;\n}\n\nexport interface TriplesNodePattern extends GraphPattern, ElementPattern {}\n\n"],"sourceRoot":"../../src"}