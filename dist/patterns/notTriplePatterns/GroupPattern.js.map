{"version":3,"sources":["patterns/notTriplePatterns/GroupPattern.ts"],"names":[],"mappings":";;AAAA,kDAAiD;AAEjD,oEAAmE;AACnE,oEAAmE;AAInE,uDAAsD;AACtD,+CAA8C;AAkB9C,SAAS,UAAU,CAAE,SAAsC;IAC1D,OAAO,UAAA,QAAQ;;QACd,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAE,QAAQ,CAAE,CAAC;QAC/D,IAAM,aAAa,GAAqB,IAAI,qCAAiB,EAAE,CAAC;QAChE,CAAA,KAAA,aAAa,CAAC,QAAQ,CAAA,CAAC,IAAI,WAAK,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,EAAd,CAAc,CAAE,EAAG;QAEtE,IAAM,UAAU,GAAqB,IAAI,qCAAiB,EAAE,CAAC;QAC7D,UAAU,CAAC,aAAa,CAAC,IAAI,CAAE,SAAS,CAAC,WAAW,EAAE,aAAa,CAAE,CAAC;QAEtE,IAAM,YAAY,GAAG,IAAI,qBAAS,CAAE;YACnC,WAAW,EAAE,SAAS,CAAC,WAAW;YAClC,WAAW,EAAE,UAAU;SACvB,CAAE,CAAC;QACJ,OAAO,2BAAY,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IACpD,CAAC,CAAA;AACF,CAAC;AAMY,QAAA,YAAY,GAcrB;IACH,UAAU,EAAV,UAAsE,SAAW,EAAE,MAAQ;QAC1F,OAAO,mCAAgB,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YACrE,KAAK,EAAE,UAAU,CAAE,SAAS,CAAE;SAC9B,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"GroupPattern.js","sourcesContent":["import { Container } from \"../../data/Container\";\n\nimport { GroupPatternToken } from \"../../tokens/GroupPatternToken\";\nimport { UnionPatternToken } from \"../../tokens/UnionPatternToken\";\n\nimport { Pattern } from \"../Pattern\";\n\nimport { NotTriplePattern } from \"./NotTriplePattern\";\nimport { UnionPattern } from \"./UnionPattern\";\n\n\n/**\n * Wrapper for easier usage of SPARQL group patterns.\n */\nexport interface GroupPattern extends NotTriplePattern<GroupPatternToken> {\n\tunion( patterns:Pattern | Pattern[] ):UnionPattern;\n}\n\n\n/**\n * Function that creates a generic {@link GroupPattern.union} function.\n *\n * @param container The container with the query data for the statement.\n *\n * @private\n */\nfunction getUnionFn( container:Container<GroupPatternToken> ):GroupPattern[ \"union\" ] {\n\treturn patterns => {\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\tconst newGroupToken:GroupPatternToken = new GroupPatternToken();\n\t\tnewGroupToken.patterns.push( ...patterns.map( x => x.getPattern() ) );\n\n\t\tconst unionToken:UnionPatternToken = new UnionPatternToken();\n\t\tunionToken.groupPatterns.push( container.targetToken, newGroupToken );\n\n\t\tconst newContainer = new Container( {\n\t\t\tiriResolver: container.iriResolver,\n\t\t\ttargetToken: unionToken,\n\t\t} );\n\t\treturn UnionPattern.createFrom( newContainer, {} );\n\t}\n}\n\n\n/**\n * Constant with utils for {@link GroupPattern} objects.\n */\nexport const GroupPattern:{\n\t/**\n\t * Factory function that allows to crete a {@link GroupPattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link GroupPattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link GroupPattern} statement.\n\t *\n\t * @return The {@link GroupPattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<GroupPatternToken>, O extends object>( container:C, object:O ):GroupPattern;\n} = {\n\tcreateFrom<C extends Container<GroupPatternToken>, O extends object>( container:C, object:O ):GroupPattern {\n\t\treturn NotTriplePattern.createFrom( container, Object.assign( object, {\n\t\t\tunion: getUnionFn( container ),\n\t\t} ) );\n\t}\n};"]}