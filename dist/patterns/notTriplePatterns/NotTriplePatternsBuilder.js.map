{"version":3,"sources":["patterns/notTriplePatterns/NotTriplePatternsBuilder.ts"],"names":[],"mappings":"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","file":"NotTriplePatternsBuilder.js","sourcesContent":["import { Container } from \"../../data/Container\";\n\nimport { BindToken } from \"../../tokens/BindToken\";\nimport { FilterToken } from \"../../tokens/FilterToken\";\nimport { GraphToken } from \"../../tokens/GraphToken\";\nimport { GroupPatternToken } from \"../../tokens/GroupPatternToken\";\nimport { MinusPatternToken } from \"../../tokens/MinusPatternToken\";\nimport { NotTripleToken } from \"../../tokens/NotTripleToken\";\nimport { OptionalToken } from \"../../tokens/OptionalToken\";\nimport { ServicePatternToken } from \"../../tokens/ServicePatternToken\";\nimport { UnionPatternToken } from \"../../tokens/UnionPatternToken\";\nimport { ValuesToken } from \"../../tokens/ValuesToken\";\nimport { VariableToken } from \"../../tokens/VariableToken\";\n\nimport { Pattern } from \"../Pattern\";\nimport { Resource } from \"../triplePatterns/Resource\";\nimport { Variable } from \"../triplePatterns/Variable\";\nimport { Undefined } from \"../Undefined\";\n\nimport { BindPattern } from \"./BindPattern\";\nimport { FilterPattern } from \"./FilterPattern\";\nimport { GraphPattern } from \"./GraphPattern\";\nimport { GroupPattern } from \"./GroupPattern\";\nimport { MinusPattern } from \"./MinusPattern\";\nimport { MultipleValuesPattern } from \"./MultipleValuesPattern\";\nimport { NotTriplePattern } from \"./NotTriplePattern\";\nimport { OptionalPattern } from \"./OptionalPattern\";\nimport { ServicePattern } from \"./ServicePattern\";\nimport { SingleValuesPattern } from \"./SingleValuesPattern\";\nimport { UnionPattern } from \"./UnionPattern\";\n\n\n/**\n * Builder for non triple based patterns.\n */\nexport interface NotTriplePatternsBuilder {\n\t/**\n\t * Property por a quickly access to the `\"UNDEF\"` keyword.\n\t */\n\tundefined:Undefined;\n\n\t/**\n\t * Creates a {@link GraphPattern} for the target named graph\n\t * specified by {@param iri}, having the patterns specified.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#accessByLabel}\n\t * for more information.\n\t *\n\t * @param iri The target graph to have the patterns.\n\t * @param patterns The patterns to match for the target graph.\n\t */\n\tgraph( iri:string | Resource | Variable, patterns:Pattern | Pattern[] ):GraphPattern;\n\n\t/**\n\t * Creates a {@link GroupPattern} for the patterns specified,\n\t * where will group the patterns in a new pattern.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#GroupPatterns}\n\t * for more information.\n\t *\n\t * @param patterns The patterns to be enclosed in a group.\n\t */\n\tgroup( patterns:Pattern | Pattern[] ):GroupPattern;\n\n\t/**\n\t * Creates a {@link UnionPattern} for the patterns specified,\n\t * where will group the pattern to be used as an alternative\n\t * matching for another group declared by the subsequents\n\t * {@link UnionPattern.and} methods.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#alternatives}\n\t * for more information.\n\t *\n\t * @param patterns The patterns to be enclosed in a group.\n\t */\n\tunion( patterns:Pattern | Pattern[] ):UnionPattern;\n\n\t/**\n\t * Creates an {@link OptionalPattern} for the patterns specified,\n\t * which will be considered as optional to match and retrieve.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#optionals}\n\t * for more information.\n\t *\n\t * @param patterns The patterns to be enclosed in a optional\n\t * group.\n\t */\n\toptional( patterns:Pattern | Pattern[] ):OptionalPattern;\n\n\t/**\n\t * Creates a {@link MinusPattern} for the patterns specified\n\t * which will be excluded from the query.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#neg-minus}\n\t * for more information.\n\t *\n\t * @param patterns The patterns to be enclosed in a minus\n\t * group.\n\t */\n\tminus( patterns:Pattern | Pattern[] ):MinusPattern;\n\n\t/**\n\t * Creates a {@link ServicePattern} for the target resource\n\t * service and the patterns specified.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-federated-query/}\n\t * for more information.\n\t *\n\t * @param resource The service where to execute the federated\n\t * query.\n\t * @param patterns The patterns of the target service.\n\t */\n\tservice( resource:string | Resource | Variable, patterns:Pattern | Pattern[] ):ServicePattern;\n\t/**\n\t * Creates a silent {@link ServicePattern} for the target resource\n\t * service and the patterns specified.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-federated-query/}\n\t * for more information.\n\t *\n\t * @param resource The service where to execute the federated\n\t * query.\n\t * @param patterns The patterns of the target service.\n\t */\n\tserviceSilent( resource:string | Resource | Variable, patterns:Pattern | Pattern[] ):ServicePattern;\n\n\n\t/**\n\t * Create a {@link FilterPattern} for the raw constraint.\n\t *\n\t * This is used to exclude values or entire patterns.\n\t * See {@link https://www.w3.org/TR/sparql11-query/#termConstraint\n     * and {@link https://www.w3.org/TR/sparql11-query/#negation} to\n\t * know more.\n\t *\n\t * @param rawConstraint The RAW constraint to filter.\n\t */\n\tfilter( rawConstraint:string ):FilterPattern;\n\n\t/**\n\t * Created a {@link BindPattern} for the raw expression\n\t * into the variable specified.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#bind}\n\t * for more information.\n\t *\n\t * @param rawExpression The RAW expression to assign.\n\t * @param variable The variable to be assigned.\n\t */\n\t// TODO: Add expression support for this patterns\n\tbind( rawExpression:string, variable:string | Variable ):BindPattern;\n\n\t/**\n\t * Create a {@link SingleValuesPattern} for the variable\n\t * specified.\n\t *\n\t * This is used to assign data to an specific variable.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#inline-data}\n\t * for more information.\n\t *\n\t * @param variable The variable to assign data.\n\t */\n\tvalues( variable:Variable ):SingleValuesPattern;\n\t/**\n\t * Create a {@link MultipleValuesPattern} for the variables\n\t * specified.\n\t *\n\t * This is used to assign data to multiple variables.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#inline-data}\n\t * for more information.\n\t *\n\t * @param variables The variables to assign data.\n\t */\n\tvalues( ...variables:Variable[] ):MultipleValuesPattern;\n}\n\n\nfunction _getPatternContainer<T extends NotTripleToken>( container:Container<undefined>, targetToken:T ):Container<T> {\n\treturn new Container( {\n\t\tiriResolver: container.iriResolver,\n\t\ttargetToken,\n\t} )\n}\n\nfunction _getPattern<T extends NotTripleToken>( container:Container<undefined>, token:T ):NotTriplePattern<T> {\n\tconst patternContainer = _getPatternContainer( container, token );\n\treturn NotTriplePattern.createFrom( patternContainer, {} );\n}\n\n\nfunction getGraphFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"graph\" ] {\n\treturn ( iriOrVariable:string | Resource | Variable, patterns:Pattern | Pattern[] ) => {\n\t\tconst varOrIRI = typeof iriOrVariable === \"string\" ?\n\t\t\tcontainer.iriResolver.resolve( iriOrVariable ) :\n\t\t\tiriOrVariable.getSubject();\n\n\t\tconst token:GraphToken = new GraphToken( varOrIRI );\n\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\ttoken.addPattern( ...patterns.map( x => x.getPattern() ) );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\nfunction getGroupFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"group\" ] {\n\treturn ( patterns:Pattern | Pattern[] ) => {\n\t\tconst token:GroupPatternToken = new GroupPatternToken();\n\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\ttoken.patterns.push( ...patterns.map( x => x.getPattern() ) );\n\n\t\tconst patternContainer = _getPatternContainer( container, token );\n\t\treturn GroupPattern.createFrom( patternContainer, {} );\n\t}\n}\n\nfunction getUnionFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"union\" ] {\n\treturn ( patterns:Pattern | Pattern[] ) => {\n\t\tconst token:UnionPatternToken = new UnionPatternToken();\n\n\t\tconst patternContainer = _getPatternContainer( container, token );\n\t\tconst unionPattern:UnionPattern = UnionPattern\n\t\t\t.createFrom( patternContainer, {} );\n\n\t\treturn unionPattern.and( patterns );\n\t}\n}\n\nfunction getOptionalFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"optional\" ] {\n\treturn ( patterns:Pattern | Pattern[] ) => {\n\t\tconst token:OptionalToken = new OptionalToken();\n\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\ttoken.addPattern( ...patterns.map( x => x.getPattern() ) );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\nfunction getMinusFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"minus\" ] {\n\treturn ( patterns:Pattern | Pattern[] ) => {\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\n\t\tconst token:MinusPatternToken = new MinusPatternToken();\n\t\ttoken.groupPattern.patterns\n\t\t\t.push( ...patterns.map( x => x.getPattern() ) );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\nfunction getServiceFn( container:Container<undefined>, modifier?:\"SILENT\" ):NotTriplePatternsBuilder[ \"service\" ] {\n\treturn ( resource:string | Resource | Variable, patterns:Pattern | Pattern[] ) => {\n\t\tconst varOrIRI = typeof resource === \"string\" ?\n\t\t\tcontainer.iriResolver.resolve( resource ) :\n\t\t\tresource.getSubject();\n\n\t\tconst token:ServicePatternToken = new ServicePatternToken( varOrIRI, modifier );\n\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\ttoken.groupPattern.patterns\n\t\t\t.push( ...patterns.map( x => x.getPattern() ) );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\n\nfunction getFilterFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"filter\" ] {\n\treturn ( rawConstraint:string ) => {\n\t\tconst token:FilterToken = new FilterToken( rawConstraint );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\nfunction getBindFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"bind\" ] {\n\treturn ( rawExpression:string, variable:string | Variable ) => {\n\t\tconst parsedVar = typeof variable === \"string\" ?\n\t\t\tnew VariableToken( variable ) :\n\t\t\tvariable.getSubject();\n\n\t\tconst token:BindToken = new BindToken( rawExpression, parsedVar );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\nfunction getValuesFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"values\" ] {\n\treturn ( ...variables:Variable[] ) => {\n\t\tconst token:ValuesToken = new ValuesToken();\n\t\ttoken.variables.push( ...variables.map( x => x.getSubject() ) );\n\n\t\tconst patternContainer = _getPatternContainer( container, token );\n\n\t\tif( variables.length === 1 )\n\t\t\treturn SingleValuesPattern\n\t\t\t\t.createFrom( patternContainer, {} );\n\n\t\treturn MultipleValuesPattern\n\t\t\t.createFrom( patternContainer, {} );\n\t}\n}\n\n\n/**\n * Constant with the utils for {@link NotTriplePatternsBuilder} objects.\n */\nexport const NotTriplePatternsBuilder:{\n\t/**\n\t * Factory function that allows to crete a {@link NotTriplePatternsBuilder}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link NotTriplePatternsBuilder} statement.\n\t * @param object The base base from where to create the\n\t * {@link NotTriplePatternsBuilder} statement.\n\t *\n\t * @return The {@link NotTriplePatternsBuilder} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<O extends object>( container:Container<undefined>, object:O ):O & NotTriplePatternsBuilder;\n} = {\n\tcreateFrom<O extends object>( container:Container<undefined>, object:O ):O & NotTriplePatternsBuilder {\n\t\treturn Object.assign( object, {\n\t\t\tundefined: \"UNDEF\" as \"UNDEF\",\n\n\t\t\tgraph: getGraphFn( container ),\n\t\t\tgroup: getGroupFn( container ),\n\t\t\tunion: getUnionFn( container ),\n\t\t\toptional: getOptionalFn( container ),\n\t\t\tminus: getMinusFn( container ),\n\t\t\tservice: getServiceFn( container ),\n\t\t\tserviceSilent: getServiceFn( container, \"SILENT\" ),\n\n\t\t\tfilter: getFilterFn( container ),\n\t\t\tbind: getBindFn( container ),\n\t\t\tvalues: getValuesFn( container ),\n\t\t} )\n\t},\n};"]}