{"version":3,"sources":["patterns/notTriplePatterns/SingleValuesPattern.ts"],"names":[],"mappings":";;AACA,0CAAgD;AAOhD,kCAAwC;AAExC,uDAAsD;AAqBtD,SAAS,QAAQ,CAAqC,SAAW;IAChE,OAAO,UAAA,KAAK;QACX,IAAM,MAAM,GAAG,SAAS,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;QACpD,IAAI,CAAE,MAAM,CAAC,MAAM;YAAG,MAAM,CAAC,IAAI,CAAE,EAAE,CAAE,CAAC;QACxC,MAAM,CAAE,CAAC,CAAE,GAAG,MAAM,CAAE,CAAC,CAAE,CAAC,MAAM,CAAE,oBAAY,CAAE,KAA6B,CAAE,CAAE,CAAC;QAElF,IAAM,WAAW,GAAG,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,MAAM,QAAA,EAAE,CAAE,CAAC;QACtE,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;QAE9E,OAAO,8BAAsB,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IAC9D,CAAC,CAAC;AACH,CAAC;AAMY,QAAA,mBAAmB,GAAG;IAClC,UAAU,EAAV,UAAiE,SAAW,EAAE,MAAQ;QACrF,OAAO,mCAAgB,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YACrE,GAAG,EAAE,QAAQ,CAAE,SAAS,CAAE;SAC1B,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC;AAKW,QAAA,sBAAsB,GAAG;IACrC,UAAU,EAAV,UAAiE,SAAW,EAAE,MAAQ;QACrF,OAAO,mCAAgB,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YACrE,GAAG,EAAE,QAAQ,CAAE,SAAS,CAAE;SAC1B,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"SingleValuesPattern.js","sourcesContent":["import { Container2 } from \"../../data/Container2\";\nimport { cloneElement } from \"../../data/utils\";\n\nimport { ValuesToken } from \"../../tokens/ValuesToken\";\nimport { SupportedNativeTypes } from \"../SupportedNativeTypes\";\nimport { Literal } from \"../triplePatterns/Literal\";\nimport { Resource } from \"../triplePatterns/Resource\";\nimport { Undefined } from \"../Undefined\";\nimport { convertValue } from \"../utils\";\n\nimport { NotTriplePattern } from \"./NotTriplePattern\";\n\n\n/**\n * @todo\n */\nexport interface SingleValuesPattern extends NotTriplePattern<ValuesToken> {\n\thas( value:SupportedNativeTypes | Resource | Literal | Undefined ):SingleValuesPatternAnd;\n}\n\n/**\n * @todo\n */\nexport interface SingleValuesPatternAnd extends NotTriplePattern<ValuesToken> {\n\tand( value:SupportedNativeTypes | Resource | Literal | Undefined ):SingleValuesPatternAnd;\n}\n\n\n/**\n * @todo\n */\nfunction getHasFn<C extends Container2<ValuesToken>>( container:C ):SingleValuesPattern[ \"has\" ] {\n\treturn value => {\n\t\tconst values = container.targetToken.values.slice();\n\t\tif( ! values.length ) values.push( [] );\n\t\tvalues[ 0 ] = values[ 0 ].concat( convertValue( value as SupportedNativeTypes ) );\n\n\t\tconst targetToken = cloneElement( container.targetToken, { values } );\n\t\tconst newContainer = cloneElement( container, { targetToken } as Partial<C> );\n\n\t\treturn SingleValuesPatternAnd.createFrom( newContainer, {} );\n\t};\n}\n\n\n/**\n * @todo\n */\nexport const SingleValuesPattern = {\n\tcreateFrom<C extends Container2<ValuesToken>, O extends object>( container:C, object:O ):SingleValuesPattern {\n\t\treturn NotTriplePattern.createFrom( container, Object.assign( object, {\n\t\t\thas: getHasFn( container ),\n\t\t} ) );\n\t},\n};\n\n/**\n * @todo\n */\nexport const SingleValuesPatternAnd = {\n\tcreateFrom<C extends Container2<ValuesToken>, O extends object>( container:C, object:O ):SingleValuesPatternAnd {\n\t\treturn NotTriplePattern.createFrom( container, Object.assign( object, {\n\t\t\tand: getHasFn( container ),\n\t\t} ) );\n\t},\n};\n"]}