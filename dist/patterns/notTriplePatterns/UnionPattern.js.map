{"version":3,"sources":["patterns/notTriplePatterns/UnionPattern.ts"],"names":[],"mappings":";;AAAA,kDAAiD;AACjD,0CAAgD;AAEhD,oEAAmE;AAInE,uDAAsD;AAiBtD,SAAS,QAAQ,CAAE,SAAsC;IACxD,OAAO,UAAA,QAAQ;;QACd,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAE,QAAQ,CAAE,CAAC;QAC/D,IAAM,aAAa,GAAqB,IAAI,qCAAiB,EAAE,CAAC;QAChE,CAAA,KAAA,aAAa,CAAC,QAAQ,CAAA,CAAC,IAAI,WAAK,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,EAAd,CAAc,CAAE,EAAG;QAEtE,IAAM,aAAa,GAAG,SAAS,CAAC,WAAW,CAAC,aAAa,CAAC,MAAM,CAAE,aAAa,CAAE,CAAC;QAClF,IAAM,UAAU,GAAqB,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,aAAa,eAAA,EAAE,CAAE,CAAC;QAE9F,IAAM,YAAY,GAAG,IAAI,qBAAS,CAAE;YACnC,WAAW,EAAE,SAAS,CAAC,WAAW;YAClC,WAAW,EAAE,UAAU;SACvB,CAAE,CAAC;QACJ,OAAO,oBAAY,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IACpD,CAAC,CAAA;AACF,CAAC;AAMY,QAAA,YAAY,GAcrB;IACH,UAAU,EAAV,UAAsE,SAAW,EAAE,MAAQ;QAC1F,OAAO,mCAAgB,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YACrE,GAAG,EAAE,QAAQ,CAAE,SAAS,CAAE;SAC1B,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"UnionPattern.js","sourcesContent":["import { Container } from \"../../data/Container\";\nimport { cloneElement } from \"../../data/utils\";\n\nimport { GroupPatternToken } from \"../../tokens/GroupPatternToken\";\nimport { UnionPatternToken } from \"../../tokens/UnionPatternToken\";\n\nimport { Pattern } from \"../Pattern\";\nimport { NotTriplePattern } from \"./NotTriplePattern\";\n\n\n/**\n * Wrapper for easier usage of SPARQL UNION patterns.\n */\nexport interface UnionPattern extends NotTriplePattern<UnionPatternToken> {\n\tand( patterns:Pattern | Pattern[] ):UnionPattern;\n}\n\n/**\n * Function that creates a generic {@link UnionPattern.and} function.\n *\n * @param container The container with the query data for the statement.\n *\n * @private\n */\nfunction getAndFn( container:Container<UnionPatternToken> ):UnionPattern[ \"and\" ] {\n\treturn patterns => {\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\tconst newGroupToken:GroupPatternToken = new GroupPatternToken();\n\t\tnewGroupToken.patterns.push( ...patterns.map( x => x.getPattern() ) );\n\n\t\tconst groupPatterns = container.targetToken.groupPatterns.concat( newGroupToken );\n\t\tconst unionToken:UnionPatternToken = cloneElement( container.targetToken, { groupPatterns } );\n\n\t\tconst newContainer = new Container( {\n\t\t\tiriResolver: container.iriResolver,\n\t\t\ttargetToken: unionToken,\n\t\t} );\n\t\treturn UnionPattern.createFrom( newContainer, {} );\n\t}\n}\n\n\n/**\n * Constant with utils for {@link UnionPattern} objects.\n */\nexport const UnionPattern:{\n\t/**\n\t * Factory function that allows to crete a {@link UnionPattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link UnionPattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link UnionPattern} statement.\n\t *\n\t * @return The {@link UnionPattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<UnionPatternToken>, O extends object>( container:C, object:O ):UnionPattern;\n} = {\n\tcreateFrom<C extends Container<UnionPatternToken>, O extends object>( container:C, object:O ):UnionPattern {\n\t\treturn NotTriplePattern.createFrom( container, Object.assign( object, {\n\t\t\tand: getAndFn( container ),\n\t\t} ) );\n\t},\n};"]}