{"version":3,"sources":["patterns/triplePatterns/RDFLiteral.ts"],"names":[],"mappings":";;AACA,0CAAgD;AAEhD,4DAA2D;AAI3D,qCAAuC;AAGvC,uDAAsD;AAatD,SAAS,aAAa,CAAmD,SAAW;IACnF,OAAO,UAAA,IAAI;QACV,IAAI,IAAI,IAAI,GAAG;YAAG,IAAI,GAAI,GAAW,CAAE,IAAI,CAAE,CAAC;QAE9C,IAAM,OAAO,GAAG,SAAS,CAAC,WAAW,CAAC,OAAO,CAAE,IAAI,EAAE,IAAI,CAAE,CAAC;QAC5D,IAAM,OAAO,GAAG,oBAAY,CAAE,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,CAAE,CAAC;QAEjF,IAAM,WAAW,GAAG,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,OAAO,SAAA,EAAE,CAAE,CAAC;QACvE,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;QAE9E,OAAO,mCAAgB,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IACxD,CAAC,CAAA;AACF,CAAC;AAED,SAAS,iBAAiB,CAAmD,SAAW;IACvF,OAAO,UAAA,QAAQ;QACd,IAAM,SAAS,GAAG,IAAI,6BAAa,CAAE,QAAQ,CAAE,CAAC;QAChD,IAAM,OAAO,GAAG,oBAAY,CAAE,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAE,CAAC;QAEvF,IAAM,WAAW,GAAG,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,OAAO,SAAA,EAAE,CAAE,CAAC;QACvE,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;QAE9E,OAAO,mCAAgB,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IACxD,CAAC,CAAA;AACF,CAAC;AAKY,QAAA,UAAU,GAAG;IACzB,UAAU,EAAV,UAA+E,SAAW,EAAE,MAAQ;QACnG,OAAO,mCAAgB,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YACrE,QAAQ,EAAE,aAAa,CAAE,SAAS,CAAE;YACpC,YAAY,EAAE,iBAAiB,CAAE,SAAS,CAAE;SAC5C,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"RDFLiteral.js","sourcesContent":["import { Container } from \"../../data/Container\";\nimport { cloneElement } from \"../../data/utils\";\n\nimport { LanguageToken } from \"../../tokens/LanguageToken\";\nimport { LiteralToken } from \"../../tokens/LiteralToken\";\nimport { SubjectToken } from \"../../tokens/SubjectToken\";\n\nimport * as XSD from \"../../utils/XSD\";\n\nimport { Literal } from \"./Literal\";\nimport { TriplePatternHas } from \"./TriplePatternHas\";\n\n\n/**\n * @todo\n */\nexport interface RDFLiteral extends Literal {\n\twithType( type:string ):Literal;\n\n\twithLanguage( language:string ):Literal;\n}\n\n\nfunction getWithTypeFn<C extends Container<SubjectToken<LiteralToken>>>( container:C ):RDFLiteral[ \"withType\" ] {\n\treturn type => {\n\t\tif( type in XSD ) type = (XSD as any)[ type ];\n\n\t\tconst iriType = container.iriResolver.resolve( type, true );\n\t\tconst subject = cloneElement( container.targetToken.subject, { type: iriType } );\n\n\t\tconst targetToken = cloneElement( container.targetToken, { subject } );\n\t\tconst newContainer = cloneElement( container, { targetToken } as Partial<C> );\n\n\t\treturn TriplePatternHas.createFrom( newContainer, {} );\n\t}\n}\n\nfunction getWithLanguageFn<C extends Container<SubjectToken<LiteralToken>>>( container:C ):RDFLiteral[ \"withLanguage\" ] {\n\treturn language => {\n\t\tconst langToken = new LanguageToken( language );\n\t\tconst subject = cloneElement( container.targetToken.subject, { language: langToken } );\n\n\t\tconst targetToken = cloneElement( container.targetToken, { subject } );\n\t\tconst newContainer = cloneElement( container, { targetToken } as Partial<C> );\n\n\t\treturn TriplePatternHas.createFrom( newContainer, {} );\n\t}\n}\n\n/**\n * @todo\n */\nexport const RDFLiteral = {\n\tcreateFrom<C extends Container<SubjectToken<LiteralToken>>, O extends object>( container:C, object:O ):O & RDFLiteral {\n\t\treturn TriplePatternHas.createFrom( container, Object.assign( object, {\n\t\t\twithType: getWithTypeFn( container ),\n\t\t\twithLanguage: getWithLanguageFn( container ),\n\t\t} ) );\n\t},\n};\n"]}