{"version":3,"sources":["patterns/triplePatterns/TriplePatternHas.ts"],"names":[],"mappings":";;AACA,8CAA6C;AAC7C,0CAAgD;AAGhD,4DAA2D;AAI3D,sCAAqC;AAErC,kCAAsD;AAKtD,iDAAgD;AA2BhD,SAAS,QAAQ,CAA+D,SAAW;IAC1F,OAAO,UAAE,QAAqC,EAAE,OAA2B;QAC1E,IAAM,SAAS,GAA4B,CAAC,OAAO,QAAQ,KAAK,QAAQ,CAAC;YACxE,CAAC,CAAC,oBAAY,CAAE,SAAS,EAAE,QAAQ,CAAE;YACrC,CAAC,CAAC,QAAQ,CAAC,UAAU,EAAE,CAAC;QAEzB,IAAM,aAAa,GAAiB,IAAI,6BAAa,CAAE,SAAS,CAAE,CAAC;QAEnE,OAAO,GAAG,KAAK,CAAC,OAAO,CAAE,OAAO,CAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAE,OAAO,CAAE,CAAC;QAC3D,aAAa,CAAC,SAAS,OAAvB,aAAa,EAAe,OAAO,CAAC,GAAG,CAAE,oBAAY,CAAE,EAAG;QAE1D,IAAM,UAAU,GAAG,SAAS,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAE,aAAa,CAAE,CAAC;QAC5E,IAAM,WAAW,GAAG,oBAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,UAAU,YAAA,EAAE,CAAE,CAAC;QAE1E,IAAM,YAAY,GAAG,oBAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;QAC9E,OAAO,wBAAgB,CAAC,UAAU,CAAY,YAAY,EAAE,EAAE,CAAE,CAAC;IAClE,CAAC,CAAC;AACH,CAAC;AAMY,QAAA,gBAAgB,GAAG;IAC/B,UAAU,EAAV,UAA2F,SAAW,EAAE,MAAQ;QAC/G,OAAO,6BAAa,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAClE,GAAG,EAAE,QAAQ,CAAQ,SAAS,CAAE;SAChC,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC;AAKW,QAAA,gBAAgB,GAAG;IAC/B,UAAU,EAAV,UAA2F,SAAW,EAAE,MAAQ;QAC/G,OAAO,iBAAO,CAAC,UAAU,CACxB,iBAAO,CAAC,UAAU,EAClB,6BAAa,CAAC,UAAU,CACxB,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YACpC,GAAG,EAAE,QAAQ,CAAQ,SAAS,CAAE;SAChC,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"TriplePatternHas.js","sourcesContent":["import { Container2 } from \"../../data/Container2\";\nimport { Factory } from \"../../data/Factory\";\nimport { cloneElement } from \"../../data/utils\";\n\nimport { ObjectToken } from \"../../tokens/ObjectToken\";\nimport { PropertyToken } from \"../../tokens/PropertyToken\";\nimport { TripleToken } from \"../../tokens/TripleToken\";\nimport { VariableOrIRIToken } from \"../../tokens/VariableOrIRIToken\";\n\nimport { Pattern } from \"../Pattern\";\nimport { SupportedNativeTypes } from \"../SupportedNativeTypes\";\nimport { _resolvePath, convertValue } from \"../utils\";\nimport { BlankNodeProperty } from \"./BlankNodeProperty\";\nimport { Collection } from \"./Collection\";\nimport { Literal } from \"./Literal\";\nimport { Resource } from \"./Resource\";\nimport { TriplePattern } from \"./TriplePattern\";\nimport { Variable } from \"./Variable\";\n\n\n/**\n * @todo\n */\nexport interface TriplePatternHas<T extends ObjectToken> extends TriplePattern<T> {\n\thas( property:Variable | Resource | \"a\" | string, object:SupportedNativeTypes | Resource | Variable | Literal | Collection | BlankNodeProperty ):TriplePatternAnd<T>;\n\thas( property:Variable | Resource | \"a\" | string, objects:(SupportedNativeTypes | Resource | Variable | Literal | Collection | BlankNodeProperty)[] ):TriplePatternAnd<T>;\n}\n\n/**\n * @todo\n */\nexport interface TriplePatternAnd<T extends ObjectToken> extends TriplePattern<T>, Pattern<TripleToken<T>> {\n\t// TODO: Add Collection\n\tand( property:Variable | Resource | \"a\" | string, object:SupportedNativeTypes | Resource | Variable | Literal | Collection | BlankNodeProperty ):TriplePatternAnd<T>;\n\tand( property:Variable | Resource | \"a\" | string, objects:(SupportedNativeTypes | Resource | Variable | Literal | Collection | BlankNodeProperty)[] ):TriplePatternAnd<T>;\n}\n\n\ntype Objects = SupportedNativeTypes | Resource | Variable | Literal | Collection | BlankNodeProperty;\n\n/**\n * @todo\n */\nfunction getHasFn<T extends ObjectToken, C extends Container2<TripleToken<T>>>( container:C ):TriplePatternHas<T>[ \"has\" ] {\n\treturn ( property:string | Variable | Resource, objects:Objects | Objects[] ) => {\n\t\tconst verbToken:VariableOrIRIToken | \"a\" = (typeof property === \"string\")\n\t\t\t? _resolvePath( container, property )\n\t\t\t: property.getSubject();\n\n\t\tconst propertyToken:PropertyToken = new PropertyToken( verbToken );\n\n\t\tobjects = Array.isArray( objects ) ? objects : [ objects ];\n\t\tpropertyToken.addObject( ...objects.map( convertValue ) );\n\n\t\tconst properties = container.targetToken.properties.concat( propertyToken );\n\t\tconst targetToken = cloneElement( container.targetToken, { properties } );\n\n\t\tconst newContainer = cloneElement( container, { targetToken } as Partial<C> );\n\t\treturn TriplePatternAnd.createFrom<T, C, {}>( newContainer, {} );\n\t};\n}\n\n\n/**\n * @todo\n */\nexport const TriplePatternHas = {\n\tcreateFrom<T extends ObjectToken, C extends Container2<TripleToken<T>>, O extends object>( container:C, object:O ):O & TriplePatternHas<T> {\n\t\treturn TriplePattern.createFrom( container, Object.assign( object, {\n\t\t\thas: getHasFn<T, C>( container ),\n\t\t} ) );\n\t}\n};\n\n/**\n * @todo\n */\nexport const TriplePatternAnd = {\n\tcreateFrom<T extends ObjectToken, C extends Container2<TripleToken<T>>, O extends object>( container:C, object:O ):O & TriplePatternAnd<T> {\n\t\treturn Factory.createFrom<C, Pattern<TripleToken<T>>, TriplePattern<T>>(\n\t\t\tPattern.createFrom,\n\t\t\tTriplePattern.createFrom,\n\t\t)( container, Object.assign( object, {\n\t\t\tand: getHasFn<T, C>( container ),\n\t\t} ) );\n\t}\n};"]}