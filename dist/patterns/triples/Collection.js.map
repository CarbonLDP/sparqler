{"version":3,"sources":["patterns/triples/Collection.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAKA,sCAMqB;AAMrB,yCAGwB;AACxB,6DAAwD;AACxD,mDAAkD;AAElD;IAAgC,8BAAkC;IAIjE,oBAAa,QAAoB,EAAE,MAAoF;QAAvH,YACC,kBAAO,QAAQ,CAAE,SAcjB;QAZA,IAAI,MAAM,GAAW,EAAE,CAAC;QACxB,MAAM,CAAC,OAAO,CAAE,UAAE,KAAK,EAAE,KAAK;YAC7B,MAAM,CAAC,IAAI,OAAX,MAAM,EAAU,yBAAS,CAAE,KAA6B,CAAE,EAAG;YAC7D,IAAI,KAAK,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC;gBAAG,MAAM,CAAC,IAAI,CAAE,wBAAe,CAAE,CAAC;QAChE,CAAC,CAAE,CAAC;QAEJ,IAAI,QAAQ,GAAW,MAAM,CAAC,MAAM,IAAI,CAAC,IAAI,CAAE,MAAM,CAAC,IAAI,CAAE,UAAA,KAAK,IAAI,OAAA,KAAK,YAAY,sBAAa,EAA9B,CAA8B,CAAE,CAAC;QACtG,KAAI,CAAC,aAAa;YACjB,QAAQ,CAAC,CAAC,CAAC,yBAAgB,CAAC,CAAC,CAAC,wBAAe;iBAC1C,MAAM;YACT,QAAQ,CAAC,CAAC,CAAC,0BAAiB,CAAC,CAAC,CAAC,yBAAgB;UAC/C,CAAC;;IACH,CAAC;IAED,+BAAU,GAAV;QACC,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,MAAM,CAAE,IAAI,CAAC,aAAa,CAAE,CAAC;IAC1D,CAAC;IAES,yBAAI,GAAd;QAAA,iBAMC;QALA,iBAAM,IAAI,WAAE,CAAC;QACb,IAAI,CAAC,UAAU,CAAC,YAAY,GAAG;YAC9B,UAAU,EAAE,cAAM,OAAA,KAAI,CAAC,UAAU,EAAE,EAAjB,CAAiB;YACnC,aAAa,EAAE,cAAM,OAAA,KAAI,CAAC,aAAa,EAAE,EAApB,CAAoB;SACzC,CAAC;IACH,CAAC;IAEF,iBAAC;AAAD,CAjCA,AAiCC,CAjC+B,+BAAc,GAiC7C;AAjCY,gCAAU;AAmCvB,kBAAe,UAAU,CAAC","file":"Collection.js","sourcesContent":["import { IRIResolver } from \"./../../iri/IRIResolver\";\nimport {\n\tSupportedNativeTypes,\n\tTriplesNodePattern,\n} from \"./..\";\nimport {\n\tCLOSE_MULTI_LIST,\n\tCLOSE_SINGLE_LIST,\n\tEMPTY_SEPARATOR,\n\tOPEN_MULTI_LIST,\n\tOPEN_SINGLE_LIST,\n} from \"./../tokens\";\nimport {\n\tLiteral,\n\tResource,\n\tVariable,\n} from \"./\";\nimport {\n\tNewLineSymbol,\n\tToken,\n} from \"./../../tokens\";\nimport { serialize } from \"./../../utils/ObjectPattern\";\nimport { TriplesPattern } from \"./TriplesPattern\";\n\nexport class Collection extends TriplesPattern<TriplesNodePattern> implements TriplesNodePattern {\n\n\tprotected elementTokens:Token[];\n\n\tconstructor( resolver:IRIResolver, values:(SupportedNativeTypes | Resource | Variable | Literal | TriplesNodePattern)[] ) {\n\t\tsuper( resolver );\n\n\t\tlet tokens:Token[] = [];\n\t\tvalues.forEach( ( value, index ) => {\n\t\t\ttokens.push( ...serialize( value as SupportedNativeTypes ) );\n\t\t\tif( index < values.length - 1 ) tokens.push( EMPTY_SEPARATOR );\n\t\t} );\n\n\t\tlet isSingle:boolean = values.length <= 1 && ! tokens.find( token => token instanceof NewLineSymbol );\n\t\tthis.elementTokens = [\n\t\t\tisSingle ? OPEN_SINGLE_LIST : OPEN_MULTI_LIST,\n\t\t\t...tokens,\n\t\t\tisSingle ? CLOSE_SINGLE_LIST : CLOSE_MULTI_LIST,\n\t\t];\n\t}\n\n\tgetPattern():Token[] {\n\t\treturn this.getSelfTokens().concat( this.patternTokens );\n\t}\n\n\tprotected init():void {\n\t\tsuper.init();\n\t\tthis.interfaces.graphPattern = {\n\t\t\tgetPattern: () => this.getPattern(),\n\t\t\tgetSelfTokens: () => this.getSelfTokens(),\n\t\t};\n\t}\n\n}\n\nexport default Collection;\n"]}