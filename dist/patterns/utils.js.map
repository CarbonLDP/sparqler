{"version":3,"sources":["patterns/utils.ts"],"names":[],"mappings":";;AAEA,uDAAsD;AAMtD,kCAAoC;AASpC,SAAgB,YAAY,CAAE,KAAqE;IAClG,IAAI,KAAK,YAAY,IAAI;QACxB,OAAO,IAAI,2BAAY,CAAE,KAAK,CAAC,WAAW,EAAE,CAAE;aAC5C,OAAO,CAAE,GAAG,CAAC,QAAQ,CAAE,CAAC;IAE3B,IAAI,OAAO,KAAK,KAAK,QAAQ;QAC5B,OAAO,KAAK,CAAC,UAAU,EAAE,CAAC;IAE3B,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAG;QAC/B,IAAI,KAAK,KAAK,OAAO;YAAG,OAAO,KAAK,CAAC;QACrC,OAAO,IAAI,2BAAY,CAAE,KAAK,CAAE,CAAC;KACjC;IAED,OAAO,IAAI,2BAAY,CAAE,KAAK,CAAE,CAAC;AAClC,CAAC;AAdD,oCAcC;AAGD,IAAM,cAAc,GAAY,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAE,CAAC;AAGhF,SAAgB,YAAY,CAAE,SAA8B,EAAE,YAAmB;IAChF,IAAM,UAAU,GAAU,YAAY;SACpC,KAAK,CAAE,SAAS,CAAE;SAClB,MAAM,CAAE,UAAE,KAAc,EAAE,IAAW;QAErC,IAAI,IAAI,CAAC,UAAU,CAAE,GAAG,CAAE,EAAG;YAC5B,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,CAAC;SACnB;aAGI;YACJ,KAAK,CAAC,IAAI,OAAV,KAAK,EAAU,IAAI,CAAC,KAAK,CAAE,eAAe,CAAE,EAAE;SAC9C;QAED,OAAO,KAAK,CAAC;IACd,CAAC,EAAE,EAAE,CAAE;SACN,GAAG,CAAE,UAAE,IAAW;QAClB,IAAI,CAAE,IAAI;YAAG,OAAO;QAGpB,IAAI,cAAc,CAAC,OAAO,CAAE,IAAI,CAAE,KAAK,CAAE,CAAC,EAAG;YAC5C,OAAO,IAAI,CAAC;SACZ;aAGI,IAAI,IAAI,KAAK,GAAG,EAAG;YACvB,OAAO,IAAI,CAAC;SACZ;aAGI;YAEJ,IAAI,IAAI,CAAC,UAAU,CAAE,GAAG,CAAE,IAAI,IAAI,CAAC,QAAQ,CAAE,GAAG,CAAE;gBAAG,IAAI,GAAG,IAAI,CAAC,KAAK,CAAE,CAAC,EAAE,CAAE,CAAC,CAAE,CAAC;YAGjF,OAAO,SAAS,CAAC,WAAW,CAAC,OAAO,CAAE,IAAI,EAAE,IAAI,CAAE,CAAC;SACnD;IACF,CAAC,CAAE;SACF,IAAI,CAAE,EAAE,CAAE,CAAC;IAEb,OAAO,UAAiB,CAAC;AAC1B,CAAC;AAzCD,oCAyCC","file":"utils.js","sourcesContent":["import { Container } from \"../data/Container\";\n\nimport { LiteralToken } from \"../tokens/LiteralToken\";\nimport { ObjectToken } from \"../tokens/ObjectToken\";\nimport { TermToken } from \"../tokens/TermToken\";\nimport { TokenNode } from \"../tokens/TokenNode\";\nimport { VariableToken } from \"../tokens/VariableToken\";\n\nimport * as XSD from \"../utils/XSD\";\n\nimport { SupportedNativeTypes } from \"./SupportedNativeTypes\";\nimport { TriplePattern } from \"./triplePatterns/TriplePattern\";\n\n\nexport function convertValue( value:\"UNDEF\" ):\"UNDEF\";\nexport function convertValue<T extends TriplePattern<X>, X extends ObjectToken>( value:T ):X;\nexport function convertValue<T extends SupportedNativeTypes>( value:T ):LiteralToken;\nexport function convertValue( value:SupportedNativeTypes | TriplePattern<VariableToken | TermToken> ):ObjectToken | \"UNDEF\" {\n\tif( value instanceof Date )\n\t\treturn new LiteralToken( value.toISOString() )\n\t\t\t.setType( XSD.dateTime );\n\n\tif( typeof value === \"object\" )\n\t\treturn value.getSubject();\n\n\tif( typeof value === \"string\" ) {\n\t\tif( value === \"UNDEF\" ) return value;\n\t\treturn new LiteralToken( value );\n\t}\n\n\treturn new LiteralToken( value );\n}\n\n\nconst PATH_OPERATORS:string[] = [ \"|\", \"/\", \"^\", \"?\", \"*\", \"+\", \"!\", \"(\", \")\" ];\n\n// TODO: Remove `a` and Implement Path tokens\nexport function _resolvePath( container:Container<TokenNode>, propertyPath:string ):\"a\" {\n\tconst parsedPath:string = propertyPath\n\t\t.split( /(<.*?>)/ )\n\t\t.reduce( ( array:string[], part:string ) => {\n\t\t\t// Is an IRI\n\t\t\tif( part.startsWith( \"<\" ) ) {\n\t\t\t\tarray.push( part );\n\t\t\t}\n\n\t\t\t// Everything else\n\t\t\telse {\n\t\t\t\tarray.push( ...part.split( /([|/^?*+!()])/ ) )\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}, [] )\n\t\t.map( ( part:string ) => {\n\t\t\tif( ! part ) return;\n\n\t\t\t// Operators\n\t\t\tif( PATH_OPERATORS.indexOf( part ) !== - 1 ) {\n\t\t\t\treturn part;\n\t\t\t}\n\n\t\t\t// \"a\" keyword\n\t\t\telse if( part === \"a\" ) {\n\t\t\t\treturn part;\n\t\t\t}\n\n\t\t\t// IRI or prefix\n\t\t\telse {\n\t\t\t\t// Remove IRI tags\n\t\t\t\tif( part.startsWith( \"<\" ) && part.endsWith( \">\" ) ) part = part.slice( 1, - 1 );\n\n\t\t\t\t// Register prefix it prefixed\n\t\t\t\treturn container.iriResolver.resolve( part, true );\n\t\t\t}\n\t\t} )\n\t\t.join( \"\" );\n\n\treturn parsedPath as \"a\";\n}"]}