{"version":3,"sources":["tokens/LiteralToken.ts"],"names":[],"mappings":";;AAAA,sCAA0C;AAE1C,+CAA8C;AAC9C,uCAAsC;AACtC,iDAAgD;AAChD,6CAA4C;AAC5C,yDAAwD;AACxD,6CAA4C;AAI5C;IAOC,sBAAa,KAAgC;QANpC,UAAK,GAAa,SAAS,CAAC;QAOpC,IAAI,KAAK,KAAK,KAAK,CAAC;YAAG,OAAO;QAC9B,IAAI,CAAC,QAAQ,CAAE,KAAK,CAAE,CAAC;IACxB,CAAC;IAGD,+BAAQ,GAAR,UAAU,KAA+B;QACxC,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,KAAK;YAC3C,OAAO,IAAI,CAAC;QAEb,IAAI,CAAC,KAAK,GAAG,OAAQ,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,2BAAY,CAAE,KAAK,CAAE,CAAC,CAAC;YACrE,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,yBAAW,CAAE,KAAK,CAAE,CAAC,CAAC;gBACrD,IAAI,yBAAW,CAAE,KAAK,CAAE,CAAC;QAE3B,OAAO,IAAI,CAAC;IACb,CAAC;IAED,8BAAO,GAAP,UAAS,IAA0C;QAClD,IAAI,CAAE,IAAI,CAAC,KAAK;YAAG,MAAM,IAAI,KAAK,CAAE,iCAAiC,CAAE,CAAC;QACxE,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,QAAQ;YAAG,IAAI,CAAC,KAAK,GAAG,IAAI,yBAAW,CAAE,KAAI,IAAI,CAAC,KAAQ,CAAE,CAAC;QAEtF,IAAI,CAAC,IAAI,GAAG,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,kBAAU,CAAE,IAAI,CAAE,CAAC,CAAC;YAC1D,IAAI,qCAAiB,CAAE,IAAI,CAAE,CAAC,CAAC,CAAC,IAAI,mBAAQ,CAAE,IAAI,CAAE,CAAC,CAAC,CAAC,IAAI,CAAC;QAE7D,OAAO,IAAI,CAAC;IACb,CAAC;IAED,kCAAW,GAAX,UAAa,QAAe;QAC3B,IAAI,CAAE,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,QAAQ;YAAG,MAAM,IAAI,KAAK,CAAE,yCAAyC,CAAE,CAAC;QACjH,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,6BAAa,CAAE,QAAQ,CAAE,CAAC;QAE9C,OAAO,IAAI,CAAC;IACb,CAAC;IAGD,+BAAQ,GAAR,UAAU,MAAc;QACvB,IAAI,IAAI,CAAC,QAAQ;YAAG,OAAO,KAAI,IAAI,CAAC,KAAK,GAAK,IAAI,CAAC,QAAW,CAAC;QAC/D,IAAI,IAAI,CAAC,IAAI;YAAG,OAAW,IAAI,CAAC,KAAK,UAAO,IAAI,CAAC,IAAO,CAAC;QACzD,OAAO,KAAI,IAAI,CAAC,KAAQ,CAAC;IAC1B,CAAC;IACF,mBAAC;AAAD,CAhDA,AAgDC,IAAA;AAhDY,oCAAY","file":"LiteralToken.js","sourcesContent":["import { isPrefixed } from \"../iri/utils\";\n\nimport { BooleanToken } from \"./BooleanToken\";\nimport { IRIToken } from \"./IRIToken\";\nimport { LanguageToken } from \"./LanguageToken\";\nimport { NumberToken } from \"./NumberToken\";\nimport { PrefixedNameToken } from \"./PrefixedNameToken\";\nimport { StringToken } from \"./StringToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\nexport class LiteralToken implements TokenNode {\n\treadonly token:\"literal\" = \"literal\";\n\n\tvalue?:NumberToken | BooleanToken | StringToken;\n\ttype?:IRIToken | PrefixedNameToken;\n\tlanguage?:LanguageToken;\n\n\tconstructor( value?:boolean | number | string ) {\n\t\tif( value === void 0 ) return;\n\t\tthis.setValue( value );\n\t}\n\n\n\tsetValue( value:boolean | number | string ):this {\n\t\tif( this.value && this.value.value === value )\n\t\t\treturn this;\n\n\t\tthis.value = typeof  value === \"boolean\" ? new BooleanToken( value ) :\n\t\t\ttypeof value === \"number\" ? new NumberToken( value ) :\n\t\t\t\tnew StringToken( value );\n\n\t\treturn this;\n\t}\n\n\tsetType( type:string | IRIToken | PrefixedNameToken ):this {\n\t\tif( ! this.value ) throw new Error( \"Must set a value before a type.\" );\n\t\tif( this.value.token !== \"string\" ) this.value = new StringToken( `${ this.value }` );\n\n\t\tthis.type = typeof type === \"string\" ? isPrefixed( type ) ?\n\t\t\tnew PrefixedNameToken( type ) : new IRIToken( type ) : type;\n\n\t\treturn this;\n\t}\n\n\tsetLanguage( language:string ):this {\n\t\tif( ! this.value || this.value.token !== \"string\" ) throw new Error( \"Non-string value can't have a language.\" );\n\t\tthis.type = void 0;\n\t\tthis.language = new LanguageToken( language );\n\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tif( this.language ) return `${ this.value }${ this.language }`;\n\t\tif( this.type ) return `${ this.value }^^${ this.type }`;\n\t\treturn `${ this.value }`;\n\t}\n}\n"]}