{"version":3,"sources":["tokens/LiteralToken.ts"],"names":[],"mappings":";;AAAA,gCAAsC;AAEtC,+CAA8C;AAC9C,uCAAsC;AACtC,iDAAgD;AAChD,6CAA4C;AAC5C,yDAAwD;AACxD,6CAA4C;AAG5C;IAMC,sBAAa,KAAgC;QALpC,UAAK,GAAa,SAAS,CAAC;QAMpC,EAAE,CAAA,CAAE,KAAK,KAAK,KAAK,CAAE,CAAC;YAAC,MAAM,CAAC;QAC9B,IAAI,CAAC,QAAQ,CAAE,KAAK,CAAE,CAAC;IACxB,CAAC;IAED,+BAAQ,GAAR,UAAU,KAA+B;QACxC,EAAE,CAAA,CAAE,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,KAAM,CAAC;YAAC,MAAM,CAAC;QAEtD,IAAI,CAAC,KAAK,GAAG,OAAQ,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,2BAAY,CAAE,KAAK,CAAE,CAAC,CAAC;YACrE,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,yBAAW,CAAE,KAAK,CAAE,CAAC,CAAC;gBACrD,IAAI,yBAAW,CAAE,KAAK,CAAE,CAAC;IAC5B,CAAC;IAED,8BAAO,GAAP,UAAS,IAA0C;QAClD,EAAE,CAAA,CAAE,CAAE,IAAI,CAAC,KAAM,CAAC;YAAC,MAAM,IAAI,KAAK,CAAE,iCAAiC,CAAE,CAAC;QACxE,EAAE,CAAA,CAAE,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,QAAS,CAAC;YAAC,IAAI,CAAC,KAAK,GAAG,IAAI,yBAAW,CAAE,KAAI,IAAI,CAAC,KAAQ,CAAE,CAAC;QAEtF,IAAI,CAAC,IAAI,GAAG,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,gBAAU,CAAE,IAAI,CAAE,CAAC,CAAC;YAC1D,IAAI,qCAAiB,CAAE,IAAI,CAAE,CAAC,CAAC,CAAC,IAAI,mBAAQ,CAAE,IAAI,CAAE,CAAC,CAAC,CAAC,IAAI,CAAC;IAC9D,CAAC;IAED,kCAAW,GAAX,UAAa,QAAe;QAC3B,EAAE,CAAA,CAAE,CAAE,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,QAAS,CAAC;YAAC,MAAM,IAAI,KAAK,CAAE,yCAAyC,CAAE,CAAC;QACjH,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,6BAAa,CAAE,QAAQ,CAAE,CAAC;IAC/C,CAAC;IAED,+BAAQ,GAAR;QACC,EAAE,CAAA,CAAE,IAAI,CAAC,QAAS,CAAC;YAAC,MAAM,CAAC,KAAI,IAAI,CAAC,KAAK,GAAK,IAAI,CAAC,QAAW,CAAC;QAC/D,EAAE,CAAA,CAAE,IAAI,CAAC,IAAK,CAAC;YAAC,MAAM,CAAK,IAAI,CAAC,KAAK,UAAO,IAAI,CAAC,IAAO,CAAC;QACzD,MAAM,CAAC,KAAI,IAAI,CAAC,KAAQ,CAAC;IAC1B,CAAC;IACF,mBAAC;AAAD,CAtCA,AAsCC,IAAA;AAtCY,oCAAY","file":"LiteralToken.js","sourcesContent":["import { isPrefixed } from \"./../iri\";\n\nimport { BooleanToken } from \"./BooleanToken\";\nimport { IRIToken } from \"./IRIToken\";\nimport { LanguageToken } from \"./LanguageToken\";\nimport { NumberToken } from \"./NumberToken\";\nimport { PrefixedNameToken } from \"./PrefixedNameToken\";\nimport { StringToken } from \"./StringToken\";\nimport { TokenNode } from \"./TokenNode\";\n\nexport class LiteralToken implements TokenNode {\n\treadonly token:\"literal\" = \"literal\";\n\tvalue?:NumberToken | BooleanToken | StringToken;\n\ttype?:IRIToken | PrefixedNameToken;\n\tlanguage?:LanguageToken;\n\n\tconstructor( value?:boolean | number | string ) {\n\t\tif( value === void 0 ) return;\n\t\tthis.setValue( value );\n\t}\n\n\tsetValue( value:boolean | number | string ):void {\n\t\tif( this.value && this.value.value === value ) return;\n\n\t\tthis.value = typeof  value === \"boolean\" ? new BooleanToken( value ) :\n\t\t\ttypeof value === \"number\" ? new NumberToken( value ) :\n\t\t\t\tnew StringToken( value );\n\t}\n\n\tsetType( type:string | IRIToken | PrefixedNameToken ):void {\n\t\tif( ! this.value ) throw new Error( \"Must set a value before a type.\" );\n\t\tif( this.value.token !== \"string\" ) this.value = new StringToken( `${ this.value }` );\n\n\t\tthis.type = typeof type === \"string\" ? isPrefixed( type ) ?\n\t\t\tnew PrefixedNameToken( type ) : new IRIToken( type ) : type;\n\t}\n\n\tsetLanguage( language:string ):void {\n\t\tif( ! this.value || this.value.token !== \"string\" ) throw new Error( \"Non-string value can't have a language.\" );\n\t\tthis.type = void 0;\n\t\tthis.language = new LanguageToken( language );\n\t}\n\n\ttoString():string {\n\t\tif( this.language ) return `${ this.value }${ this.language }`;\n\t\tif( this.type ) return `${ this.value }^^${ this.type }`;\n\t\treturn `${ this.value }`;\n\t}\n}\n"]}