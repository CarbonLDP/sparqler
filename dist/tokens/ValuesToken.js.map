{"version":3,"sources":["tokens/ValuesToken.ts"],"names":[],"mappings":";;AAEA,uCAA8E;AAY9E;IAMC;QALS,UAAK,GAAY,QAAQ,CAAC;QAMlC,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;IAClB,CAAC;IAED,kCAAY,GAAZ;QAAc,mBAA4B;aAA5B,UAA4B,EAA5B,qBAA4B,EAA5B,IAA4B;YAA5B,8BAA4B;;;QACzC,CAAA,KAAA,IAAI,CAAC,SAAS,CAAA,CAAC,IAAI,WAAK,SAAS,EAAG;QACpC,OAAO,IAAI,CAAC;IACb,CAAC;IAED,+BAAS,GAAT;QAAW,gBAA+C;aAA/C,UAA+C,EAA/C,qBAA+C,EAA/C,IAA+C;YAA/C,2BAA+C;;QACzD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,MAAM,CAAE,CAAC;QAC3B,OAAO,IAAI,CAAC;IACb,CAAC;IAGD,8BAAQ,GAAR,UAAU,MAAc;QACvB,IAAM,SAAS,GAAU,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAEjD,IAAM,MAAM,GAAU,IAAI,CAAC,aAAa,CAAE,MAAM,CAAE,CAAC;QACnD,OAAO,YAAW,SAAS,SAAM,MAAS,CAAC;IAC5C,CAAC;IAEO,sCAAgB,GAAxB;QACC,IAAI,CAAE,IAAI,CAAC,SAAS,CAAC,MAAM;YAAG,OAAO,IAAI,CAAC;QAE1C,IAAM,SAAS,GAAU,IAAI,CAAC,SAAS,CAAC,IAAI,CAAE,GAAG,CAAE,CAAC;QACpD,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC;YAAG,OAAO,SAAS,CAAC;QAEnD,OAAO,OAAM,SAAS,OAAK,CAAC;IAC7B,CAAC;IAEO,mCAAa,GAArB,UAAuB,MAAc;QACpC,IAAI,CAAE,IAAI,CAAC,MAAM,CAAC,MAAM;YAAG,OAAO,IAAI,CAAC;QAEvC,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,EAAG;YACjC,IAAM,MAAM,GAAU,IAAI,CAAC,MAAM;iBAC/B,MAAM,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,MAAM,EAAR,CAAQ,CAAE;iBACvB,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAE,CAAC,CAAE,EAAN,CAAM,CAAE;iBAClB,IAAI,CAAE,GAAG,CAAE,CAAC;YAEd,IAAI,CAAE,MAAM;gBAAG,OAAO,IAAI,CAAC;YAC3B,OAAO,IAAI,GAAG,MAAM,GAAG,IAAI,CAAC;SAC5B;QAED,IAAM,SAAS,GAAU,yBAAc,CAAE,MAAM,EAAE,6BAAkB,CAAE,CAAC;QACtE,IAAM,SAAS,GAAU,uBAAY,CAAE,MAAM,CAAE,CAAC;QAChD,IAAM,MAAM,GAAU,yBAAc,CAAE,MAAM,CAAE,CAAC;QAC/C,OAAO,GAAG,GAAG,SAAS;YACrB,IAAI,CAAC,MAAM;iBACT,GAAG,CAAE,UAAA,MAAM;gBACX,IAAM,SAAS,GAAU,MAAM,CAAC,MAAM,CAAC,CAAC;oBACvC,OAAM,MAAM,CAAC,IAAI,CAAE,GAAG,CAAE,OAAK,CAAC,CAAC,CAAC,IAAI,CAAC;gBACtC,OAAO,SAAS,GAAG,SAAS,CAAC;YAC9B,CAAC,CAAE;iBACF,IAAI,CAAE,SAAS,CAAE,GAAG,SAAS;YAC/B,MAAM,GAAG,GAAG,CAAC;IACf,CAAC;IACF,kBAAC;AAAD,CAhEA,AAgEC,IAAA;AAhEY,kCAAW","file":"ValuesToken.js","sourcesContent":["import { IRIToken } from \"./IRIToken\";\nimport { LiteralToken } from \"./LiteralToken\";\nimport { getIndentation, getSeparator, INDENTATION_SPACES } from \"./printing\";\nimport { RDFLiteralToken } from \"./RDFLiteralToken\";\nimport { TokenNode } from \"./TokenNode\";\nimport { VariableToken } from \"./VariableToken\";\n\n\n/**\n * The token of the `VALUES` clause or pattern statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rValuesClause}\n * @see {@link https://www.w3.org/TR/sparql11-query/#rInlineData}\n */\nexport class ValuesToken implements TokenNode {\n\treadonly token:\"values\" = \"values\";\n\n\treadonly variables:VariableToken[];\n\treadonly values:(IRIToken | RDFLiteralToken | LiteralToken | \"UNDEF\")[][];\n\n\tconstructor() {\n\t\tthis.variables = [];\n\t\tthis.values = [];\n\t}\n\n\taddVariables( ...variables:VariableToken[] ):this {\n\t\tthis.variables.push( ...variables );\n\t\treturn this;\n\t}\n\n\taddValues( ...values:(IRIToken | LiteralToken | \"UNDEF\")[] ):this {\n\t\tthis.values.push( values );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tconst variables:string = this._getVariablesStr();\n\n\t\tconst values:string = this._getValuesStr( spaces );\n\t\treturn `VALUES ${ variables } ${ values }`;\n\t}\n\n\tprivate _getVariablesStr():string {\n\t\tif( ! this.variables.length ) return \"()\";\n\n\t\tconst variables:string = this.variables.join( \" \" );\n\t\tif( this.variables.length === 1 ) return variables;\n\n\t\treturn `( ${ variables } )`;\n\t}\n\n\tprivate _getValuesStr( spaces?:number ):string {\n\t\tif( ! this.values.length ) return \"{}\";\n\n\t\tif( this.variables.length === 1 ) {\n\t\t\tconst values:string = this.values\n\t\t\t\t.filter( x => x.length )\n\t\t\t\t.map( x => x[ 0 ] )\n\t\t\t\t.join( \" \" );\n\n\t\t\tif( ! values ) return \"{}\";\n\t\t\treturn \"{ \" + values + \" }\";\n\t\t}\n\n\t\tconst subIndent:string = getIndentation( spaces, INDENTATION_SPACES );\n\t\tconst separator:string = getSeparator( spaces );\n\t\tconst indent:string = getIndentation( spaces );\n\t\treturn \"{\" + separator +\n\t\t\tthis.values\n\t\t\t\t.map( values => {\n\t\t\t\t\tconst valuesStr:string = values.length ?\n\t\t\t\t\t\t`( ${ values.join( \" \" ) } )` : \"()\";\n\t\t\t\t\treturn subIndent + valuesStr;\n\t\t\t\t} )\n\t\t\t\t.join( separator ) + separator +\n\t\t\tindent + \"}\";\n\t}\n}\n"]}