{"version":3,"sources":["tokens/printing.ts"],"names":[],"mappings":";;AAOa,QAAA,kBAAkB,GAAK,CAAC,CAAC;AAYtC,SAAgB,YAAY,CAAE,MAAc;IAC3C,IAAI,MAAM,KAAK,KAAK,CAAC;QAAG,OAAO,GAAG,CAAC;IACnC,OAAO,IAAI,CAAC;AACb,CAAC;AAHD,oCAGC;AAeD,SAAgB,cAAc,CAAE,MAAc,EAAE,KAAa;IAC5D,IAAI,MAAM,KAAK,KAAK,CAAC;QAAG,OAAO,EAAE,CAAC;IAElC,IAAI,KAAK;QAAG,MAAM,IAAI,KAAK,CAAC;IAC5B,OAAO,GAAG,CAAC,MAAM,CAAE,MAAM,CAAE,CAAC;AAC7B,CAAC;AALD,wCAKC;AAWD,SAAgB,SAAS,CAAE,MAAyB,EAAE,KAAY;IACjE,IAAI,MAAM,KAAK,KAAK,CAAC;QAAG,OAAO,MAAM,CAAC;IACtC,OAAO,MAAM,GAAG,KAAK,CAAC;AACvB,CAAC;AAHD,8BAGC;AAYD,SAAgB,uBAAuB,CAAE,EAKxC;QAL0C,kBAAM,EAAE,cAAI,EAAE,oCAAe,EAAE,kBAAM;IAM/E,IAAI,CAAE,MAAM,CAAC,MAAM;QAAG,OAAO,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;IAEpD,IAAM,gBAAgB,GAAU,YAAY,CAAE,MAAM,CAAE,CAAC;IAEvD,IAAM,YAAY,GAAsB,SAAS,CAAE,MAAM,EAAE,0BAAkB,CAAE,CAAC;IAChF,IAAM,cAAc,GAAY,MAAM,CAAC,GAAG,CAAE,UAAE,KAAK,EAAE,KAAK,EAAE,KAAK;QAChE,IAAM,QAAQ,GAAU,KAAK,CAAC,QAAQ,CAAE,YAAY,CAAE,CAAC;QAGvD,IAAI,CAAE,eAAe,IAAI,KAAK,KAAK,KAAK,CAAC,MAAM,GAAG,CAAC;YAAG,OAAO,QAAQ,CAAC;QAGtE,IAAI,eAAe,KAAK,GAAG,IAAI,KAAK,CAAC,KAAK,KAAK,SAAS;YAAG,OAAO,QAAQ,CAAC;QAE3E,OAAO,QAAQ,GAAG,eAAe,CAAC;IACnC,CAAC,CAAE,CAAC;IAGJ,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,IAAI,CAAE,cAAc,CAAE,CAAC,CAAE,CAAC,QAAQ,CAAE,IAAI,CAAE;QACxE,OAAO,IAAI,CAAC,IAAI,GAAG,GAAG,GAAG,cAAc,GAAG,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;IAG5D,IAAM,YAAY,GAAU,cAAc,CAAE,YAAY,CAAE,CAAC;IAC3D,IAAM,SAAS,GAAU,cAAc;SACrC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,YAAY,GAAG,CAAC,EAAhB,CAAgB,CAAE;SAC5B,IAAI,CAAE,gBAAgB,CAAE,CAAC;IAE3B,IAAM,MAAM,GAAU,cAAc,CAAE,MAAM,CAAE,CAAC;IAC/C,OAAO,IAAI,CAAC,IAAI;QACf,gBAAgB,GAAG,SAAS,GAAG,gBAAgB;QAC/C,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;AACtB,CAAC;AArCD,0DAqCC","file":"printing.js","sourcesContent":["import { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The number of spaces to be used as indentation in the pretty print\n * mode of the tokens.\n */\nexport const INDENTATION_SPACES:4 = 4;\n\n\n/**\n * Returns the separator of tokens depending in the spaces provided.\n *\n * If no spaces provided this means the printing mode is in compact\n * and so a blank space will be returned, otherwise a new line will\n * be the one returned.\n *\n * @param spaces The spaces of the current indentation of the tokens.\n */\nexport function getSeparator( spaces?:number ):string {\n\tif( spaces === void 0 ) return \" \";\n\treturn \"\\n\";\n}\n\n/**\n * Get the full indentation for a token line printing.\n *\n * If no spaces is provided, this means the printing mode is in\n * compact and no indentation is needed and so a empty string will be\n * returned, even if extra spaces are also provided.\n *\n * Otherwise, a string with the sum of the spaces and the extra ones\n * as empty spaces will be returned..\n *\n * @param spaces The spaces of the current indentation of a line.\n * @param extra Extra spaces to be added in the indentation line.\n */\nexport function getIndentation( spaces?:number, extra?:number ):string {\n\tif( spaces === void 0 ) return \"\";\n\n\tif( extra ) spaces += extra;\n\treturn \" \".repeat( spaces );\n}\n\n/**\n * Returns the sum of the provided spaces with the extra ones.\n *\n * If spaces is undefined it means the current printing mode is\n * compact and so undefined will be returned.\n *\n * @param spaces The spaces of the current indentation of a line.\n * @param extra The extra spaces to be added in the indentation.\n */\nexport function addSpaces( spaces:number | undefined, extra:number ):number | undefined {\n\tif( spaces === void 0 ) return spaces;\n\treturn spaces + extra;\n}\n\n\n/**\n * Returns the printing of a group of tokens that are contained in a\n * specific block.\n *\n * @param spaces The spaces of the current indentation.\n * @param tags The close and open tag of the token container to print.\n * @param tokensSeparator The separator betaken the tokens.\n * @param tokens The actual tokens to be printed.\n */\nexport function getTokenContainerString( { spaces, tags, tokensSeparator, tokens }:{\n\tspaces:number | undefined,\n\ttags:{ open:string, close:string },\n\ttokensSeparator?:string;\n\ttokens:TokenNode[],\n} ):string {\n\tif( ! tokens.length ) return tags.open + tags.close;\n\n\tconst generalSeparator:string = getSeparator( spaces );\n\n\tconst tokensSpaces:number | undefined = addSpaces( spaces, INDENTATION_SPACES );\n\tconst strArrayTokens:string[] = tokens.map( ( token, index, array ) => {\n\t\tconst strToken:string = token.toString( tokensSpaces );\n\n\t\t// No separator or last one\n\t\tif( ! tokensSeparator || index === array.length - 1 ) return strToken;\n\n\t\t// Optional when not triple token\n\t\tif( tokensSeparator === \".\" && token.token !== \"subject\" ) return strToken;\n\n\t\treturn strToken + tokensSeparator;\n\t} );\n\n\n\tif( strArrayTokens.length === 1 && ! strArrayTokens[ 0 ].includes( \"\\n\" ) )\n\t\treturn tags.open + \" \" + strArrayTokens + \" \" + tags.close;\n\n\n\tconst tokensIndent:string = getIndentation( tokensSpaces );\n\tconst strTokens:string = strArrayTokens\n\t\t.map( x => tokensIndent + x )\n\t\t.join( generalSeparator );\n\n\tconst indent:string = getIndentation( spaces );\n\treturn tags.open +\n\t\tgeneralSeparator + strTokens + generalSeparator +\n\t\tindent + tags.close;\n}\n"]}