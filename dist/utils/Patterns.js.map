{"version":3,"sources":["utils/Patterns.ts"],"names":[],"mappings":";;AACA,+CAM8B;AAC9B,sCAIqB;AAErB,wBAAgC,QAAsC;IACrE,IAAI,MAAM,GAAW,IAAI,CAAC,SAAS,CAAE,QAAQ,CAAE,CAAC;IAEhD,IAAI,SAAS,GAAS,0BAAiB,CAAC;IACxC,IAAI,UAAU,GAAS,2BAAkB,CAAC;IAC1C,EAAE,CAAA,CAAE,IAAI,CAAC,WAAW,CAAE,MAAM,CAAG,CAAC,CAAC,CAAC;QACjC,SAAS,GAAG,yBAAgB,CAAC;QAC7B,UAAU,GAAG,0BAAiB,CAAC;IAChC,CAAC;IAED,MAAM,EAAG,SAAS,SAAK,MAAM,GAAE,UAAU,GAAG;AAC7C,CAAC;AAXD,wCAWC;AAED,mBAA2B,QAAsC;IAChE,IAAM,YAAY,GAAkB,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAE,QAAQ,CAAE,CAAC;IAExF,IAAI,aAAa,GAAW,EAAE,CAAC;IAC/B,IAAI,SAAS,GAAS,KAAK,CAAC,CAAC;IAE7B,YAAY,CAAC,OAAO,CAAE,UAAE,YAAY,EAAE,KAAK,EAAE,KAAK;QACjD,IAAI,MAAM,GAAW,YAAY,CAAC,UAAU,EAAE,CAAC;QAE/C,EAAE,CAAA,CAAE,SAAS,KAAK,gCAAuB,IAAI,CAAE,MAAM,CAAE,CAAC,CAAE,YAAY,mBAAU,IAAI,MAAM,CAAE,CAAC,CAAE,KAAK,yBAAgB,IAAI,MAAM,CAAE,CAAC,CAAE,KAAK,0BAAiB,CAAG,CAAC;YAAC,aAAa,CAAC,GAAG,EAAE,CAAC;QAElL,aAAa,CAAC,IAAI,OAAlB,aAAa,EAAU,MAAM,EAAG;QAEhC,SAAS,GAAG,MAAM,CAAE,MAAM,CAAC,MAAM,GAAG,CAAC,CAAE,CAAC;QACxC,EAAE,CAAA,CAAE,KAAK,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,SAAS,KAAK,0BAAiB,IAAI,SAAS,KAAK,2BAAmB,CAAC,CAAC,CAAC;YACtG,aAAa,CAAC,IAAI,CAAE,SAAS,GAAG,gCAAuB,CAAE,CAAC;QAC3D,CAAC;IACF,CAAC,CAAE,CAAC;IAEJ,MAAM,CAAC,aAAa,CAAC;AACtB,CAAC;AApBD,8BAoBC;AAED,qBAA6B,MAAc;IAC1C,MAAM,CAAC,MAAM,CAAC,IAAI,CAAE,UAAA,KAAK,IAAI,OAAA,KAAK,YAAY,sBAAa,IAAI,CAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,CAAE,CAAC,OAAO,CAAE,KAAK,CAAE,OAAO,CAAE,CAAE,KAAK,CAAE,CAAC,EAA3F,CAA2F,CAAE,KAAK,KAAK,CAAC,CAAC;AACvI,CAAC;AAFD,kCAEC","file":"Patterns.js","sourcesContent":["import { GraphPattern } from \"./../patterns\";\nimport {\n\tCLOSE_MULTI_BLOCK,\n\tCLOSE_SINGLE_BLOCK,\n\tGRAPH_PATTERN_SEPARATOR,\n\tOPEN_MULTI_BLOCK,\n\tOPEN_SINGLE_BLOCK,\n} from \"./../patterns/tokens\";\nimport {\n\tIdentifier,\n\tNewLineSymbol,\n\tToken,\n} from \"./../tokens\";\n\nexport function getBlockTokens( patterns:GraphPattern | GraphPattern[] ):Token[] {\n\tlet tokens:Token[] = this.getTokens( patterns );\n\n\tlet openToken:Token = OPEN_SINGLE_BLOCK;\n\tlet closeToken:Token = CLOSE_SINGLE_BLOCK;\n\tif( this.isMultiLine( tokens ) ) {\n\t\topenToken = OPEN_MULTI_BLOCK;\n\t\tcloseToken = CLOSE_MULTI_BLOCK;\n\t}\n\n\treturn [ openToken, ...tokens, closeToken ];\n}\n\nexport function getTokens( patterns:GraphPattern | GraphPattern[] ):Token[] {\n\tconst patternArray:GraphPattern[] = Array.isArray( patterns ) ? patterns : [ patterns ];\n\n\tlet triplesTokens:Token[] = [];\n\tlet lastToken:Token = void 0;\n\n\tpatternArray.forEach( ( graphPattern, index, array ) => {\n\t\tlet tokens:Token[] = graphPattern.getPattern();\n\n\t\tif( lastToken === GRAPH_PATTERN_SEPARATOR && ( tokens[ 0 ] instanceof Identifier || tokens[ 0 ] === OPEN_MULTI_BLOCK || tokens[ 0 ] === OPEN_SINGLE_BLOCK ) ) triplesTokens.pop();\n\n\t\ttriplesTokens.push( ...tokens );\n\n\t\tlastToken = tokens[ tokens.length - 1 ];\n\t\tif( index < array.length - 1 && lastToken !== CLOSE_MULTI_BLOCK && lastToken !== CLOSE_SINGLE_BLOCK ) {\n\t\t\ttriplesTokens.push( lastToken = GRAPH_PATTERN_SEPARATOR );\n\t\t}\n\t} );\n\n\treturn triplesTokens;\n}\n\nexport function isMultiLine( tokens:Token[] ):boolean {\n\treturn tokens.find( token => token instanceof NewLineSymbol && [ \".\", \";\", \",\", \"\" ].indexOf( token[ \"value\" ] ) !== - 1 ) !== void 0;\n}\n"],"sourceRoot":"../../src"}